<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Z-13: The Quarantine â€” Full</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root { --accent: #c73b3b; --muted: #bfc3c7; --hud-bg: rgba(6,6,8,0.74); }
  html,body { height:100%; margin:0; background:#000; color:#fff; font-family:Inter, system-ui, Arial; overflow:hidden; }
  canvas { display:block; width:100%; height:100vh; }
  /* Loading/menu */
  #loading { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; z-index:900; background:linear-gradient(180deg,#000,#070707); }
  #progressBar{ width:60%; height:14px; border-radius:8px; background:rgba(255,255,255,0.04); overflow:hidden; margin-top:12px; }
  #progressFill{ height:100%; width:0%; background:linear-gradient(90deg,#c73b3b,#ff7b7b); transition:width 0.2s; }
  #menu{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:890; }
  .menu-card{ width:min(980px,94%); padding:22px; border-radius:12px; background:rgba(0,0,0,0.5); text-align:center; }
  h1.title{ margin:0; font-size:36px; color:#fff; text-shadow:0 8px 24px rgba(0,0,0,0.8); }
  .map-row{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-top:12px; }
  .map-card{ padding:8px 12px; border-radius:8px; background:rgba(255,255,255,0.03); cursor:pointer; font-weight:700; }
  .map-card.active{ outline:2px solid rgba(199,59,59,0.9); }
  .btn{ background:var(--accent); border:none; color:#fff; padding:10px 14px; border-radius:8px; cursor:pointer; margin:6px; }
  .btn.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); }
  /* HUD */
  #hud{ position:fixed; left:12px; top:12px; z-index:860; background:var(--hud-bg); color:#fff; padding:10px; border-radius:10px; min-width:260px; display:none; }
  #weaponUI{ position:fixed; right:12px; bottom:12px; z-index:860; background:var(--hud-bg); color:#fff; padding:10px; border-radius:10px; min-width:220px; display:none; }
  #crosshair{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:855; color:#fff; display:none; font-size:20px; pointer-events:none; }
  #pickupPrompt{ position:fixed; left:50%; bottom:18%; transform:translateX(-50%); z-index:854; background:rgba(0,0,0,0.6); color:#fff; padding:8px 12px; border-radius:8px; display:none; }
  #pauseOverlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:880; }
  .pause-card{ background:rgba(0,0,0,0.6); padding:20px; border-radius:12px; color:#fff; text-align:center; }
  #gameOver{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:895; }
  .save-toast{ position:fixed; right:12px; bottom:12px; padding:8px 12px; border-radius:8px; background:rgba(0,0,0,0.6); color:#fff; z-index:920; }
  #fps{ position:fixed; right:8px; top:8px; color:#ddd; z-index:920; display:none; }
  #pointerHint{ position:fixed; left:50%; top:78%; transform:translateX(-50%); z-index:855; padding:8px 12px; border-radius:8px; background:rgba(0,0,0,0.36); color:#fff; display:none; }
</style>
</head>
<body>
  <!-- Loading -->
  <div id="loading" aria-hidden="false">
    <h2 style="color:#fff;margin:0">LOADING Z-13: THE QUARANTINEâ€¦</h2>
    <div style="color:var(--muted);margin-top:8px" id="loadingText">Preparing assets...</div>
    <div id="progressBar"><div id="progressFill"></div></div>
  </div>

  <!-- Menu -->
  <div id="menu" aria-hidden="true">
    <div class="menu-card">
      <h1 class="title">Z-13: The Quarantine</h1>
      <div style="color:var(--muted);margin-top:8px">Wave survival â€¢ Kill required zombies to progress â€¢ Save/load</div>
      <div style="margin-top:14px;color:var(--muted);font-size:13px">Select Map</div>
      <div class="map-row" id="mapRow"></div>
      <div style="margin-top:12px">
        <button id="startBtn" class="btn">Start Game</button>
        <button id="loadBtn" class="btn ghost" style="display:none">Load Save</button>
        <button id="deleteBtn" class="btn ghost" style="display:none">Delete Save</button>
        <button id="creditsBtn" class="btn ghost">Credits</button>
      </div>
    </div>
  </div>

  <!-- Pointer Hint -->
  <div id="pointerHint">ðŸŽ¯ Click to lock mouse â€¢ ESC to unlock</div>

  <!-- Pickup prompt -->
  <div id="pickupPrompt">[E] Pick up</div>

  <!-- HUD -->
  <div id="hud" aria-live="polite">
    <div style="display:flex;justify-content:space-between"><div>Health</div><div id="healthVal">100</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Score</div><div id="scoreVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Wave</div><div id="waveVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Zombies Left</div><div id="zLeft">0</div></div>
  </div>

  <!-- Weapon UI -->
  <div id="weaponUI">
    <div id="weaponName">Pistol</div>
    <div style="font-size:13px;margin-top:6px">Ammo: <span id="ammoVal">12</span>/<span id="reserveVal">48</span></div>
    <div id="powerups" style="margin-top:8px;font-size:12px;color:var(--muted)"></div>
  </div>

  <!-- Pause -->
  <div id="pauseOverlay"><div class="pause-card">
    <h2>Paused</h2>
    <div style="margin-top:8px">
      <button id="resumeBtn" class="btn">Resume</button>
      <button id="saveBtn" class="btn">Save</button>
      <button id="restartBtn" class="btn">Restart</button>
      <button id="menuBtn" class="btn ghost">Main Menu</button>
    </div>
    <div style="margin-top:10px;color:var(--muted);font-size:13px">Settings placeholder â€” sensitivity & volume</div>
  </div></div>

  <!-- Game Over / Victory -->
  <div id="gameOver" style="display:none"><div style="background:rgba(0,0,0,0.8);padding:24px;border-radius:12px;text-align:center;color:#fff">
    <h1 id="goTitle">You Died</h1>
    <div id="goText" style="margin-top:8px">Score: 0</div>
    <div style="margin-top:12px"><button id="retryBtn" class="btn">Retry</button><button id="goMenuBtn" class="btn ghost">Main Menu</button></div>
  </div></div>

  <div id="fps"></div>
  <div id="progressDebug" style="display:none"></div>

  <canvas id="gameCanvas"></canvas>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
/* Z-13: The Quarantine â€” Full single-file build
   Features:
   - Loading screen (simulated assets to avoid hang)
   - Main Menu / Map select / Save & Load
   - Wave system (kill X to progress)
   - Weapons: Pistol, Rifle, Shotgun (reload, ammo)
   - Items: ammo, medkits, grenades (E to pick up)
   - Multiple maps (distinct fog/props)
   - Zombies: walkers, runners, exploders
   - Loot drops, HUD, pause/save, victory/game over
   - Basic procedural sfx (no external files)
*/

/* ---------------- UI refs ---------------- */
const loading = document.getElementById('loading');
const progressFill = document.getElementById('progressFill');
const loadingText = document.getElementById('loadingText');
const menu = document.getElementById('menu');
const mapRow = document.getElementById('mapRow');
const startBtn = document.getElementById('startBtn');
const loadBtn = document.getElementById('loadBtn');
const deleteBtn = document.getElementById('deleteBtn');
const creditsBtn = document.getElementById('creditsBtn');
const pointerHint = document.getElementById('pointerHint');
const pickupPrompt = document.getElementById('pickupPrompt');
const hud = document.getElementById('hud');
const healthVal = document.getElementById('healthVal');
const scoreVal = document.getElementById('scoreVal');
const waveVal = document.getElementById('waveVal');
const zLeftEl = document.getElementById('zLeft');
const weaponUI = document.getElementById('weaponUI');
const weaponNameEl = document.getElementById('weaponName');
const ammoVal = document.getElementById('ammoVal');
const reserveVal = document.getElementById('reserveVal');
const powerupsEl = document.getElementById('powerups');
const crosshair = document.getElementById('crosshair');
const pauseOverlay = document.getElementById('pauseOverlay');
const resumeBtn = document.getElementById('resumeBtn');
const saveBtn = document.getElementById('saveBtn');
const restartBtn = document.getElementById('restartBtn');
const menuBtn = document.getElementById('menuBtn');
const gameOverDiv = document.getElementById('gameOver');
const goTitle = document.getElementById('goTitle');
const goText = document.getElementById('goText');
const retryBtn = document.getElementById('retryBtn'), goMenuBtn = document.getElementById('goMenuBtn');
const fpsEl = document.getElementById('fps');
const canvas = document.getElementById('gameCanvas');

/* ---------------- Globals ---------------- */
let scene, camera, renderer, clock;
let running=false, gameStarted=false, paused=false;
let playerHealth=100, score=0, wave=0;
let zombies = [], pickups = [], props = [], particlePools = [];
let zombiesThisWave=0, killsThisWave=0;
let lastSpawn=0, spawnInterval=1200, intermissionEnd=0;
let lastFrame = performance.now();
let audioCtx = null;
let pointerLockEnabled=false;

/* ---------------- Maps ---------------- */
const maps = [
  {id:'graveyard', name:'Graveyard', fog:0x0b0b10, fogDensity:0.014, spawnBias:0.0},
  {id:'city', name:'City Ruins', fog:0x111017, fogDensity:0.012, spawnBias:0.05},
  {id:'facility', name:'Quarantine Facility', fog:0x070707, fogDensity:0.0095, spawnBias:0.12},
  {id:'forest', name:'Forest Outbreak', fog:0x08121a, fogDensity:0.015, spawnBias:-0.05}
];
let selectedMap = maps[0];

/* build map selector UI */
maps.forEach((m,i)=>{
  const el = document.createElement('div'); el.className='map-card'; el.textContent = m.name; el.title = m.name;
  if(i===0) el.classList.add('active');
  el.addEventListener('click', ()=>{ document.querySelectorAll('.map-card').forEach(x=>x.classList.remove('active')); el.classList.add('active'); selectedMap = m; });
  mapRow.appendChild(el);
});

/* ---------------- Weapons & inventory ---------------- */
const weapons = {
  pistol:{name:'Pistol',mag:12,reserve:48,fireRate:260,damage:4,automatic:false,reload:900},
  rifle:{name:'Rifle',mag:30,reserve:120,fireRate:110,damage:1.8,automatic:true,reload:1400},
  shotgun:{name:'Shotgun',mag:6,reserve:36,fireRate:700,damage:6,pellets:7,automatic:false,reload:1300}
};
let currentWeapon='pistol';
let weaponState = {}; for(const k in weapons) weaponState[k] = {ammo:weapons[k].mag, reserve:weapons[k].reserve, reloading:false, lastShot:0};

let inventory = {grenades:2, medkits:1, batteries:1};
let activePowerups = {}; // name -> {expires}

/* ---------------- Audio helpers ---------------- */
function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ audioCtx=null; console.warn('Audio disabled'); } } }
function sfx(freq=440,dur=0.06,type='sine',vol=0.1){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; o.connect(g); g.gain.value = 0.0001; g.connect(audioCtx.destination);
  g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime+0.01);
  o.start(); o.stop(audioCtx.currentTime+dur);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur);
}

/* ---------------- Loading (simulated, reliable) ---------------- */
async function simulatedLoad(){
  const assets = ['shaders','textures','sounds','models','ui','maps','particles','weapons','sfx1','sfx2','sfx3'];
  for(let i=0;i<assets.length;i++){
    await new Promise(r => setTimeout(r, 80 + Math.random()*160));
    progressFill.style.width = Math.round(((i+1)/assets.length)*100) + '%';
    loadingText.textContent = 'Loading ' + assets[i] + '...';
  }
  await new Promise(r => setTimeout(r, 180));
  loading.style.display = 'none';
  menu.style.display = 'flex';
  try{ const exists = !!localStorage.getItem('z13_save_v1'); loadBtn.style.display = exists ? 'inline-block' : 'none'; deleteBtn.style.display = exists ? 'inline-block' : 'none'; }catch(e){}
}

/* ---------------- Three.js init ---------------- */
function initScene(){
  // clear previous if any
  if(renderer){ try{ renderer.forceContextLoss(); renderer.domElement.remove(); }catch(e){} renderer=null; }

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(selectedMap.fog, selectedMap.fogDensity);
  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2500);
  camera.position.set(0,1.6,0);

  renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);

  // lighting
  const hemi = new THREE.HemisphereLight(0x8888aa, 0x222222, 0.9); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff0c8, 0.5); dir.position.set(8,12,6); scene.add(dir);

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,4,4), new THREE.MeshStandardMaterial({color:0x0f0f10}));
  ground.rotation.x = -Math.PI/2; scene.add(ground);

  // props (map-specific)
  props = [];
  if(selectedMap.id === 'graveyard'){
    for(let i=0;i<80;i++){
      if(Math.random() < 0.6){
        const t = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1 + Math.random()*1.6, 0.25), new THREE.MeshStandardMaterial({color:0x2b2b2b}));
        t.position.set((Math.random()-0.5)*200, (t.geometry.parameters.height)/2, (Math.random()-0.5)*200);
        t.rotation.y = Math.random()*Math.PI*2; scene.add(t); props.push(t);
      } else {
        const c = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.2,1.6), new THREE.MeshStandardMaterial({color:0x332b2b}));
        c.position.set((Math.random()-0.5)*200,0.6,(Math.random()-0.5)*200); scene.add(c); props.push(c);
      }
    }
  } else if(selectedMap.id === 'city'){
    for(let i=0;i<60;i++){
      const b = new THREE.Mesh(new THREE.BoxGeometry(2+Math.random()*6, 1+Math.random()*8, 1+Math.random()*6), new THREE.MeshStandardMaterial({color:0x141414}));
      b.position.set((Math.random()-0.5)*200, (b.geometry.parameters.height)/2, (Math.random()-0.5)*200); b.rotation.y = Math.random()*Math.PI*2; scene.add(b); props.push(b);
    }
  } else if(selectedMap.id === 'facility'){
    for(let i=0;i<50;i++){
      const crate = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.2,1.6), new THREE.MeshStandardMaterial({color:0x222222}));
      crate.position.set((Math.random()-0.5)*140,0.6,(Math.random()-0.5)*140); scene.add(crate); props.push(crate);
    }
  } else {
    for(let i=0;i<60;i++){
      const p = new THREE.Mesh(new THREE.BoxGeometry(1,1+Math.random()*3,1), new THREE.MeshStandardMaterial({color:0x25302a}));
      p.position.set((Math.random()-0.5)*160,p.geometry.parameters.height/2,(Math.random()-0.5)*160); scene.add(p); props.push(p);
    }
  }

  // explosive barrels
  for(let i=0;i<12;i++){
    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.8,12), new THREE.MeshStandardMaterial({color:0x6b2b2b}));
    barrel.position.set((Math.random()-0.5)*120,0.4,(Math.random()-0.5)*120); barrel.userData = {explosive:true}; scene.add(barrel); props.push(barrel);
  }

  // particle pools (for blood, dust)
  particlePools = []; for(let i=0;i<4;i++){ const max=120; const geom=new THREE.BufferGeometry(); const arr=new Float32Array(max*3); geom.setAttribute('position', new THREE.BufferAttribute(arr,3)); const mat=new THREE.PointsMaterial({size:0.08,transparent:true,opacity:0.92}); const pts=new THREE.Points(geom,mat); pts.userData={max,alive:[]}; scene.add(pts); particlePools.push(pts); }
  clock = new THREE.Clock();
  window.addEventListener('resize', onResize);
}

/* ------------- Particles ------------- */
function spawnParticles(pos,color=0x8b0000,count=12,speed=3){
  for(const pool of particlePools){
    const ud = pool.userData;
    if(ud.alive.length + count <= ud.max){
      for(let i=0;i<count;i++) ud.alive.push({px:pos.x,py:pos.y,pz:pos.z,vx:(Math.random()-0.5)*speed,vy:Math.random()*speed*0.6+0.6,vz:(Math.random()-0.5)*speed,life:0,max:0.4+Math.random()*0.6});
      pool.material.color.setHex(color);
      pool.geometry.attributes.position.needsUpdate = true;
      return;
    }
  }
}
function updateParticles(delta){
  for(const pool of particlePools){
    const ud = pool.userData; const arr = pool.geometry.attributes.position.array; let k=0;
    for(let i=ud.alive.length-1;i>=0;i--){
      const p = ud.alive[i];
      p.life += delta;
      p.vy -= 9.8*delta*0.7;
      p.px += p.vx*delta; p.py += p.vy*delta; p.pz += p.vz*delta;
      arr[k*3] = p.px; arr[k*3+1] = p.py; arr[k*3+2] = p.pz; k++;
      if(p.life >= p.max) ud.alive.splice(i,1);
    }
    pool.geometry.attributes.position.needsUpdate = true;
  }
}

/* ------------- Zombies ------------- */
function spawnZombie(type=null){
  const types = ['walker','runner','exploder'];
  let t = type || (Math.random() < 0.08 ? 'runner' : (Math.random() < 0.06 ? 'exploder' : 'walker'));
  const colorMap = {walker:0x3db34b,runner:0x3b7fd9,exploder:0xd94b3b};
  const mat = new THREE.MeshStandardMaterial({color:colorMap[t]});
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.05,0.5), mat);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.45,0.45,0.45), new THREE.MeshStandardMaterial({color:0x4a5a33}));
  head.position.set(0,0.9,0);
  const g = new THREE.Group(); g.add(torso); g.add(head);
  const angle = Math.random()*Math.PI*2;
  const r = 30 + Math.random()*40 + (selectedMap.spawnBias||0)*20;
  g.position.set(camera.position.x + Math.cos(angle)*r, 0.6, camera.position.z + Math.sin(angle)*r);
  if(t==='runner') g.userData = {type:'runner', hp:3 + Math.floor(wave*0.2), speed:1.1, attack:6};
  else if(t==='exploder') g.userData = {type:'exploder', hp:3 + Math.floor(wave*0.4), speed:0.5, explodeRadius:2.4, attack:6};
  else g.userData = {type:'walker', hp:3 + Math.floor(Math.random()*2 + wave*0.2), speed:0.45 + Math.random()*0.2, attack:6};
  scene.add(g); zombies.push(g); return g;
}

function killZombie(z){
  if(!z) return;
  spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.6,0)),0x9b1b1b,22,4.2);
  try{ scene.remove(z); }catch(e){}
  const idx = zombies.indexOf(z); if(idx >= 0) zombies.splice(idx,1);
  killsThisWave++; score += (z.userData.type==='runner'?15:10) + Math.floor(Math.random()*8);
  scoreVal.textContent = score;
  // loot drop chance
  if(Math.random() < 0.34){ const type = Math.random() < 0.6 ? 'ammo' : (Math.random() < 0.5 ? 'medkit' : 'grenade'); const pick = spawnPickup(z.position.clone(), type); pick.position.add(new THREE.Vector3((Math.random()-0.5)*1.2,0.4,(Math.random()-0.5)*1.2)); }
  // exploder triggers shock
  if(z.userData && z.userData.type === 'exploder'){
    for(const o of zombies.slice()){
      const d = o.position.distanceTo(z.position);
      if(d < z.userData.explodeRadius) { o.userData.hp -= 2 + Math.floor(Math.random()*3); if(o.userData.hp <= 0) killZombie(o); }
    }
  }
  checkWaveClear();
}

/* ------------- Pickups (E to collect) ------------- */
function spawnPickup(pos, type='ammo'){
  const color = type==='ammo' ? 0x2b6cff : (type==='medkit' ? 0xff6b6b : 0xffe066);
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.28,10,10), new THREE.MeshStandardMaterial({color:color, emissive: color, emissiveIntensity:0.25}));
  mesh.position.copy(pos); mesh.userData = {pickup:true, type}; scene.add(mesh); pickups.push(mesh); return mesh;
}
function tryPickup(){
  let nearest=null, nd=Infinity;
  for(const p of pickups){ const d = p.position.distanceTo(camera.position); if(d < 2 && d < nd){ nd=d; nearest=p; } }
  if(!nearest) return;
  const type = nearest.userData.type; scene.remove(nearest); pickups = pickups.filter(x=>x!==nearest);
  if(type === 'ammo'){ for(const k in weaponState) weaponState[k].reserve += 8 + Math.floor(Math.random()*12); sfx(920,0.08,'triangle',0.12); showToast('+ Ammo'); }
  else if(type === 'medkit'){ playerHealth = Math.min(100, playerHealth + 35); healthVal.textContent = playerHealth; sfx(720,0.08,'sine',0.12); showToast('+35 HP'); }
  else if(type === 'grenade'){ inventory.grenades = (inventory.grenades||0) + 1; showToast('+1 Grenade'); sfx(820,0.08,'sine',0.12); }
  updateAmmoUI();
}
function updatePickupPrompt(){
  let near=false;
  for(const p of pickups) if(p.position.distanceTo(camera.position) < 2.0){ near=true; break; }
  pickupPrompt.style.display = near ? 'block' : 'none';
}
function showToast(txt){
  const t = document.createElement('div'); t.className='save-toast'; t.textContent = txt; document.body.appendChild(t); setTimeout(()=> t.style.opacity='0',900); setTimeout(()=> t.remove(),1400);
}

/* ------------- Shooting & weapons ------------- */
function changeWeapon(key){ currentWeapon = key; weaponNameEl.textContent = weapons[key].name; updateAmmoUI(); }
function updateAmmoUI(){ const st = weaponState[currentWeapon]; ammoVal.textContent = Math.round(st.ammo); reserveVal.textContent = Math.round(st.reserve); weaponNameEl.textContent = weapons[currentWeapon].name; }
function attemptShoot(){
  const k = currentWeapon, w = weapons[k], st = weaponState[k];
  if(st.reloading) return; const now = performance.now();
  if(now - st.lastShot < w.fireRate) return;
  if(st.ammo <= 0){ reloadWeapon(); return; }
  st.lastShot = now; st.ammo--; updateAmmoUI(); ensureAudio(); sfx(900+Math.random()*300,0.05,'square',0.12);
  // raycast
  const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
  const dirBase = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  if(k==='shotgun'){
    for(let i=0;i<w.pellets;i++){
      const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*0.14,(Math.random()-0.5)*0.14,(Math.random()-0.5)*0.14)).normalize();
      rayDamage(origin,d,w.damage+Math.floor(Math.random()*2),10);
    }
  } else {
    rayDamage(origin, dirBase, w.damage, 160);
  }
  flashMuzzle();
}
function rayDamage(origin,dir,damage,maxRange){
  const ray = new THREE.Raycaster(origin,dir,0,maxRange);
  let hit=null, hitDist=Infinity;
  for(const z of zombies){
    const box = new THREE.Box3().setFromObject(z);
    if(ray.ray.intersectsBox(box)){
      const pt = ray.ray.intersectBox(box, new THREE.Vector3());
      const d = origin.distanceTo(pt);
      if(d < hitDist){ hitDist = d; hit = {z,pt}; }
    }
  }
  if(hit){
    const {z,pt} = hit; const falloff = Math.max(0.4, 1 - hitDist/maxRange); const applied = Math.max(1, Math.round(damage * falloff));
    z.userData.hp -= applied; spawnParticles(pt, 0x9b1b1b, 12, 3.2); sfx(220+Math.random()*120,0.05,'sawtooth',0.11);
    if(z.userData.hp <= 0) killZombie(z); else z.position.add(new THREE.Vector3((Math.random()-0.5)*0.2,0,(Math.random()-0.5)*0.2));
  } else {
    spawnParticles(origin.clone().add(dir.clone().multiplyScalar(maxRange*0.95)), 0xffaa66, 6, 1.6);
  }
}
function flashMuzzle(){ const el=document.createElement('div'); el.style.position='fixed'; el.style.left='50%'; el.style.top='58%'; el.style.transform='translate(-50%,-50%)'; el.style.width='26px'; el.style.height='12px'; el.style.borderRadius='8px'; el.style.background='rgba(255,220,160,0.96)'; el.style.zIndex=9999; document.body.appendChild(el); setTimeout(()=>el.remove(),36); }
function reloadWeapon(){ const st = weaponState[currentWeapon]; const w = weapons[currentWeapon]; if(st.reloading) return; if(st.ammo >= w.mag) return; if(st.reserve <= 0) return; st.reloading = true; setTimeout(()=>{ const need=w.mag-st.ammo; const take=Math.min(need, st.reserve); st.reserve -= take; st.ammo += take; st.reloading=false; updateAmmoUI(); sfx(420,0.08,'sine',0.12); }, w.reload); }

/* ------------- Explosions ------------- */
function spawnExplosion(pos, damage){
  spawnParticles(pos, 0xff9a2b, 28, 4.6); sfx(80,0.6,'sawtooth',0.18);
  for(const z of zombies.slice()){
    const d = z.position.distanceTo(pos);
    if(d < 4.2){ z.userData.hp -= Math.max(2, Math.round(damage*(1 - d/4.2))); if(z.userData.hp <= 0) killZombie(z); }
  }
  for(const p of props){
    if(p.userData && p.userData.explosive){
      const d = p.position.distanceTo(pos);
      if(d < 5.2){
        spawnParticles(p.position, 0xff7a2b, 40, 6.0);
        try{ scene.remove(p); }catch(e){} // remove barrel
      }
    }
  }
}

/* ------------- Wave system (fixed) ------------- */
function spawnWave(count){
  zombiesThisWave = count; killsThisWave = 0; zLeftEl.textContent = zombiesThisWave - killsThisWave;
  for(let i=0;i<count;i++){
    setTimeout(()=> spawnZombie(), i*120 + Math.random()*400);
  }
}
function startWave(){
 
