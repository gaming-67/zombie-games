<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Dash</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom styles for full-screen canvas and menu */
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #000; }
        canvas { display: block; }
        
        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            z-index: 100;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
        }
        
        /* Layout for Score/Health */
        .score-health-group {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        /* --- Menu Button Styling --- */
        .game-button {
            background-image: linear-gradient(to right, #6d28d9 0%, #a855f7 51%, #6d28d9 100%);
            margin: 10px;
            padding: 15px 45px;
            text-align: center;
            text-transform: uppercase;
            transition: 0.5s;
            background-size: 200% auto;
            color: white;            
            box-shadow: 0 0 20px #a855f7;
            border-radius: 9999px;
            display: block;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto; /* Allow interaction */
        }
        .game-button:hover:not([disabled]) {
            background-position: right center;
            color: #fff;
            text-shadow: 0 0 10px white;
            transform: scale(1.05);
        }
        .game-button[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            background-image: none !important;
            background-color: #374151 !important;
            pointer-events: none;
        }

        .buy-button {
            background-image: linear-gradient(to right, #00bfff 0%, #00ffff 51%, #00bfff 100%);
            box-shadow: 0 0 15px #00ffff;
            color: #000;
        }
        
        /* Game Over specific styles */
        #game-over-container {
            display: none;
        }
        
        .score-text {
            color: #ffffff;
            font-weight: bold;
            font-size: 1.5rem;
            text-shadow: 0 0 10px #ff00ff; /* Stronger neon shadow */
        }

        .dust-text {
            color: #fcd34d; /* Yellow */
            font-weight: bold;
            font-size: 1.5rem;
            text-shadow: 0 0 10px #facc15;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Health Icon Style */
        .health-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-color: #00ffff; /* Cyan color */
            border-radius: 4px;
            box-shadow: 0 0 5px #00ffff;
            margin-right: 5px;
            transition: all 0.2s;
        }

        /* Full screen flash for Game Over */
        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #8b0000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s;
            z-index: 2000;
        }

        /* Cutscene Text Animation */
        .cutscene-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 3rem;
            font-weight: 700;
            text-shadow: 0 0 10px #6d28d9;
            opacity: 0;
            transition: opacity 1s, transform 0.5s;
            z-index: 1001;
            text-align: center;
        }
        
        /* Cutscene Skip Hint */
        #cutscene-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            z-index: 1001;
            opacity: 0;
            transition: opacity 1s;
            pointer-events: none;
        }

        /* Shop Item Card */
        .shop-item-card {
            background-color: #1f2937; /* Dark Gray */
            padding: 16px;
            border-radius: 12px;
            border: 2px solid #a855f7;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.5);
            transition: transform 0.2s;
        }
        .shop-item-card:hover {
            transform: translateY(-3px);
            border-color: #00ffff;
        }
        .shop-dust-level {
            font-size: 1.1rem;
            font-weight: 500;
            margin-top: 5px;
            color: #facc15;
        }

        /* Skin Card Specific Styling */
        .skin-card {
            border: 3px solid transparent;
            cursor: pointer;
        }
        .skin-card-equipped {
            border-color: #00ff00; /* Green highlight for equipped */
            box-shadow: 0 0 20px #00ff00;
        }
        .skin-card-color {
            width: 100%;
            height: 50px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    
    <!-- FIREBASE SETUP -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Log all Firebase activities to the console (for debugging)
        setLogLevel('Debug');

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth;
        let userId = null;
        let isAuthReady = false;

        // --- Global Data Object (Managed by Firestore) ---
        window.playerData = {
            userId: null,
            highScore: 0,
            cosmicDust: 0,
            maxHealthLevel: 1,      
            dustMultiplierLevel: 1, 
            initialShieldLevel: 1,
            // NEW SKIN FIELDS
            equippedSkinId: 'default',
            purchasedSkins: ['default'],
        };
        
        // --- Shop Data and Logic ---
        
        // 1. UPGRADES
        const upgradeItems = [
            {
                id: 'maxHealthLevel',
                name: 'Max Health Upgrade',
                description: 'Permanently increases ship maximum health by 1 HP.',
                maxLevel: 5,
                getCost: (level) => Math.round(50 * Math.pow(1.5, level - 1))
            },
            {
                id: 'dustMultiplierLevel',
                name: 'Dust Multiplier',
                description: 'Increases the amount of Cosmic Dust collected by 25% per level.',
                maxLevel: 4,
                getCost: (level) => Math.round(75 * Math.pow(2.0, level - 1))
            },
            {
                id: 'initialShieldLevel',
                name: 'Start Shield Duration',
                description: 'Starts the game with a temporary shield for 1 additional second per level.',
                maxLevel: 3,
                getCost: (level) => Math.round(100 * Math.pow(2.5, level - 1))
            }
        ];
        
        // 2. SKINS (NEW)
        const shipSkins = [
            {
                id: 'default',
                name: 'Vanguard Grey',
                cost: 0,
                color: 0x8b5cf6, // Purple
                exhaustColor: 0xffa500, // Orange
                description: 'Standard issue chassis.'
            },
            {
                id: 'cyan_steel',
                name: 'Cyan Steel',
                cost: 500,
                color: 0x06b6d4, // Cyan
                exhaustColor: 0x00ffff, // Bright Cyan
                description: 'A slick, high-visibility chassis.'
            },
            {
                id: 'gold_elite',
                name: 'Gold Elite',
                cost: 1200,
                color: 0xfacc15, // Gold
                exhaustColor: 0xffe600, // Bright Gold
                description: 'Proof of a successful pilot. Pure luxury.'
            },
            {
                id: 'crimson_rage',
                name: 'Crimson Rage',
                cost: 2000,
                color: 0xdc2626, // Red
                exhaustColor: 0xff0000, // Bright Red
                description: 'Warning: Prone to aggressive piloting.'
            }
        ];
        
        // Helper to find skin data
        window.getSkinData = (id) => shipSkins.find(skin => skin.id === id);

        // Function to update the menu UI statistics
        window.updateMenuStatsUI = function() {
            if (window.playerData) {
                const highscoreDisplay = document.getElementById('high-score-display');
                const dustValueDisplay = document.getElementById('dust-value');
                
                if (highscoreDisplay) highscoreDisplay.textContent = `HIGH SCORE: ${Math.floor(window.playerData.highScore)}`;
                if (dustValueDisplay) dustValueDisplay.textContent = window.playerData.cosmicDust;
            }
        }

        // Function to update the upgrade tab UI 
        window.updateUpgradesShopUI = function() {
            const container = document.getElementById('upgrade-items-container');
            if (!container) return;
            
            container.innerHTML = ''; 
            if (!window.playerData) return;

            upgradeItems.forEach(item => {
                const currentLevel = window.playerData[item.id];
                const nextLevel = currentLevel + 1;
                const nextCost = item.getCost(nextLevel);
                
                const isMaxed = currentLevel >= item.maxLevel;
                const canAfford = window.playerData.cosmicDust >= nextCost;

                let levelStat = `Level ${currentLevel} / ${item.maxLevel}`;
                if (item.id === 'maxHealthLevel') {
                    levelStat += ` (Base HP: ${currentLevel + 2})`;
                } else if (item.id === 'dustMultiplierLevel') {
                    levelStat += ` (x${(1 + (currentLevel - 1) * 0.25).toFixed(2)} Dust)`;
                } else if (item.id === 'initialShieldLevel') {
                     levelStat += ` (+${(currentLevel - 1) * 1}s Start Shield)`;
                }

                let buttonHtml;
                if (isMaxed) {
                    buttonHtml = `<button disabled class="game-button px-4 py-2 w-full text-sm">MAX LEVEL</button>`;
                } else if (canAfford) {
                    buttonHtml = `<button data-item-id="${item.id}" data-cost="${nextCost}" class="game-button buy-button px-4 py-2 w-full text-sm purchase-upgrade-btn">BUY: ${nextCost} DUST</button>`;
                } else {
                    buttonHtml = `<button disabled class="game-button px-4 py-2 w-full text-sm">NEED ${nextCost} DUST</button>`;
                }

                const cardHtml = `
                    <div class="shop-item-card text-gray-100">
                        <h3 class="text-xl font-bold text-cyan-400 mb-2">${item.name}</h3>
                        <p class="text-sm text-gray-300 mb-3">${item.description}</p>
                        <p class="shop-dust-level">
                           <span class="text-yellow-400">${levelStat}</span>
                        </p>
                        ${buttonHtml}
                    </div>
                `;
                container.insertAdjacentHTML('beforeend', cardHtml);
            });
            
            container.querySelectorAll('.purchase-upgrade-btn').forEach(button => {
                if (button.hasAttribute('data-listener-attached')) return;
                
                button.addEventListener('click', (e) => {
                    const itemId = e.currentTarget.getAttribute('data-item-id');
                    const cost = parseInt(e.currentTarget.getAttribute('data-cost'));
                    window.handlePurchaseUpgrade(cost, itemId);
                });
                button.setAttribute('data-listener-attached', 'true');
            });
        }
        
        // NEW: Function to update the skins tab UI
        window.updateSkinsShopUI = function() {
            const container = document.getElementById('skin-items-container');
            if (!container) return;
            
            container.innerHTML = ''; 
            if (!window.playerData) return;
            
            const { cosmicDust, purchasedSkins, equippedSkinId } = window.playerData;

            shipSkins.forEach(skin => {
                const isPurchased = purchasedSkins.includes(skin.id);
                const isEquipped = skin.id === equippedSkinId;
                const canAfford = cosmicDust >= skin.cost;

                let buttonHtml;
                if (isEquipped) {
                    buttonHtml = `<button disabled class="game-button px-4 py-2 w-full text-sm skin-equip-btn" style="background-image:none; background-color:#16a34a;">EQUIPPED</button>`;
                } else if (isPurchased) {
                    buttonHtml = `<button data-skin-id="${skin.id}" class="game-button px-4 py-2 w-full text-sm skin-equip-btn" style="background-image: linear-gradient(to right, #4ade80 0%, #10b981 51%, #4ade80 100%); color: #000; box-shadow: 0 0 10px #4ade80;">EQUIP</button>`;
                } else if (canAfford) {
                    buttonHtml = `<button data-skin-id="${skin.id}" data-cost="${skin.cost}" class="game-button buy-button px-4 py-2 w-full text-sm purchase-skin-btn">BUY: ${skin.cost} DUST</button>`;
                } else {
                    buttonHtml = `<button disabled class="game-button px-4 py-2 w-full text-sm">NEED ${skin.cost} DUST</button>`;
                }

                const cardHtml = `
                    <div class="shop-item-card skin-card ${isEquipped ? 'skin-card-equipped' : ''}" data-skin-id="${skin.id}">
                        <div class="skin-card-color" style="background-color: #${skin.color.toString(16).padStart(6, '0')};"></div>
                        <h3 class="text-xl font-bold text-gray-100 mb-1">${skin.name}</h3>
                        <p class="text-sm text-gray-400 mb-3">${skin.description}</p>
                        ${buttonHtml}
                    </div>
                `;
                container.insertAdjacentHTML('beforeend', cardHtml);
            });
            
            // Attach event listeners for purchase and equip
            container.querySelectorAll('.purchase-skin-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const skinId = e.currentTarget.getAttribute('data-skin-id');
                    const cost = parseInt(e.currentTarget.getAttribute('data-cost'));
                    window.handlePurchaseSkin(cost, skinId);
                });
            });
            
            container.querySelectorAll('.skin-equip-btn:not([disabled])').forEach(button => {
                button.addEventListener('click', (e) => {
                    const skinId = e.currentTarget.getAttribute('data-skin-id');
                    window.handleEquipSkin(skinId);
                });
            });
        }


        // Function to initialize Firebase and authenticate
        async function initializeFirebase() {
            if (!firebaseConfig) {
                console.error("Firebase configuration not found. Cannot initialize Firestore.");
                return;
            }

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                userId = auth.currentUser?.uid || crypto.randomUUID();
                isAuthReady = true;
                
                console.log(`Firebase initialized. User ID: ${userId}`);
                setupFirestoreListeners();

            } catch (error) {
                console.error("Firebase authentication failed:", error);
            }
        }

        
        // Firestore Path Helpers (Private Data)
        const getUserDataPath = () => `/artifacts/${appId}/users/${userId}/gameData/stats`;

        // Function to set up real-time listener for player data
        function setupFirestoreListeners() {
            if (!isAuthReady || !userId) return;

            const userDocRef = doc(db, getUserDataPath());

            onSnapshot(userDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    window.playerData.highScore = data.highScore || 0;
                    window.playerData.cosmicDust = data.cosmicDust || 0;
                    window.playerData.maxHealthLevel = data.maxHealthLevel || 1;
                    window.playerData.dustMultiplierLevel = data.dustMultiplierLevel || 1; 
                    window.playerData.initialShieldLevel = data.initialShieldLevel || 1; 
                    // NEW SKIN FIELDS
                    window.playerData.equippedSkinId = data.equippedSkinId || 'default';
                    // Ensure purchasedSkins is an array, default to ['default']
                    window.playerData.purchasedSkins = Array.isArray(data.purchasedSkins) ? data.purchasedSkins : ['default']; 
                    
                    window.updateMenuStatsUI(); 
                    window.updateUpgradesShopUI(); 
                    window.updateSkinsShopUI();
                    
                    if (window.syncGameStats) {
                        window.syncGameStats();
                    }

                } else {
                    console.log("No player data found, creating initial record.");
                    // Create initial document if it doesn't exist
                    setDoc(userDocRef, {
                        highScore: 0,
                        cosmicDust: 0,
                        maxHealthLevel: 1,
                        dustMultiplierLevel: 1,
                        initialShieldLevel: 1,
                        equippedSkinId: 'default',
                        purchasedSkins: ['default'],
                        lastLogin: new Date().toISOString()
                    });
                }
            }, (error) => {
                console.error("Error listening to player data:", error);
            });
        }
        
        // Function to save score and currency (called on Game Over)
        window.saveGameData = async (newScore, collectedDust) => {
            if (!isAuthReady || !userId) return;

            const userDocRef = doc(db, getUserDataPath());
            const currentDust = window.playerData.cosmicDust;
            const currentHighScore = window.playerData.highScore;

            let updates = {};
            
            if (newScore > currentHighScore) {
                updates.highScore = newScore;
            }

            if (collectedDust > 0) {
                updates.cosmicDust = currentDust + collectedDust;
            }

            if (Object.keys(updates).length > 0) {
                try {
                    await updateDoc(userDocRef, updates);
                    console.log("Game data saved successfully.");
                } catch (e) {
                    console.error("Error updating document: ", e);
                }
            }
        };

        // Function to handle UPGRADE purchase
        window.handlePurchaseUpgrade = async (cost, levelKey) => {
            if (!isAuthReady || !userId) {
                console.error("Authentication not ready.");
                return false;
            }

            const currentData = window.playerData;
            
            if (currentData.cosmicDust < cost) {
                console.log("Not enough Cosmic Dust!");
                return false;
            }

            const userDocRef = doc(db, getUserDataPath());

            try {
                await updateDoc(userDocRef, {
                    cosmicDust: currentData.cosmicDust - cost,
                    [levelKey]: currentData[levelKey] + 1
                });
                console.log("Upgrade purchased successfully.");
                return true;
            } catch (e) {
                console.error("Error purchasing upgrade: ", e);
                return false;
            }
        };
        
        // NEW: Function to handle SKIN purchase
        window.handlePurchaseSkin = async (cost, skinId) => {
            if (!isAuthReady || !userId) {
                console.error("Authentication not ready.");
                return false;
            }

            const currentData = window.playerData;
            
            if (currentData.cosmicDust < cost) {
                console.log("Not enough Cosmic Dust!");
                return false;
            }

            const userDocRef = doc(db, getUserDataPath());

            try {
                await updateDoc(userDocRef, {
                    cosmicDust: currentData.cosmicDust - cost,
                    purchasedSkins: arrayUnion(skinId), // Add skin ID to array
                    equippedSkinId: skinId // Auto-equip the new skin
                });
                console.log(`Skin ${skinId} purchased and equipped successfully.`);
                return true;
            } catch (e) {
                console.error("Error purchasing skin: ", e);
                return false;
            }
        };
        
        // NEW: Function to handle SKIN equip
        window.handleEquipSkin = async (skinId) => {
            if (!isAuthReady || !userId) return;

            const userDocRef = doc(db, getUserDataPath());

            try {
                await updateDoc(userDocRef, {
                    equippedSkinId: skinId
                });
                console.log(`Skin ${skinId} equipped successfully.`);
                // The onSnapshot listener will handle the UI and game update
            } catch (e) {
                console.error("Error equipping skin: ", e);
            }
        };


        // Initialize Firebase on load
        initializeFirebase();

    </script>
    
    <!-- UI Container for Score, Health, and Shield -->
    <div class="ui-container">
        <div class="score-health-group">
            <!-- HEALTH DISPLAY -->
            <div id="health-display" class="text-cyan-400 font-bold text-lg"></div>
            <div id="score-display" class="score-text">SCORE: 0</div>
        </div>
        
        <div class="flex flex-col items-end gap-1">
            <!-- PAUSE BUTTON -->
            <button id="pause-button" class="game-button px-4 py-1 text-sm opacity-0 transition-opacity duration-300" 
                    style="background-image: none; background-color: #374151; pointer-events: auto;">
                PAUSE (ESC)
            </button>

            <div id="multiplier-status" class="score-text text-yellow-400 opacity-0 transition-opacity duration-300 text-base"></div>
            <div class="flex items-center gap-4">
                <div id="shield-status" class="score-text text-cyan-400 opacity-0 transition-opacity duration-300 text-base">SHIELD: READY</div>
                <div id="controls-hint" class="score-text text-sm text-gray-400 hidden md:block">Move: A/D or ←/→</div>
            </div>
        </div>
    </div>
    
    <!-- Cutscene Text Layers -->
    <div id="cutscene-text-1" class="cutscene-text text-purple-400">LOADING SHIP DATA...</div>
    <div id="cutscene-text-2" class="cutscene-text text-cyan-400">ENGAGING HYPERDRIVE.</div>
    <div id="cutscene-text-3" class="cutscene-text text-red-400">AWAITING DASH COMMAND.</div>
    
    <!-- Cutscene Skip Hint -->
    <div id="cutscene-hint">
        PRESS ANY KEY TO SKIP
    </div>

    <!-- Game Over Flash Layer -->
    <div id="flash-overlay"></div>

    <!-- Main Menu Overlay -->
    <div id="main-menu" class="menu-overlay hidden">
        <div class="text-center p-10 bg-gray-900 bg-opacity-95 rounded-2xl shadow-2xl border-4 border-purple-700 w-11/12 md:w-1/3 transform hover:scale-[1.01] transition-transform duration-300">
            <h1 class="text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-600 mb-4 tracking-widest">
                COSMIC DASH
            </h1>
            
            <p id="high-score-display" class="text-gray-300 text-xl font-light mb-2">HIGH SCORE: 0</p>
            <p id="dust-display" class="dust-text justify-center mb-6">
                 <!-- Dust Icon (Inline SVG) -->
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-yellow-400">
                    <path fill-rule="evenodd" d="M9.032 2.217C12.784 1.487 16.592 2.508 19 5.424V3.75a.75.75 0 0 1 1.5 0v5.25a.75.75 0 0 1-.75.75h-5.25a.75.75 0 0 1 0-1.5h1.967A7.5 7.5 0 0 0 11.25 4.546v.831A.75.75 0 0 1 9.75 6v-3A.75.75 0 0 1 9.032 2.217ZM5.75 12a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5H5.75Zm5.25-3a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5h-3.5ZM9 12.75a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H9.75a.75.75 0 0 1-.75-.75Zm7.25 1.25a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5h-1.5ZM5.75 15.75a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5H5.75Zm5.25 3a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5h-3.5ZM9 19.5a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H9.75a.75.75 0 0 1-.75-.75Zm7.25-1.25a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5h-1.5Z" clip-rule="evenodd" />
                </svg>
                <span id="dust-value">0</span> DUST
            </p>
            
            <button id="start-button"
                    class="game-button px-10 py-4 text-xl">
                START DASH
            </button>
            <button id="shop-button"
                    class="game-button px-10 py-4 text-xl"
                    style="background-image: linear-gradient(to right, #00ffff 0%, #00bfff 51%, #00ffff 100%); color: #000; box-shadow: 0 0 20px #00ffff;">
                SHOP
            </button>
            <button id="controls-button"
                    class="game-button bg-gray-700 hover:bg-gray-600 px-10 py-4 text-xl"
                    style="background-image: none; background-color: #374151;">
                CONTROLS
            </button>
            <p id="loading-text" class="text-sm text-gray-500 mt-6">Initializing core systems...</p>
        </div>
    </div>
    
    <!-- Pause Modal -->
    <div id="pause-modal" class="menu-overlay hidden">
        <div class="text-center p-10 bg-gray-900 bg-opacity-95 rounded-2xl shadow-2xl border-4 border-yellow-500 w-11/12 md:w-1/3">
            <h2 class="text-6xl font-black text-yellow-400 mb-8">
                PAUSED
            </h2>
            
            <button id="resume-button"
                    class="game-button px-10 py-4 text-xl">
                RESUME DASH
            </button>
            <button id="pause-to-menu-button"
                    class="game-button px-10 py-4 text-xl"
                    style="background-image: none; background-color: #374151;">
                MAIN MENU
            </button>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div id="game-over-container" class="menu-overlay">
        <div class="text-center p-10 bg-gray-900 bg-opacity-95 rounded-2xl shadow-2xl border-4 border-red-600 w-11/12 md:w-1/3">
            <h2 class="text-6xl font-black text-red-500 mb-4">
                CRASHED!
            </h2>
            <p class="text-gray-400 text-2xl mb-2">Final Score:</p>
            <p id="final-score" class="text-yellow-400 font-extrabold mb-4 text-4xl">
                0
            </p>
             <p class="dust-text justify-center mb-6 text-2xl">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-yellow-400">
                    <path fill-rule="evenodd" d="M9.032 2.217C12.784 1.487 16.592 2.508 19 5.424V3.75a.75.75 0 0 1 1.5 0v5.25a.75.75 0 0 1-.75.75h-5.25a.75.75 0 0 1 0-1.5h1.967A7.5 7.5 0 0 0 11.25 4.546v.831A.75.75 0 0 1 9.75 6v-3A.75.75 0 0 1 9.032 2.217ZM5.75 12a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5H5.75Zm5.25-3a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5h-3.5ZM9 12.75a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H9.75a.75.75 0 0 1-.75-.75Zm7.25 1.25a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5h-1.5ZM5.75 15.75a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5H5.75Zm5.25 3a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5h-3.5ZM9 19.5a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H9.75a.75.75 0 0 1-.75-.75Zm7.25-1.25a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5h-1.5Z" clip-rule="evenodd" />
                </svg>
                <span id="collected-dust-display">0</span> DUST COLLECTED
            </p>
            <button id="restart-button"
                    class="game-button bg-red-700 hover:bg-red-600 px-8 py-3 text-lg"
                    style="background-image: linear-gradient(to right, #ef4444 0%, #f97316 51%, #ef4444 100%); box-shadow: 0 0 20px #ef4444;">
                RESTART DASH
            </button>
            <button id="game-over-to-menu-button"
                    class="game-button bg-gray-700 hover:bg-gray-600 px-8 py-3 text-lg"
                    style="background-image: none; background-color: #374151;">
                MAIN MENU
            </button>
        </div>
    </div>

    <!-- Shop Modal (Updated with Tabs) -->
    <div id="shop-modal" class="menu-overlay hidden">
        <div class="p-8 bg-gray-900 bg-opacity-95 rounded-2xl shadow-2xl border-4 border-cyan-500 w-11/12 md:w-2/3 max-h-[90vh] overflow-y-auto">
            <h2 class="text-4xl text-cyan-400 font-bold mb-4 border-b pb-2 border-cyan-700 flex justify-between items-center">
                SHIP HANGAR & UPGRADES
                <span id="shop-dust-display" class="dust-text text-2xl">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-yellow-400">
                        <path fill-rule="evenodd" d="M9.032 2.217C12.784 1.487 16.592 2.508 19 5.424V3.75a.75.75 0 0 1 1.5 0v5.25a.75.75 0 0 1-.75.75h-5.25a.75.75 0 0 1 0-1.5h1.967A7.5 7.5 0 0 0 11.25 4.546v.831A.75.75 0 0 1 9.75 6v-3A.75.75 0 0 1 9.032 2.217ZM5.75 12a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5H5.75Zm5.25-3a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5h-3.5ZM9 12.75a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H9.75a.75.75 0 0 1-.75-.75Zm7.25 1.25a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5h-1.5ZM5.75 15.75a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5H5.75Zm5.25 3a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5h-3.5ZM9 19.5a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H9.75a.75.75 0 0 1-.75-.75Zm7.25-1.25a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5h-1.5Z" clip-rule="evenodd" />
                    </svg>
                    <span id="shop-dust-value">0</span> DUST
                </span>
            </h2>
            
            <!-- Tab Navigation -->
            <div class="flex border-b border-gray-700 mb-6">
                <button id="tab-upgrades" class="px-4 py-2 text-lg font-semibold border-b-4 border-cyan-400 text-cyan-400 transition-colors duration-200">
                    PERMANENT UPGRADES
                </button>
                <button id="tab-skins" class="px-4 py-2 text-lg font-semibold border-b-4 border-transparent text-gray-500 hover:text-gray-200 transition-colors duration-200">
                    SHIP SKINS
                </button>
            </div>

            <!-- Upgrade Content -->
            <div id="upgrades-content" class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div id="upgrade-items-container" class="col-span-full grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Upgrade items will be injected here -->
                </div>
            </div>

            <!-- Skins Content (Hidden by default) -->
            <div id="skins-content" class="hidden">
                <div id="skin-items-container" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-6">
                    <!-- Skin items will be injected here -->
                </div>
            </div>


            <button id="close-shop-button"
                    class="game-button mt-8 w-full px-8 py-3 text-lg"
                    style="background-image: linear-gradient(to right, #6d28d9 0%, #a855f7 51%, #6d28d9 100%);">
                BACK TO MENU
            </button>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions-modal" class="menu-overlay hidden">
        <div class="p-8 bg-gray-800 bg-opacity-95 rounded-xl shadow-2xl border-2 border-cyan-500 w-11/12 md:w-1/2">
            <h2 class="text-4xl text-cyan-400 font-bold mb-6 border-b pb-2 border-cyan-700">GAME INSTRUCTIONS</h2>
            <ul class="text-gray-300 space-y-4 text-left text-lg">
                <li class="flex items-start">
                    <span class="text-cyan-400 mr-3 font-extrabold text-xl">»</span>
                    <div>
                        <span class="font-bold text-white">Movement:</span> Use the <span class="font-mono bg-gray-700 p-1 rounded">A</span> and <span class="font-mono bg-gray-700 p-1 rounded">D</span> keys (or Left/Right Arrows) to steer your ship.
                    </div>
                </li>
                <li class="flex items-start">
                    <span class="text-yellow-400 mr-3 font-extrabold text-xl">»</span>
                    <div>
                        <span class="font-bold text-white">Cosmic Dust (Yellow/Gold):</span> Collect these to earn currency for permanent upgrades in the Shop! (Upgrade available!)
                    </div>
                </li>
                 <li class="flex items-start">
                    <span class="text-purple-400 mr-3 font-extrabold text-xl">»</span>
                    <div>
                        <span class="font-bold text-white">Score Multiplier (Purple Cube):</span> Gives a temporary **2x score bonus**.
                    </div>
                </li>
                <li class="flex items-start">
                    <span class="text-cyan-400 mr-3 font-extrabold text-xl">»</span>
                    <div>
                        <span class="font-bold text-white">Shield Power-ups (Cyan Wireframe):</span> Activates temporary invulnerability. (Upgrade available!)
                    </div>
                </li>
                <li class="flex items-start">
                    <span class="text-red-500 mr-3 font-extrabold text-xl">»</span>
                    <div>
                        <span class="font-bold text-white">Dangers:</span> Avoid gray Asteroids and fast, red Mines!
                    </div>
                </li>
            </ul>
            <button id="close-instructions-button"
                    class="game-button mt-8 w-full px-8 py-3 text-lg"
                    style="background-image: linear-gradient(to right, #00ffff 0%, #00bfff 51%, #00ffff 100%); box-shadow: 0 0 20px #00ffff;">
                BACK TO MENU
            </button>
        </div>
    </div>

    <!-- The 3D Canvas will be injected here -->
    <script type="module">
        // Import necessary functions from global scope after Firebase initialization
        const saveGameData = window.saveGameData;
        
        // --- Game State Management ---
        const GameState = {
            CUTSCENE: 'CUTSCENE',
            MENU: 'MENU',
            LOADING: 'LOADING',
            PLAYING: 'PLAYING',
            GAMEOVER: 'GAMEOVER',
            PAUSED: 'PAUSED' 
        };
        let gameState = GameState.LOADING;

        // --- Three.js Variables ---
        let scene, camera, renderer;
        let starField = [];
        let playerShip;
        let exhaustMesh;
        let animationFrameId;
        
        // --- Game Variables ---
        let score = 0;
        let collectedDust = 0; 
        let scoreMultiplier = 1; 
        let dustCollectionMultiplier = 1; 

        let obstacleTimeout = 0;
        const BASE_OBSTACLE_INTERVAL = 80;
        const BASE_OBSTACLE_SPEED = 0.5;
        let currentObstacleInterval = BASE_OBSTACLE_INTERVAL;
        let currentObstacleSpeed = BASE_OBSTACLE_SPEED;
        let obstacles = [];
        const PLAYER_MOVE_SPEED = 0.15;
        const PLAYER_MAX_X = 5; 

        // --- Lane Visuals ---
        let laneLines = [];
        
        // --- Health & Damage Variables ---
        let maxHealth = 3; 
        let playerHealth = maxHealth;
        let isInvulnerable = false;
        let invulnerabilityTimer = 0;
        const INVULNERABILITY_DURATION = 90; // 1.5 seconds

        // --- Power-up/Shield Variables ---
        let powerUps = []; 
        let shieldActive = false;
        let shieldTimer = 0;
        const SHIELD_DURATION = 300; 
        
        let multiplierTimer = 0; 
        const MULTIPLIER_DURATION = 420; 
        
        let dustTimeout = 0;
        const DUST_INTERVAL = 300; 

        let powerUpTimeout = 0;
        const POWERUP_INTERVAL = 400; 

        // --- Cutscene Variables ---
        let cutsceneTimer = 0;
        const CUTSCENE_DURATION = 400; 
        const cutsceneTextElements = [
            { el: document.getElementById('cutscene-text-1'), start: 0, end: 150 },
            { el: document.getElementById('cutscene-text-2'), start: 150, end: 300 },
            { el: document.getElementById('cutscene-text-3'), start: 300, end: CUTSCENE_DURATION }
        ];

        // --- Input Handling ---
        const keys = { left: false, right: false };

        // --- UI Element References ---
        const menuElement = document.getElementById('main-menu');
        const startButton = document.getElementById('start-button');
        const controlsButton = document.getElementById('controls-button');
        const shopButton = document.getElementById('shop-button');
        const shopModal = document.getElementById('shop-modal');
        const closeShopButton = document.getElementById('close-shop-button');
        const instructionsModal = document.getElementById('instructions-modal');
        const closeInstructionsButton = document.getElementById('close-instructions-button');
        const loadingText = document.getElementById('loading-text');
        const gameOverContainer = document.getElementById('game-over-container');
        const restartButton = document.getElementById('restart-button');
        const gameOverToMenuButton = document.getElementById('game-over-to-menu-button'); 
        const scoreDisplay = document.getElementById('score-display');
        const finalScoreDisplay = document.getElementById('final-score');
        const collectedDustDisplay = document.getElementById('collected-dust-display');
        const shieldStatusDisplay = document.getElementById('shield-status');
        const multiplierStatusDisplay = document.getElementById('multiplier-status');
        const flashOverlay = document.getElementById('flash-overlay');
        const healthDisplay = document.getElementById('health-display');
        const cutsceneHint = document.getElementById('cutscene-hint');
        const pauseButton = document.getElementById('pause-button'); 
        const pauseModal = document.getElementById('pause-modal'); 
        const resumeButton = document.getElementById('resume-button'); 
        const pauseToMenuButton = document.getElementById('pause-to-menu-button'); 
        
        // Shop Tab Elements (NEW)
        const tabUpgrades = document.getElementById('tab-upgrades');
        const tabSkins = document.getElementById('tab-skins');
        const upgradesContent = document.getElementById('upgrades-content');
        const skinsContent = document.getElementById('skins-content');

        // --- UI Update Functions ---
        
        function updateHealthDisplay() {
            let html = '';
            for (let i = 0; i < maxHealth; i++) {
                if (i < playerHealth) {
                    const flashingStyle = isInvulnerable && (Math.floor(invulnerabilityTimer / 10) % 2 === 0) 
                        ? 'background-color: #ff0000; box-shadow: 0 0 5px #ff0000;' 
                        : '';
                    html += `<div class="health-icon" style="${flashingStyle}"></div>`;
                } else {
                    html += `<div class="health-icon opacity-25" style="background-color: #4a4a4a; box-shadow: none;"></div>`;
                }
            }
            healthDisplay.innerHTML = html;
        }
        
        // Function to sync internal game variables and ship appearance from Firestore data
        window.syncGameStats = function() {
            if (window.playerData) {
                // 1. Upgrade Sync
                const newMaxHealth = window.playerData.maxHealthLevel + 2;
                if (newMaxHealth !== maxHealth) {
                    maxHealth = newMaxHealth;
                    playerHealth = Math.min(playerHealth, maxHealth); 
                }
                dustCollectionMultiplier = 1.0 + (window.playerData.dustMultiplierLevel - 1) * 0.25;

                updateHealthDisplay();
                
                // 2. Skin Sync (NEW)
                if (playerShip && playerShip.material) {
                    const skinData = window.getSkinData(window.playerData.equippedSkinId);
                    if (skinData) {
                        const shipColor = new THREE.Color(skinData.color);
                        
                        // Update player ship color
                        playerShip.material.color = shipColor;
                        playerShip.material.emissive.set(shipColor.getHex()); 
                        playerShip.material.emissiveIntensity = 0.5;

                        // Update base exhaust color (pre-game effects)
                        const exhaustColor = new THREE.Color(skinData.exhaustColor);
                        exhaustMesh.material.color = exhaustColor;
                    }
                }
            }
        }
        
        // Shop Tab Switching Logic
        function switchShopTab(tabId) {
            const isUpgrades = tabId === 'upgrades';
            
            tabUpgrades.classList.toggle('border-cyan-400', isUpgrades);
            tabUpgrades.classList.toggle('text-cyan-400', isUpgrades);
            tabUpgrades.classList.toggle('border-transparent', !isUpgrades);
            tabUpgrades.classList.toggle('text-gray-500', !isUpgrades);
            tabUpgrades.classList.toggle('hover:text-gray-200', !isUpgrades);

            tabSkins.classList.toggle('border-cyan-400', !isUpgrades);
            tabSkins.classList.toggle('text-cyan-400', !isUpgrades);
            tabSkins.classList.toggle('border-transparent', isUpgrades);
            tabSkins.classList.toggle('text-gray-500', isUpgrades);
            tabSkins.classList.toggle('hover:text-gray-200', isUpgrades);

            upgradesContent.classList.toggle('hidden', !isUpgrades);
            skinsContent.classList.toggle('hidden', isUpgrades);

            // Re-render the active tab to update button states
            if (isUpgrades) {
                window.updateUpgradesShopUI();
            } else {
                window.updateSkinsShopUI();
            }
        }

        // --- Three.js Initialization (Rest of the file) ---
        
        function createLaneDividers() {
            const lineGeometry = new THREE.CylinderGeometry(0.05, 0.05, 200, 8);
            lineGeometry.rotateX(Math.PI / 2);
            
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0x4a4a4a, transparent: true, opacity: 0.7 });

            // Left line
            const line1 = new THREE.Mesh(lineGeometry, lineMaterial);
            line1.position.set(-PLAYER_MAX_X - 0.5, 0, -100);
            scene.add(line1);
            laneLines.push(line1);
            
            // Right line
            const line2 = new THREE.Mesh(lineGeometry, lineMaterial);
            line2.position.set(PLAYER_MAX_X + 0.5, 0, -100);
            scene.add(line2);
            laneLines.push(line2);
        }

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            
            // 2. Camera Setup (Cutscene Start Position)
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 10, -50); 
            
            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            renderer.setClearColor(0x000000, 1);

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(1, 2, 1).normalize();
            scene.add(directionalLight);

            // 5. Create Player Ship
            const shipGeometry = new THREE.CylinderGeometry(0.5, 0.2, 2, 8);
            shipGeometry.rotateX(Math.PI / 2);
            
            // Placeholder material - will be overwritten by syncGameStats
            const shipMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b5cf6, 
                metalness: 0.8, 
                roughness: 0.1,
                emissive: 0x4c2b90,
                emissiveIntensity: 0.5
            });
            playerShip = new THREE.Mesh(shipGeometry, shipMaterial);
            playerShip.position.set(0, 0, 0);
            scene.add(playerShip);

            // 5b. Create Ship Exhaust
            const exhaustColor = 0xffa500;
            const exhaustGeometry = new THREE.CylinderGeometry(0.3, 0.5, 3, 16);
            exhaustGeometry.translate(0, 0, -2.5);
            const exhaustMaterial = new THREE.MeshBasicMaterial({ 
                color: exhaustColor, 
                transparent: true, 
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            exhaustMesh = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            playerShip.add(exhaustMesh);
            exhaustMesh.scale.set(1, 1, 0.1);

            // 6. Create Star Field
            createStarField();
            
            // 7. Create Lane Visuals
            createLaneDividers();

            // 8. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('keyup', onKeyUp, false);
            
            startButton.addEventListener('click', () => startGame(true));
            restartButton.addEventListener('click', () => startGame(true));
            gameOverToMenuButton.addEventListener('click', showMainMenu); 

            controlsButton.addEventListener('click', () => {
                instructionsModal.classList.remove('hidden');
                menuElement.classList.add('hidden');
            });
            closeInstructionsButton.addEventListener('click', () => {
                instructionsModal.classList.add('hidden');
                menuElement.classList.remove('hidden');
            });
            
            shopButton.addEventListener('click', () => { 
                shopModal.classList.remove('hidden');
                menuElement.classList.add('hidden');
                switchShopTab('upgrades'); // Default to Upgrades tab
            });
            closeShopButton.addEventListener('click', () => {
                shopModal.classList.add('hidden');
                menuElement.classList.remove('hidden');
            });
            
            // NEW: Shop Tab Listeners
            tabUpgrades.addEventListener('click', () => switchShopTab('upgrades'));
            tabSkins.addEventListener('click', () => switchShopTab('skins'));


            pauseButton.addEventListener('click', pauseGame); 
            resumeButton.addEventListener('click', resumeGame); 
            pauseToMenuButton.addEventListener('click', showMainMenu); 


            // Initial UI Setup for Cutscene
            cutsceneHint.style.opacity = 1;
            gameState = GameState.CUTSCENE;
            loadingText.classList.add('hidden'); 
            startButton.disabled = true; 

            updateHealthDisplay(); // Initial draw
            
            animate();
        }

        // Handles window resize for responsiveness
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Creates a simple background of stars
        function createStarField() {
            const starGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            for (let i = 0; i < 2000; i++) {
                const star = new THREE.Mesh(starGeometry, starMaterial);
                star.position.set(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    -Math.random() * 200
                );
                scene.add(star);
                starField.push(star);
            }
        }
        
        // --- Input Handlers ---
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            if (key === 'a' || event.keyCode === 37) keys.left = true;
            if (key === 'd' || event.keyCode === 39) keys.right = true;
            
            // Pause/Resume on Escape key
            if (key === 'escape') {
                if (gameState === GameState.PLAYING) {
                    pauseGame();
                } else if (gameState === GameState.PAUSED) {
                    resumeGame();
                }
            }

            if (gameState === GameState.CUTSCENE) {
                endCutscene();
            }
        }

        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            if (key === 'a' || event.keyCode === 37) keys.left = false;
            if (key === 'd' || event.keyCode === 39) keys.right = false;
        }
        
        // --- Obstacle Logic ---
        
        const ObstacleType = { ASTEROID: 'asteroid', MINE: 'mine' }; 

        function createObstacle() {
            let type = ObstacleType.ASTEROID;
            if (Math.random() < 0.1 + (score / 500)) { 
                type = ObstacleType.MINE;
            }

            let geometry, material, size, speedFactor = 1;

            if (type === ObstacleType.ASTEROID) {
                size = Math.random() * 1 + 0.5;
                geometry = Math.random() < 0.5 ? new THREE.IcosahedronGeometry(size, 0) : new THREE.DodecahedronGeometry(size, 0);
                const asteroidColor = new THREE.Color(0x4a4a4a).lerp(new THREE.Color(0x606060), Math.random());
                material = new THREE.MeshStandardMaterial({ 
                    color: asteroidColor, 
                    flatShading: true,
                    metalness: 0.5, 
                    roughness: 0.8
                });
            } else { // Mine
                size = 0.5;
                geometry = new THREE.SphereGeometry(size, 10, 10);
                material = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    wireframe: true, 
                    blending: THREE.AdditiveBlending 
                });
                speedFactor = 1.5; 
            }

            const obstacle = new THREE.Mesh(geometry, material);
            
            obstacle.position.set(
                (Math.random() - 0.5) * PLAYER_MAX_X * 2,
                (Math.random() - 0.5) * 1,
                -50
            );
            
            obstacle.radius = size * 0.8; 
            obstacle.type = type;
            obstacle.speedFactor = speedFactor;
            
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        
        function updateObstacles() {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                
                const effectiveSpeed = currentObstacleSpeed * obstacle.speedFactor;
                obstacle.position.z += effectiveSpeed; 
                
                obstacle.rotation.x += 0.01;
                obstacle.rotation.y += 0.015;

                if (obstacle.type === ObstacleType.MINE) {
                    const pulse = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                    obstacle.scale.setScalar(1 + pulse * 0.2);
                    obstacle.material.opacity = 0.5 + pulse * 0.5;
                }

                if (obstacle.position.z > camera.position.z + 1) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }

            obstacleTimeout++;
            if (obstacleTimeout >= currentObstacleInterval) {
                createObstacle();
                obstacleTimeout = 0;
            }
        }
        
        // --- Power-up Logic ---
        
        const PowerUpType = { SHIELD: 'shield', MULTIPLIER: 'multiplier', DUST: 'dust' }; 

        function createPowerUp(type) {
            let geometry, material, color, size;

            if (type === PowerUpType.SHIELD) {
                color = 0x00ffff;
                size = 0.8;
                geometry = new THREE.TetrahedronGeometry(size, 0);
                material = new THREE.MeshBasicMaterial({ 
                    color: color, wireframe: true, blending: THREE.AdditiveBlending, opacity: 0.9 
                });
            } else if (type === PowerUpType.MULTIPLIER) {
                color = 0xa855f7;
                size = 1;
                geometry = new THREE.BoxGeometry(size, size, size);
                material = new THREE.MeshBasicMaterial({ 
                    color: color, wireframe: true, blending: THREE.AdditiveBlending, opacity: 0.9 
                });
            } else { // DUST
                color = 0xfcd34d; // Yellow/Gold
                size = 0.5;
                geometry = new THREE.OctahedronGeometry(size, 0);
                material = new THREE.MeshBasicMaterial({
                    color: color, flatShading: true, emissive: color, emissiveIntensity: 0.5 
                });
            }
            
            const powerUp = new THREE.Mesh(geometry, material);
            
            powerUp.position.set(
                (Math.random() - 0.5) * PLAYER_MAX_X * 2, 
                (Math.random() - 0.5) * 1,                
                -50                                       
            );
            powerUp.radius = size * 0.8;
            powerUp.type = type; 
            
            scene.add(powerUp);
            powerUps.push(powerUp);
        }

        function activateShield(duration = SHIELD_DURATION) {
            shieldActive = true;
            shieldTimer = duration;
            shieldStatusDisplay.textContent = `SHIELD: ${Math.ceil(shieldTimer / 60)}s`;
            shieldStatusDisplay.style.opacity = 1;
            shieldStatusDisplay.classList.remove('text-red-500'); 
            shieldStatusDisplay.classList.add('text-cyan-400');
        }
        
        function activateMultiplier() {
            scoreMultiplier = 2;
            multiplierTimer = MULTIPLIER_DURATION;
            multiplierStatusDisplay.textContent = `SCORE x2: ${Math.ceil(multiplierTimer / 60)}s`;
            multiplierStatusDisplay.style.opacity = 1;
        }


        function checkPowerUpCollision() {
            const playerPos = playerShip.position;
            const playerRadius = 0.5;

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                const distance = playerPos.distanceTo(powerUp.position);
                
                if (distance < playerRadius + powerUp.radius) {
                    
                    if (powerUp.type === PowerUpType.SHIELD) {
                        activateShield();
                    } else if (powerUp.type === PowerUpType.MULTIPLIER) {
                        activateMultiplier();
                    } else if (powerUp.type === PowerUpType.DUST) { 
                        // Apply dust multiplier from shop upgrade
                        collectedDust += Math.floor(1 * dustCollectionMultiplier);
                    }

                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                    return;
                }
                
                if (powerUp.position.z > camera.position.z + 1) {
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                }
            }
        }

        // --- Collision Detection ---
        function checkCollisions() {
            const playerPos = playerShip.position;
            const playerRadius = 0.5;

            if (isInvulnerable) return;

            for (const obstacle of obstacles) {
                const obsPos = obstacle.position;
                const distance = playerPos.distanceTo(obsPos);
                
                if (distance < playerRadius + obstacle.radius) {
                    
                    if (shieldActive) {
                        scene.remove(obstacle);
                        obstacles.splice(obstacles.indexOf(obstacle), 1);
                        
                        // Flash shield status
                        shieldStatusDisplay.classList.remove('text-cyan-400');
                        shieldStatusDisplay.classList.add('text-yellow-300');
                        setTimeout(() => {
                             if (shieldActive) {
                                shieldStatusDisplay.classList.remove('text-yellow-300');
                                shieldStatusDisplay.classList.add('text-cyan-400');
                             }
                        }, 100);
                        return false;
                    } else {
                        playerHealth--;
                        updateHealthDisplay();
                        
                        isInvulnerable = true;
                        invulnerabilityTimer = INVULNERABILITY_DURATION;
                        
                        if (playerHealth <= 0) {
                            gameOver();
                            return true;
                        } else {
                            flashOverlay.style.opacity = 1;
                            setTimeout(() => { flashOverlay.style.opacity = 0; }, 50);
                            
                            scene.remove(obstacle);
                            obstacles.splice(obstacles.indexOf(obstacle), 1);
                            return false;
                        }
                    }
                }
            }
            return false;
        }

        // --- Game Flow Functions ---

        function endCutscene() {
            if (gameState === GameState.CUTSCENE) {
                showMainMenu();
            }
        }
        
        function showMainMenu() {
            gameState = GameState.MENU;
            
            // Cleanup any lingering game states
            isInvulnerable = false;
            shieldActive = false;
            scoreMultiplier = 1;
            
            // Hide all overlays and UI elements related to gameplay
            gameOverContainer.style.display = 'none';
            instructionsModal.classList.add('hidden');
            shopModal.classList.add('hidden');
            pauseModal.classList.add('hidden');
            pauseButton.style.opacity = 0; 
            
            // Show Main Menu
            menuElement.classList.remove('hidden'); 
            startButton.disabled = false; 
            window.updateMenuStatsUI(); 
            
            console.log("Game State: MENU");
        }

        function pauseGame() {
            if (gameState !== GameState.PLAYING) return;
            gameState = GameState.PAUSED;
            pauseModal.classList.remove('hidden');
            pauseButton.style.opacity = 0; 
            console.log("Game State: PAUSED");
        }

        function resumeGame() {
            if (gameState !== GameState.PAUSED) return;
            gameState = GameState.PLAYING;
            pauseModal.classList.add('hidden');
            pauseButton.style.opacity = 1; 
            console.log("Game State: PLAYING");
        }


        function startGame(reset) {
            if (!window.playerData) {
                console.warn("Firebase data not yet loaded. Using default stats.");
                maxHealth = 3;
                dustCollectionMultiplier = 1;
            }

            if (reset) {
                obstacles.forEach(obs => scene.remove(obs));
                obstacles = [];
                powerUps.forEach(pu => scene.remove(pu));
                powerUps = [];
                
                score = 0;
                collectedDust = 0; 
                playerShip.position.x = 0;
                scoreDisplay.textContent = `SCORE: 0`;
                
                window.syncGameStats(); 

                playerHealth = maxHealth;
                
                isInvulnerable = false;
                invulnerabilityTimer = 0;
                
                currentObstacleInterval = BASE_OBSTACLE_INTERVAL;
                currentObstacleSpeed = BASE_OBSTACLE_SPEED;
                
                const initialShieldSeconds = (window.playerData?.initialShieldLevel || 1) - 1; 
                if (initialShieldSeconds > 0) {
                    activateShield(initialShieldSeconds * 60); 
                } else {
                    shieldStatusDisplay.style.opacity = 0;
                }
                
                scoreMultiplier = 1; 
                multiplierTimer = 0;
                multiplierStatusDisplay.style.opacity = 0;
                
                updateHealthDisplay();
            }
            
            // Hide all menus/overlays
            menuElement.classList.add('hidden'); 
            gameOverContainer.style.display = 'none';
            instructionsModal.classList.add('hidden');
            shopModal.classList.add('hidden');
            pauseModal.classList.add('hidden'); 

            // Show Pause Button
            pauseButton.style.opacity = 1; 

            gameState = GameState.PLAYING;
            console.log("Game State: PLAYING");
        }
        
        function gameOver() {
            gameState = GameState.GAMEOVER;
            
            const finalScoreValue = Math.floor(score);
            finalScoreDisplay.textContent = `${finalScoreValue} points`;
            collectedDustDisplay.textContent = collectedDust;
            
            gameOverContainer.style.display = 'flex';
            
            // Hide Pause Button
            pauseButton.style.opacity = 0;
            
            // Save data to Firestore
            saveGameData(finalScoreValue, collectedDust);
            
            // Dramatic red flash effect
            flashOverlay.style.opacity = 1;
            setTimeout(() => {
                flashOverlay.style.opacity = 0;
            }, 100);

            // Deactivate UI elements
            shieldStatusDisplay.style.opacity = 0;
            shieldActive = false;
            shieldTimer = 0;
            
            multiplierStatusDisplay.style.opacity = 0;
            scoreMultiplier = 1;
            multiplierTimer = 0;
            
            console.log("Game State: GAMEOVER");
        }
        
        // --- Main Game Logic ---
        function updateGame() {
            // 1. Player Movement
            if (keys.left) {
                playerShip.position.x -= PLAYER_MOVE_SPEED;
            }
            if (keys.right) {
                playerShip.position.x += PLAYER_MOVE_SPEED;
            }
            
            playerShip.position.x = Math.max(-PLAYER_MAX_X, Math.min(PLAYER_MAX_X, playerShip.position.x));
            playerShip.rotation.z = -((playerShip.position.x / PLAYER_MAX_X) * Math.PI / 8); 

            // 2. Invulnerability Timer
            if (isInvulnerable) {
                invulnerabilityTimer--;
                updateHealthDisplay();
                if (invulnerabilityTimer <= 0) {
                    isInvulnerable = false;
                    playerShip.visible = true;
                    updateHealthDisplay();
                }
            }
            
            if (isInvulnerable && (Math.floor(invulnerabilityTimer / 5) % 2 === 0)) {
                playerShip.visible = false;
            } else {
                playerShip.visible = true;
            }


            // 3. Obstacles & Power-ups
            updateObstacles();
            
            // Power-up spawning (Shield or Multiplier)
            powerUpTimeout++;
            if (powerUpTimeout >= POWERUP_INTERVAL) {
                const typeToSpawn = Math.random() < 0.7 ? PowerUpType.SHIELD : PowerUpType.MULTIPLIER;
                createPowerUp(typeToSpawn);
                powerUpTimeout = 0;
            }
            
            // Dust spawning
            dustTimeout++;
            if (dustTimeout >= DUST_INTERVAL) {
                 createPowerUp(PowerUpType.DUST);
                 dustTimeout = 0;
            }
            
            checkPowerUpCollision();

            // 4. Collision Check
            checkCollisions();

            // 5. Shield Update 
            if (shieldActive) {
                shieldTimer--;
                
                const remainingTime = Math.ceil(shieldTimer / 60);
                shieldStatusDisplay.textContent = `SHIELD: ${remainingTime}s`;
                
                if (shieldTimer < 180 && (Math.floor(shieldTimer / 30) % 2 === 0)) {
                    shieldStatusDisplay.classList.remove('text-cyan-400');
                    shieldStatusDisplay.classList.add('text-red-500');
                } else if (shieldTimer >= 0) {
                    shieldStatusDisplay.classList.remove('text-red-500');
                    shieldStatusDisplay.classList.add('text-cyan-400');
                }

                if (shieldTimer <= 0) {
                    shieldActive = false;
                    shieldStatusDisplay.style.opacity = 0;
                    shieldStatusDisplay.classList.remove('text-cyan-400', 'text-red-500');
                }
            }
            
            // 6. Multiplier Update 
            if (scoreMultiplier > 1) {
                multiplierTimer--;
                const remainingTime = Math.ceil(multiplierTimer / 60);
                multiplierStatusDisplay.textContent = `SCORE x${scoreMultiplier}: ${remainingTime}s`;

                if (multiplierTimer <= 0) {
                    scoreMultiplier = 1;
                    multiplierStatusDisplay.style.opacity = 0;
                }
            }


            // 7. Scoring & Difficulty 
            score += 0.1 * scoreMultiplier;
            scoreDisplay.textContent = `SCORE: ${Math.floor(score)}`;
            
            const difficultyFactor = Math.floor(score / 50);
            currentObstacleSpeed = BASE_OBSTACLE_SPEED * (1 + difficultyFactor * 0.15);
            currentObstacleInterval = Math.max(10, BASE_OBSTACLE_INTERVAL - (difficultyFactor * 6));

            // 8. Exhaust Animation 
            const pulse = 0.5 + (Math.sin(Date.now() * 0.01) * 0.5 + 0.5) * 0.5; 
            const scaleZ = 0.5 + (pulse * 1.5) * (currentObstacleSpeed / BASE_OBSTACLE_SPEED);
            
            exhaustMesh.scale.set(1, 1, scaleZ);
            exhaustMesh.material.opacity = 0.5 + pulse * 0.5;
            
            // Retrieve the equipped skin's base colors
            const skinData = window.getSkinData(window.playerData.equippedSkinId) || window.getSkinData('default');
            const baseExhaustColor = new THREE.Color(skinData.exhaustColor);

            if (shieldActive) {
                 exhaustMesh.material.color.setRGB(0.0, 0.7, 1.0); // Override for shield
                 playerShip.material.emissive.setHex(0x00ffff);
            } else if (scoreMultiplier > 1) {
                 exhaustMesh.material.color.setRGB(0.7, 0.0, 1.0); // Override for multiplier
                 playerShip.material.emissive.setHex(0xa855f7);
            } else {
                 // Use base skin color and mix with fire pulse
                 const r = baseExhaustColor.r + (1 - baseExhaustColor.r) * pulse * 0.2;
                 const g = baseExhaustColor.g + (1 - baseExhaustColor.g) * pulse * 0.2;
                 const b = baseExhaustColor.b + (1 - baseExhaustColor.b) * pulse * 0.2;
                 exhaustMesh.material.color.setRGB(r, g, b);

                 // Return ship emissive to its base color
                 const shipColor = new THREE.Color(skinData.color);
                 playerShip.material.emissive.set(shipColor.getHex());
            }
        }
        
        // --- Enhanced Cutscene Update ---
        function updateCutscene() {
            cutsceneTimer++;
            const t = cutsceneTimer / CUTSCENE_DURATION;
            
            // Camera movement
            camera.position.x = 0;
            camera.position.y = THREE.MathUtils.lerp(10, 1, t);
            camera.position.z = THREE.MathUtils.lerp(-50, 5, t);
            
            camera.rotation.x = THREE.MathUtils.lerp(-Math.PI / 4, 0, t);
            playerShip.rotation.y += 0.01;
            
            // Text Animations
            cutsceneTextElements.forEach(item => {
                if (cutsceneTimer >= item.start && cutsceneTimer < item.end) {
                    // Fade in/keep visible
                    item.el.style.opacity = 1;
                    item.el.style.transform = 'translate(-50%, -50%) scale(1)';
                } else {
                    // Fade out
                    item.el.style.opacity = 0;
                    item.el.style.transform = 'translate(-50%, -50%) scale(0.9)';
                }
            });


            if (cutsceneTimer >= CUTSCENE_DURATION) {
                endCutscene();
            }
        }


        // The main game loop
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            if (gameState === GameState.PLAYING) { 
                updateGame();
                
                // Update power-up positions (part of game logic)
                powerUps.forEach(pu => {
                    pu.position.z += currentObstacleSpeed;
                    if (pu.type !== PowerUpType.DUST) {
                        pu.rotation.x += 0.03;
                        pu.rotation.y += 0.05;
                    } else { 
                        pu.rotation.y += 0.03;
                    }
                });
                
            } else if (gameState === GameState.CUTSCENE) {
                updateCutscene();
                
            } else if (gameState === GameState.MENU || gameState === GameState.GAMEOVER || gameState === GameState.LOADING || gameState === GameState.PAUSED) {
                // Subtle ship animation for menus, no movement/game update
                playerShip.rotation.y += 0.005;
            }
            
            // Move stars and lane lines (applies to all states)
            const speedMultiplier = gameState === GameState.PLAYING ? (currentObstacleSpeed / BASE_OBSTACLE_SPEED) : 0.5;
            
            starField.forEach(star => {
                star.position.z += 1.5 * speedMultiplier;
                if (star.position.z > camera.position.z) {
                    star.position.z = -100;
                }
            });
            
            laneLines.forEach(line => {
                line.position.z += 1.5 * speedMultiplier;
                if (line.position.z > camera.position.z + 5) {
                    line.position.z = -100;
                }
            });


            renderer.render(scene, camera);
        }

        // Start initialization when the window loads
        window.onload = function() {
            loadingText.classList.remove('hidden');
            init();
            
            // Ensure stats are synced if Firebase listener hasn't fired yet
            window.syncGameStats();
        };

    </script>
</body>
</html>
