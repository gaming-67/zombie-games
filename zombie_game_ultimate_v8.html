<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Night of the Rot — Mega Edition</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{--hud-bg:rgba(6,6,8,0.6);--accent:#d93f3f;--muted:#c7c9cf}
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui,Segoe UI,Helvetica,Arial}
  canvas{display:block;width:100%;height:100vh}
  #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:40;background:linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.95))}
  .menu{background:rgba(0,0,0,0.64); padding:22px;border-radius:12px; width:min(820px,96%); color:#fff}
  h1{margin:0;font-size:28px}
  .btn{background:var(--accent); color:#fff; border:none; padding:10px 12px; border-radius:8px; cursor:pointer; font-weight:700}
  .btn.s{background:#2b2b2b;margin-left:10px}
  #hud{position:fixed;left:12px;top:12px;z-index:45;color:#fff;background:var(--hud-bg);padding:10px;border-radius:10px;min-width:260px}
  #weaponUI{position:fixed;right:12px;bottom:12px;z-index:45;color:#fff;background:var(--hud-bg);padding:10px;border-radius:10px;min-width:220px}
  #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:44;pointer-events:none;font-size:20px;color:rgba(255,255,255,0.9)}
  #gameOver{display:none;position:fixed;inset:0;z-index:46;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;color:#fff}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}
  .pickup{position:fixed;left:50%;transform:translateX(-50%);bottom:120px;z-index:47;color:#fff;pointer-events:none;font-weight:800;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,0.6)}
  #fps{position:fixed;right:8px;top:8px;color:#bbb;z-index:50;font-size:12px}
</style>
</head>
<body>
  <div id="overlay">
    <div class="menu">
      <h1>Night of the Rot — Mega Edition</h1>
      <div class="hint">First-person • 4 weapons (1-4) • flamethrower • bosses • dogs • exploding zombies • flashlight (F) • pickups • waves • highscore</div>
      <div style="margin-top:12px;">
        <button id="startBtn" class="btn">Start Game</button>
        <button id="controlsBtn" class="btn s">Controls</button>
        <button id="muteBtn" class="btn s" style="float:right">Mute</button>
      </div>
      <div style="margin-top:12px;color:#ddd">Controls: WASD move • Click canvas to lock pointer/look • Left-click shoot • Right-click aim (ADS) • R reload • 1-4 switch weapons • F flashlight/melee toggle • E pick up • Shift sprint</div>
    </div>
  </div>

  <div id="hud" aria-live="polite">
    <div style="display:flex;justify-content:space-between"><div>Health</div><div id="healthVal">100</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Score</div><div id="scoreVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Wave</div><div id="waveVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Highscore</div><div id="highVal">0</div></div>
  </div>

  <div id="weaponUI">
    <div id="weaponName">Pistol</div>
    <div class="hint" style="margin-top:6px">Ammo: <span id="ammoVal">12</span> / <span id="reserveVal">36</span></div>
    <div class="hint" id="reloadText" style="display:none;margin-top:6px">Reloading...</div>
  </div>

  <div id="crosshair">+</div>
  <div id="pickupText" class="pickup" style="display:none"></div>
  <div id="gameOver">
    <div style="background:rgba(0,0,0,0.6);padding:20px;border-radius:10px;text-align:center;color:#fff">
      <h1 id="goTitle">You Died</h1>
      <div class="hint" id="goScore">Score: 0</div>
      <div style="margin-top:12px"><button id="retryBtn" class="btn">Retry</button></div>
    </div>
  </div>

  <div id="fps"></div>
  <canvas id="gameCanvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/* Mega Edition — single-file. Features added above.
   This is intentionally compact but functional: procedural sounds, particle pooling, many enemy types.
*/

/* ----------------- UI elements ----------------- */
const canvas = document.getElementById('gameCanvas');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const controlsBtn = document.getElementById('controlsBtn');
const muteBtn = document.getElementById('muteBtn');
const healthEl = document.getElementById('healthVal');
const scoreEl = document.getElementById('scoreVal');
const waveEl = document.getElementById('waveVal');
const highEl = document.getElementById('highVal');
const weaponNameEl = document.getElementById('weaponName');
const ammoEl = document.getElementById('ammoVal');
const reserveEl = document.getElementById('reserveVal');
const reloadText = document.getElementById('reloadText');
const pickupText = document.getElementById('pickupText');
const goDiv = document.getElementById('gameOver');
const goScore = document.getElementById('goScore');
const retryBtn = document.getElementById('retryBtn');
const fpsEl = document.getElementById('fps');

/* -------------- global state -------------- */
let scene, camera, renderer, clock;
let running=false, muted=false;
let health=100, score=0, wave=0;
let zombies=[], pickups=[], props=[];
const worldSize = 120;
let lastSpawn=0, spawnInterval=1400, lastWaveTime=0;
let lastFrame=performance.now();
let audioCtx=null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function sfx(freq=440,dur=0.06,type='sine',vol=0.12){ if(muted) return; ensureAudio(); const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(audioCtx.destination); g.gain.value=0.0001; g.gain.exponentialRampToValueAtTime(vol, audioCtx.currentTime+0.01); o.start(); o.stop(audioCtx.currentTime+dur); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur); }

/* -------------- weapons -------------- */
const weapons = {
  pistol:{name:'Pistol',mag:12,reserve:96,fireRate:240,damage:3,automatic:false,reloadTime:900,adsSpread:0.01,hipSpread:0.06},
  shotgun:{name:'Shotgun',mag:6,reserve:48,fireRate:680,damage:6,pellets:7,spread:0.18,automatic:false,reloadTime:1200,adsSpread:0.06,hipSpread:0.2},
  rifle:{name:'Rifle',mag:30,reserve:150,fireRate:85,damage:1,automatic:true,reloadTime:1400,adsSpread:0.006,hipSpread:0.045},
  flamethrower:{name:'Flamethrower',mag:100,reserve:400,fireRate:30,damage:0.15,automatic:true,reloadTime:1800,range:6}
};
let currentWeapon='pistol';
let weaponState={
  pistol:{ammo:weapons.pistol.mag,reserve:weapons.pistol.reserve,reloading:false,lastShot:0},
  shotgun:{ammo:weapons.shotgun.mag,reserve:weapons.shotgun.reserve,reloading:false,lastShot:0},
  rifle:{ammo:weapons.rifle.mag,reserve:weapons.rifle.reserve,reloading:false,lastShot:0},
  flamethrower:{ammo:weapons.flamethrower.mag,reserve:weapons.flamethrower.reserve,reloading:false,lastShot:0}
};
let aiming=false, mouseHeld=false, meleeCooldown=0;

/* -------------- initialize three -------------- */
function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.013);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0,1.6,0);
  renderer = new THREE.WebGLRenderer({canvas:canvas,antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio?devicePixelRatio:1);
  const hemi = new THREE.HemisphereLight(0x8888aa, 0x222222, 0.9); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff0c8, 0.6); dir.position.set(8,12,6); scene.add(dir);
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(worldSize*2, worldSize*2, 12,12), new THREE.MeshStandardMaterial({color:0x0f0f10}));
  ground.rotation.x = -Math.PI/2; scene.add(ground);

  // props: gravestones, trees, barrels
  for(let i=0;i<140;i++){
    if(Math.random() < 0.5){
      const h = 0.6 + Math.random()*1.6;
      const box = new THREE.Mesh(new THREE.BoxGeometry(0.6, h, 0.25), new THREE.MeshStandardMaterial({color:0x222222}));
      box.position.set((Math.random()-0.5)*worldSize, h/2, (Math.random()-0.5)*worldSize);
      box.rotation.y = Math.random()*Math.PI*2; scene.add(box); props.push(box);
    } else {
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,1.6,6), new THREE.MeshStandardMaterial({color:0x3b2b1a}));
      const leaves = new THREE.Mesh(new THREE.SphereGeometry(0.7,6,6), new THREE.MeshStandardMaterial({color:0x0f3b13}));
      const x=(Math.random()-0.5)*worldSize,z=(Math.random()-0.5)*worldSize;
      trunk.position.set(x,0.8,z); leaves.position.set(x,1.4,z); scene.add(trunk); scene.add(leaves); props.push(trunk); props.push(leaves);
    }
  }
  // lamp posts
  for(let i=0;i<10;i++){
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,2,6), new THREE.MeshStandardMaterial({color:0x444444}));
    pole.position.set((Math.random()-0.5)*worldSize,1,(Math.random()-0.5)*worldSize);
    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.12,6,6), new THREE.MeshStandardMaterial({emissive:0xfff1c6, emissiveIntensity:0.32, color:0x222222}));
    bulb.position.set(pole.position.x,pole.position.y+1,pole.position.z);
    scene.add(pole); scene.add(bulb);
    setInterval(()=>{ bulb.material.emissiveIntensity = 0.15 + Math.random()*0.6; }, 700 + Math.random()*1400);
  }

  clock = new THREE.Clock();
  window.addEventListener('resize', onResize);
  canvas.addEventListener('click', ()=>{ if(running) canvas.requestPointerLock?.(); });
  document.addEventListener('pointerlockchange', ()=>{ controlsEnabled = !!document.pointerLockElement; });
  window.addEventListener('mousedown',(e)=>{ if(!running) return; if(e.button===0){ mouseHeld=true; attemptShoot(); } if(e.button===2) aiming=true; });
  window.addEventListener('mouseup',(e)=>{ mouseHeld=false; if(e.button===2) aiming=false; });
  window.addEventListener('keydown',(e)=>{ if(e.key==='r' || e.key==='R') reloadWeapon(); if(e.key==='1') switchWeapon('pistol'); if(e.key==='2') switchWeapon('shotgun'); if(e.key==='3') switchWeapon('rifle'); if(e.key==='4') switchWeapon('flamethrower'); if(e.key==='f' || e.key==='F') meleeAttack(); if(e.key==='e' || e.key==='E') tryPickup(); if(e.key==='Escape') document.exitPointerLock?.(); if(e.key==='Tab') e.preventDefault(); });
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // particles & pools
  for(let i=0;i<6;i++) makeParticlePool();
}

/* -------------- controls -------------- */
let controlsEnabled=false;
const keys={w:0,a:0,s:0,d:0,shift:0};
function initControls(){
  window.addEventListener('keydown',(e)=>{ if(e.repeat) return; if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return; if(e.key.toLowerCase()==='w') keys.w=1; if(e.key.toLowerCase()==='a') keys.a=1; if(e.key.toLowerCase()==='s') keys.s=1; if(e.key.toLowerCase()==='d') keys.d=1; if(e.key==='Shift') keys.shift=1; });
  window.addEventListener('keyup',(e)=>{ if(e.key.toLowerCase()==='w') keys.w=0; if(e.key.toLowerCase()==='a') keys.a=0; if(e.key.toLowerCase()==='s') keys.s=0; if(e.key.toLowerCase()==='d') keys.d=0; if(e.key==='Shift') keys.shift=0; });
  window.addEventListener('mousemove',(e)=>{ if(!controlsEnabled) return; const mvX=e.movementX||0,mvY=e.movementY||0; camera.rotation.order='YXZ'; camera.rotation.y -= mvX*0.0026; camera.rotation.x -= mvY*0.0026; camera.rotation.x = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, camera.rotation.x)); });
}

/* -------------- particle pooling -------------- */
const pools=[];
function makeParticlePool(){
  const max=140;
  const geom=new THREE.BufferGeometry();
  const arr=new Float32Array(max*3); geom.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const mat=new THREE.PointsMaterial({size:0.08,transparent:true,opacity:0.9});
  const pts=new THREE.Points(geom,mat); pts.userData={max,alive:[]}; scene && scene.add(pts);
  pools.push(pts);
}
function spawnParticles(pos,color=0x8b0000,count=14,speed=3){
  for(const pool of pools){
    const ud=pool.userData; if(ud.alive.length + count <= ud.max){
      const arr=pool.geometry.attributes.position.array;
      for(let i=0;i<count;i++){
        const id = ud.alive.length + (Math.random()*0.0001); // not used as index storage - we store objects
        ud.alive.push({px:pos.x,py:pos.y,pz:pos.z,vx:(Math.random()-0.5)*speed,vy:Math.random()*speed*0.6+0.6,vz:(Math.random()-0.5)*speed,life:0,max:0.5+Math.random()*0.6});
      }
      pool.material.color.setHex(color);
      return;
    }
  }
}
function updateParticles(delta){
  for(const pool of pools){
    const ud=pool.userData;
    const arr=pool.geometry.attributes.position.array;
    let k=0;
    for(let i=ud.alive.length-1;i>=0;i--){
      const p=ud.alive[i];
      p.life += delta;
      p.vy -= 9.8*delta*0.7;
      p.px += p.vx*delta; p.py += p.vy*delta; p.pz += p.vz*delta;
      arr[k*3]=p.px; arr[k*3+1]=p.py; arr[k*3+2]=p.pz;
      k++; if(p.life >= p.max) ud.alive.splice(i,1);
    }
    pool.geometry.attributes.position.needsUpdate = true;
    pool.material.opacity = 0.9; // keep simple
  }
}

/* -------------- enemies -------------- */
function spawnZombie(kind=null, fromEdge=true){
  const types = ['walker','runner','tank','crawler','exploder','dog'];
  let t = kind || (Math.random()<0.06 ? 'tank' : (Math.random()<0.1 ? 'runner' : (Math.random()<0.06 ? 'exploder' : (Math.random()<0.07 ? 'crawler' : (Math.random()<0.06 ? 'dog' : 'walker')))));
  const mat = new THREE.MeshStandardMaterial({color: t==='tank' ? 0x2b3b1a : (t==='runner'?0x314011:0x273812), roughness:1});
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.15,0.5), mat);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color:0x556633}));
  head.position.set(0,0.95,0);
  const group = new THREE.Group(); group.add(torso); group.add(head);
  // position
  const angle = Math.random()*Math.PI*2; const r = fromEdge ? worldSize*0.95 : (Math.random()*0.6 + 0.2)*worldSize*0.8;
  group.position.set(Math.cos(angle)*r, 0.6, Math.sin(angle)*r);
  // stats
  if(kind === 'boss' || (Math.random()<0 && kind==='boss')){ // explicit boss spawn handled elsewhere
    group.scale.set(2.2,2.2,2.2); group.userData = {type:'boss',hp:140 + wave*36,baseSpeed:0.28,state:'chase',stateTime:0,lastGroan:0,lastDamage:0};
  } else {
    if(t==='walker') group.userData = {type:'walker',hp:3 + Math.floor(Math.random()*2 + wave*0.2),baseSpeed:0.5 + Math.random()*0.22,state:'wander',stateTime:0,lastGroan:0,lastDamage:0,targetOffset:new THREE.Vector3()};
    if(t==='runner') group.userData = {type:'runner',hp:2 + Math.floor(wave*0.08),baseSpeed:0.9 + Math.random()*0.8,state:'wander',stateTime:0,lastGroan:0,lastDamage:0,targetOffset:new THREE.Vector3()};
    if(t==='tank') group.userData = {type:'tank',hp:8 + Math.floor(wave*1.2),baseSpeed:0.35 + Math.random()*0.15,state:'wander',stateTime:0,lastGroan:0,lastDamage:0,targetOffset:new THREE.Vector3()};
    if(t==='crawler') group.userData = {type:'crawler',hp:2 + Math.floor(wave*0.5),baseSpeed:0.45 + Math.random()*0.2,state:'wander',stateTime:0,lastGroan:0,lastDamage:0,stealth:true,targetOffset:new THREE.Vector3()};
    if(t==='exploder') group.userData = {type:'exploder',hp:3 + Math.floor(wave*0.4),baseSpeed:0.5 + Math.random()*0.25,explodeRadius:2.3,state:'wander',stateTime:0,lastGroan:0,lastDamage:0,targetOffset:new THREE.Vector3()};
    if(t==='dog') group.userData = {type:'dog',hp:2,baseSpeed:1.4 + Math.random()*0.6,state:'wander',stateTime:0,lastGroan:0,lastDamage:0,targetOffset:new THREE.Vector3()};
  }
  scene.add(group); zombies.push(group);
}

/* -------------- AI helpers -------------- */
function computeSeparation(z){
  const sep=new THREE.Vector3(); let count=0;
  for(const o of zombies){ if(o===z) continue; const d=z.position.distanceTo(o.position); if(d < 2.0){ const diff=z.position.clone().sub(o.position).normalize().divideScalar(d); sep.add(diff); count++; } }
  if(count>0) sep.divideScalar(count);
  return sep;
}
function inFOV(z, angle=50*Math.PI/180, maxDist=22){
  const toZ = new THREE.Vector3().subVectors(z.position, camera.position); const horiz = Math.hypot(toZ.x,toZ.z);
  if(horiz > maxDist) return false;
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
  const toZNorm = toZ.clone(); toZNorm.y=0; toZNorm.normalize();
  const a = Math.acos(Math.max(-1,Math.min(1,forward.dot(toZNorm))));
  return a < angle;
}

/* -------------- Shooting -------------- */
function attemptShoot(){
  const k = currentWeapon, w = weapons[k], st = weaponState[k];
  if(st.reloading) return;
  const now = performance.now();
  if(now - st.lastShot < w.fireRate) return;
  if(st.ammo <= 0){ reloadWeapon(); return; }
  st.lastShot = now; st.ammo--; updateAmmoUI();
  ensureAudio(); sfx(900 + Math.random()*300, 0.05, 'square', 0.16);
  const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
  const dirBase = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  if(k === 'shotgun'){
    const spread = aiming ? w.adsSpread : w.hipSpread;
    for(let i=0;i<w.pellets;i++){
      const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
      rayDamage(origin,d,w.damage + Math.floor(Math.random()*2), 6.5 + wave*0.1);
    }
  } else if(k === 'flamethrower'){
    // continuous cone of short range
    const spread = 0.28 * (aiming?0.6:1);
    for(let i=0;i<8;i++){
      const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
      rayDamage(origin,d,w.damage, w.range);
    }
    spawnFlameParticles(origin,dirBase);
  } else {
    const spread = aiming ? w.adsSpread : w.hipSpread;
    const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
    rayDamage(origin,d,w.damage, k==='rifle'?80:120);
  }
  flashMuzzle();
}
function rayDamage(origin,dir,damage,maxRange){
  const ray = new THREE.Raycaster(origin,dir,0,maxRange);
  let closest=null,dist=Infinity;
  for(const z of zombies){ const box = new THREE.Box3().setFromObject(z); if(ray.ray.intersectsBox(box)){ const pt = ray.ray.intersectBox(box,new THREE.Vector3()); const d = origin.distanceTo(pt); if(d < dist){ dist=d; closest={z,pt}; } } }
  if(closest){
    const {z,pt} = closest; const falloff = Math.max(0.45,1 - dist/maxRange); const apply = Math.max(1, Math.round(damage * falloff));
    z.userData.hp -= apply; spawnParticles(pt,0x8b0000,10,3.2); sfx(220+Math.random()*120,0.05,'sawtooth',0.12);
    if(z.userData.hp <= 0) killZombie(z); else { if(z.userData.stealth) z.userData.stealth=false; if(z.userData.type==='runner' && Math.random()<0.28){ z.userData.state='dodge'; z.userData.stateTime=0; } }
  } else {
    const miss = origin.clone().add(dir.clone().multiplyScalar(maxRange*0.9)); spawnParticles(miss,0xffa766,6,1.6); // sparks
  }
}

/* -------------- muzzle & flame visuals -------------- */
function flashMuzzle(){ const el=document.createElement('div'); el.style.position='fixed'; el.style.left='50%'; el.style.top='58%'; el.style.transform='translate(-50%,-50%)'; el.style.width='26px'; el.style.height='14px'; el.style.borderRadius='8px'; el.style.background='rgba(255,220,160,0.96)'; el.style.zIndex=9999; document.body.appendChild(el); setTimeout(()=>el.remove(),36); }
function spawnFlameParticles(origin,dir){ // spawn near origin for a brief flame effect
  const base = origin.clone().add(dir.clone().multiplyScalar(0.6));
  spawnParticles(base,0xff6a2b,18,2.2);
}

/* -------------- kill / pickups -------------- */
function killZombie(z){
  spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.6,0)),0x8b0000,22,4.2);
  scene.remove(z); zombies = zombies.filter(o=>o!==z);
  let gain = 10; if(z.userData.type==='runner') gain+=3; if(z.userData.type==='tank') gain+=12; if(z.userData.type==='boss') gain+=300; if(z.userData.type==='dog') gain+=6;
  score += gain + Math.floor(Math.random()*6) + wave*2; scoreEl.textContent = score; sfx(160,0.16,'sine',0.18);
  // exploding zombie effect
  if(z.userData.type === 'exploder'){
    // damage nearby zombies
    for(const o of zombies){
      const d = o.position.distanceTo(z.position); if(d < z.userData.explodeRadius){ o.userData.hp -= 2 + Math.floor(Math.random()*3); spawnParticles(o.position,0xffaa44,10,2.6); if(o.userData.hp <= 0) killZombie(o); }
    }
  }
  // drop chance
  if(Math.random() < 0.28) spawnPickup(z.position.clone());
}

/* -------------- pickups -------------- */
function spawnPickup(pos){ const type = Math.random() < 0.5 ? 'ammo' : 'health'; const color = type==='ammo' ? 0x2b6cff : 0xff6b6b; const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.28,8,8), new THREE.MeshStandardMaterial({color})); mesh.position.copy(pos).add(new THREE.Vector3(0,0.6,0)); mesh.userData = {type, spawn:performance.now()}; scene.add(mesh); pickups.push(mesh); }
function tryPickup(){ let nearest=null, nd=Infinity; for(const p of pickups){ const d = p.position.distanceTo(camera.position); if(d < 2.0 && d < nd){ nd=d; nearest=p; } } if(nearest){ if(nearest.userData.type==='health'){ health = Math.min(100, health + 35); healthEl.textContent = health; showPickupText('+35 HP'); sfx(640,0.08,'triangle',0.12); } else { for(const k of Object.keys(weaponState)) weaponState[k].reserve += 10 + Math.floor(Math.random()*12); updateAmmoUI(); showPickupText('Ammo Pack'); sfx(920,0.08,'triangle',0.12); } scene.remove(nearest); pickups = pickups.filter(p=>p!==nearest); } }
function showPickupText(t){ pickupText.textContent = t; pickupText.style.display='block'; setTimeout(()=> pickupText.style.display='none',1200); }

/* -------------- reload & melee -------------- */
function reloadWeapon(){ const k=currentWeapon; const w=weapons[k]; const st=weaponState[k]; if(st.reloading) return; if(st.ammo >= w.mag) return; if(st.reserve <= 0) return; st.reloading=true; reloadText.style.display='block'; setTimeout(()=>{ const need = w.mag - st.ammo; const take = Math.min(need, st.reserve); st.reserve -= take; st.ammo += take; st.reloading=false; reloadText.style.display='none'; updateAmmoUI(); sfx(420,0.08,'sine',0.12); }, w.reloadTime); }
function meleeAttack(){ if(performance.now() < meleeCooldown) return; meleeCooldown = performance.now() + 900; sfx(480,0.06,'square',0.13); const origin = new THREE.Vector3(); camera.getWorldPosition(origin); const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); const ray = new THREE.Raycaster(origin,dir,0,1.8); for(const z of zombies){ const box = new THREE.Box3().setFromObject(z); if(ray.ray.intersectsBox(box)){ z.userData.hp -= 4 + Math.floor(Math.random()*3); spawnParticles(z.position.clone(),0x8b0000,10,3); if(z.userData.hp <= 0) killZombie(z); break; } } }

/* -------------- wave system -------------- */
function startWave(){ wave++; waveEl.textContent = wave; spawnInterval = Math.max(600, 1400 - (wave-1)*70); const initial = 3 + Math.floor(1.5*wave); for(let i=0;i<initial;i++){ if(wave % 6 === 0 && i===0) spawnZombie('boss', true); else spawnZombie(null,true); } }

/* -------------- update loop -------------- */
let lastTime=performance.now();
function update(delta){
  // movement
  const speed = (keys.shift ? 6.2 : 3.4); const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize(); const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
  const move = new THREE.Vector3(); if(keys.w) move.add(forward); if(keys.s) move.sub(forward); if(keys.a) move.sub(right); if(keys.d) move.add(right);
  if(move.lengthSq() > 0){ move.normalize().multiplyScalar(speed*delta); camera.position.add(move); camera.position.x = Math.max(-worldSize, Math.min(worldSize, camera.position.x)); camera.position.z = Math.max(-worldSize, Math.min(worldSize, camera.position.z)); }

  // auto fire rifle
  if(mouseHeld && weapons[currentWeapon].automatic) attemptShoot();

  // spawn
  if(performance.now() - lastSpawn > spawnInterval){ lastSpawn = performance.now(); const count = 1 + Math.floor(Math.random()*Math.min(4, 1 + Math.floor(wave/2))); for(let i=0;i<count;i++) spawnZombie(null,true); }

  // AI update
  for(const z of zombies){
    const ud = z.userData; ud.stateTime = (ud.stateTime || 0) + delta; const toPlayer = new THREE.Vector3().subVectors(camera.position, z.position); const dist = Math.hypot(toPlayer.x, toPlayer.z);
    if(ud.stealth){ if(inFOV(z,30*Math.PI/180,14) || dist < 6) ud.stealth = false; else z.visible = Math.random() < 0.98 ? false : true; } else z.visible = true;
    if(ud.type === 'boss'){
      const dir = camera.position.clone().setY(z.position.y).sub(z.position).normalize();
      z.position.x += dir.x * ud.baseSpeed * (1 + wave*0.02) * delta * 0.9; z.position.z += dir.z * ud.baseSpeed * (1 + wave*0.02) * delta * 0.9;
      if(dist < 2.0 && (!ud.lastDamage || performance.now() - ud.lastDamage > 900)){ ud.lastDamage = performance.now(); health -= 18; healthEl.textContent = health; sfx(160,0.16,'sawtooth',0.16); shakeScreen(6); if(health <= 0) endGame(); }
    } else {
      if(ud.state === 'wander'){ if(dist < (ud.type==='runner'?16:12) || inFOV(z)){ ud.state='chase'; ud.stateTime=0; ud.targetOffset.set((Math.random()-0.5)*1.6,0,(Math.random()-0.5)*1.6); } else { z.position.x += (Math.random()-0.5)*0.01; z.position.z += (Math.random()-0.5)*0.01; } }
      else if(ud.state === 'chase' || ud.state === 'flank'){ const desired = camera.position.clone().setY(z.position.y); const offsetRot = ud.targetOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), camera.rotation.y); desired.add(offsetRot); const dir = desired.clone().sub(z.position).setY(0).normalize(); const sep = computeSeparation(z).multiplyScalar(0.6); dir.add(sep).normalize(); const spd = ud.baseSpeed * (1 + Math.min(0.8, wave*0.03)); z.position.x += dir.x * spd * delta; z.position.z += dir.z * spd * delta; if(dist < 1.2){ ud.state='attack'; ud.stateTime=0; } else if(ud.state === 'chase' && Math.random() < 0.002 + wave*0.0008){ ud.state='flank'; ud.stateTime=0; ud.targetOffset.set((Math.random()-0.5)*2,0,(Math.random()-0.5)*2); } }
      else if(ud.state === 'dodge'){ const side=(Math.random()<0.5?1:-1); z.position.x += Math.cos(camera.rotation.y + side) * ud.baseSpeed * 3.6 * delta; z.position.z += Math.sin(camera.rotation.y + side) * ud.baseSpeed * 3.6 * delta; if(ud.stateTime > 0.35) ud.state='chase'; }
      else if(ud.state === 'attack'){ if(!ud.lastDamage || performance.now() - ud.lastDamage > 900){ ud.lastDamage = performance.now(); const dmg = ud.type==='tank'?12:(ud.type==='runner'?6:6); health -= dmg; healthEl.textContent = health; sfx(180,0.06,'sawtooth',0.12); shakeScreen(6); if(health <= 0) endGame(); } if(ud.stateTime > 0.9) ud.state='chase'; }
    }
    const lookAt = new THREE.Vector3(camera.position.x, z.position.y, camera.position.z); z.lookAt(lookAt);
  }

  // pickups bob
  for(const p of pickups) p.position.y = 0.5 + Math.sin(performance.now()/420 + p.position.x)*0.07;

  // particles update
  updateParticles(delta);

  // spawn new wave if few left
  if(zombies.length < Math.max(1, 2 + Math.floor(wave/2)) && performance.now() - lastWaveTime > 4000){
    lastWaveTime = performance.now(); startWave();
  }
}

/* -------------- rendering loop -------------- */
let fpsTime=0, fpsCount=0;
function loop(){
  if(!running) return;
  const t = performance.now(); const delta = Math.min(0.06,(t - lastFrame)/1000); lastFrame = t;
  update(delta); renderer.render(scene,camera);
  fpsTime += (t - (lastFrame - delta*1000)); fpsCount++; if(fpsTime > 1000){ fpsEl.textContent = 'FPS: ' + Math.round(fpsCount/(fpsTime/1000)); fpsTime=0; fpsCount=0; }
  requestAnimationFrame(loop);
}

/* -------------- start / end -------------- */
function startGame(){
  health=100; score=0; wave=0; healthEl.textContent=health; scoreEl.textContent=score; waveEl.textContent=wave;
  zombies.forEach(z=>scene.remove(z)); zombies=[]; pickups.forEach(p=>scene.remove(p)); pickups=[];
  for(const k of Object.keys(weaponState)){ weaponState[k].ammo = weapons[k].mag; weaponState[k].reserve = weapons[k].reserve; weaponState[k].reloading=false; weaponState[k].lastShot=0; }
  switchWeapon('pistol'); updateAmmoUI();
  overlay.style.display='none'; goDiv.style.display='none'; running=true;
  lastFrame = performance.now(); lastSpawn = performance.now(); lastWaveTime = performance.now();
  initThreeIfNeeded(); startWave(); loop(); ensureAudio(); sfx(720,0.08,'sine',0.14);
}
function endGame(){
  running=false; goDiv.style.display='flex'; goScore.textContent = 'Score: ' + score;
  const prev = parseInt(localStorage.getItem('nor_high')||'0',10); if(score > prev){ localStorage.setItem('nor_high', String(score)); highEl.textContent = score; sfx(960,0.28,'sine',0.2);} else sfx(120,0.6,'sawtooth',0.16);
}

/* -------------- utilities -------------- */
function onResize(){ if(!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
function initThreeIfNeeded(){ if(!scene) initThree(); }
initThree(); initControls(); // pre-load

/* UI wiring */
startBtn.addEventListener('click', ()=> startGame());
retryBtn.addEventListener('click', ()=> startGame());
muteBtn.addEventListener('click', ()=>{ muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Mute'; });
controlsBtn.addEventListener('click', ()=> { alert('Controls:\\nWASD - move\\nClick canvas to lock pointer\\nLeft click - shoot\\nRight click - aim (ADS)\\nR - reload\\n1-4 - switch weapons\\nF - melee / flashlight (toggle)\\nE - pick up items\\nShift - sprint'); });

/* weapon switching */
function switchWeapon(k){ currentWeapon = k; weaponNameEl.textContent = weapons[k].name; updateAmmoUI(); }

/* ammo UI */
function updateAmmoUI(){ const st=weaponState[currentWeapon]; ammoEl.textContent = Math.round(st.ammo); reserveEl.textContent = Math.round(st.reserve); }

/* screen shake */
let shakeTime = 0; function shakeScreen(str=8){ shakeTime = Math.max(shakeTime, str); const orig = camera.position.clone(); const tick = setInterval(()=>{ if(shakeTime <= 0){ clearInterval(tick); camera.position.lerp(orig,0.6); } else { camera.position.x += (Math.random()-0.5)*0.03* (shakeTime/8); camera.position.y += (Math.random()-0.5)*0.03*(shakeTime/8); shakeTime -= 0.8; } },16); }

/* flame particle small helper */
function spawnFlameParticle(pos){ spawnParticles(pos,0xff6f2b,8,1.6); }

/* show pickup text */
function showPickupText(txt){ pickupText.textContent = txt; pickupText.style.display = 'block'; setTimeout(()=> pickupText.style.display = 'none', 1200); }

/* initial demo zombies for menu */
for(let i=0;i<6;i++) spawnZombie(null,true);

/* highscore load */
const storedHigh = parseInt(localStorage.getItem('nor_high') || '0',10); highEl.textContent = storedHigh;

/* safety */
window.addEventListener('contextmenu', e => e.preventDefault());
</script>
</body>
</html>
