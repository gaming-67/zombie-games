<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Z-13: The Quarantine â€” Full</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
:root{--accent:#c73b3b;--muted:#bfc3c7;--hud-bg:rgba(6,6,8,0.72)}
html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui,Segoe UI,Helvetica,Arial}
canvas{display:block;width:100%;height:100vh}
/* Loading & Menu */
#loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:600;background:linear-gradient(#000,#000);}
#progressBar{width:60%;height:12px;border-radius:8px;background:rgba(255,255,255,0.04);overflow:hidden;margin-top:12px}
#progressFill{height:100%;width:0%;background:linear-gradient(90deg,#c73b3b,#ff7b7b)}
#menu{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:550;color:#fff}
.menu-card{width:min(980px,94%);padding:26px;border-radius:12px;background:rgba(0,0,0,0.46);text-align:center;box-shadow:0 20px 40px rgba(0,0,0,0.8)}
.title{font-size:40px;margin:0;color:#ffefe6;text-shadow:0 8px 24px rgba(0,0,0,0.8)}
.subtitle{color:var(--muted);margin-top:8px;font-size:14px}
.map-row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-top:12px}
.map-card{padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.03);cursor:pointer;font-weight:700}
.map-card.active{outline:2px solid rgba(199,59,59,0.9)}
.btn{background:var(--accent);border:none;color:#fff;padding:10px 14px;border-radius:8px;cursor:pointer;margin:6px}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
/* HUD */
#hud{position:fixed;left:12px;top:12px;z-index:520;background:var(--hud-bg);color:#fff;padding:10px;border-radius:10px;min-width:260px;display:none}
#weaponUI{position:fixed;right:12px;bottom:12px;z-index:520;background:var(--hud-bg);color:#fff;padding:10px;border-radius:10px;min-width:220px;display:none}
#crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:515;color:#fff;display:none;font-size:22px}
#pickupPrompt{position:fixed;left:50%;bottom:18%;transform:translateX(-50%);z-index:514;background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:8px;display:none}
#gameOver{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:560;background:rgba(0,0,0,0.96);color:#fff}
.game-over-card{background:rgba(0,0,0,0.6);padding:24px;border-radius:12px;text-align:center}
#pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:540}
.pause-card{background:rgba(0,0,0,0.6);padding:22px;border-radius:12px;color:#fff;text-align:center}
.blur{backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px)}
#pointerHint{position:fixed;left:50%;top:78%;transform:translateX(-50%);z-index:517;padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.36);color:#fff;display:none}
#fps{position:fixed;right:8px;top:8px;color:#ddd;z-index:600;display:none}
.save-toast{position:fixed;right:12px;bottom:12px;padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.6);color:#fff;z-index:700}
</style>
</head>
<body>
  <div id="loading">
    <div style="font-weight:800;color:#fff">LOADING Z-13: THE QUARANTINE...</div>
    <div id="progressBar"><div id="progressFill"></div></div>
    <div id="loadingText" style="color:var(--muted);margin-top:8px">Preparing maps & systems...</div>
  </div>

  <div id="menu" aria-hidden="true">
    <div class="menu-card">
      <div class="title">Z-13: The Quarantine</div>
      <div class="subtitle">Realistic Survival â€” kill required number of zombies to clear each wave</div>
      <div style="margin-top:12px;color:var(--muted)">Select Map</div>
      <div class="map-row" id="mapRow"></div>
      <div style="margin-top:14px">
        <button id="startBtn" class="btn">Start Game</button>
        <button id="loadBtn" class="btn ghost" style="display:none">Load Save</button>
        <button id="deleteSaveBtn" class="btn ghost" style="display:none">Delete Save</button>
        <button id="settingsBtn" class="btn ghost">Settings</button>
        <button id="creditsBtn" class="btn ghost">Credits</button>
      </div>
      <div style="margin-top:10px;color:var(--muted);font-size:12px">Developed by Six â€” single-file demo</div>
    </div>
  </div>

  <div id="pointerHint">ðŸŽ¯ Click to lock mouse â€¢ ESC to unlock</div>
  <div id="pickupPrompt">[E] Pick up</div>

  <div id="hud" aria-live="polite">
    <div style="display:flex;justify-content:space-between"><div>Health</div><div id="healthVal">100</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Score</div><div id="scoreVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Wave</div><div id="waveVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Zombies Left</div><div id="zLeft">0</div></div>
  </div>

  <div id="weaponUI">
    <div id="weaponName">Pistol</div>
    <div style="font-size:13px;margin-top:6px">Ammo: <span id="ammoVal">12</span>/<span id="reserveVal">36</span></div>
    <div id="powerUps" style="margin-top:8px;font-size:12px;color:var(--muted)"></div>
  </div>

  <div id="crosshair">+</div>

  <div id="pauseOverlay"><div class="pause-card blur">
    <h2>Paused</h2>
    <div style="margin-top:8px">
      <button id="resumeBtn" class="btn">Resume</button>
      <button id="saveBtn" class="btn">Save</button>
      <button id="restartBtn" class="btn">Restart</button>
      <button id="menuBtn" class="btn ghost">Main Menu</button>
    </div>
    <div style="margin-top:10px;color:var(--muted);font-size:13px">Settings placeholder â€” sensitivity & volume</div>
  </div></div>

  <div id="gameOver"><div class="game-over-card">
    <h1 id="goTitle">You Died</h1>
    <div id="goScore" style="margin-top:8px">Score: 0</div>
    <div style="margin-top:12px"><button id="retryBtn" class="btn">Retry</button><button id="menuBtn2" class="btn ghost">Main Menu</button></div>
  </div></div>

  <div id="fps"></div>

  <canvas id="gameCanvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* Z-13: The Quarantine â€” Full playable single-file
   - Fixed wave progression (kills counted + removed)
   - Map selection (8 maps)
   - Press E to pick up items
   - Lots of items, loot drops, power-ups
   - Pause menu, save/load/delete (localStorage)
   - Pointer lock + mouse look
   - Weather basics + explosive barrels as hazard
   - Realistic survival mode tuned for scarcity
*/

/* ----------------- Globals & UI refs ----------------- */
const canvas = document.getElementById('gameCanvas');
const loading = document.getElementById('loading'), progressFill = document.getElementById('progressFill'), loadingText = document.getElementById('loadingText');
const menu = document.getElementById('menu'), mapRow = document.getElementById('mapRow'), startBtn = document.getElementById('startBtn');
const loadBtn = document.getElementById('loadBtn'), deleteSaveBtn = document.getElementById('deleteSaveBtn'), settingsBtn = document.getElementById('settingsBtn');
const creditsBtn = document.getElementById('creditsBtn');
const hud = document.getElementById('hud'), healthVal = document.getElementById('healthVal'), scoreVal = document.getElementById('scoreVal'), waveVal = document.getElementById('waveVal'), zLeft = document.getElementById('zLeft');
const weaponUI = document.getElementById('weaponUI'), weaponNameEl = document.getElementById('weaponName'), ammoEl = document.getElementById('ammoVal'), reserveEl = document.getElementById('reserveVal');
const crosshair = document.getElementById('crosshair'), pickupPrompt = document.getElementById('pickupPrompt');
const pauseOverlay = document.getElementById('pauseOverlay'), resumeBtn = document.getElementById('resumeBtn'), saveBtn = document.getElementById('saveBtn'), restartBtn = document.getElementById('restartBtn'), menuBtn = document.getElementById('menuBtn');
const gameOver = document.getElementById('gameOver'), retryBtn = document.getElementById('retryBtn'), menuBtn2 = document.getElementById('menuBtn2');
const pointerHint = document.getElementById('pointerHint'), fpsEl = document.getElementById('fps');

let scene, camera, renderer, clock;
let running=false, gameStarted=false, paused=false;
let playerHealth=100, score=0, wave=0;
let zombies = [], pickups = [], props = [], particlePools = [];
let zombiesThisWave=0, killsThisWave=0;
let lastSpawn = 0, spawnInterval = 1200, intermissionEnd = 0;
let lastFrame = performance.now();
let audioCtx = null;

/* ----------------- Maps ----------------- */
const maps = [
  {id:'graveyard', name:'Graveyard', desc:'Fog & tombstones', fog:0x0b0b10, fogDensity:0.014, ambient:'wind', spawnBias:0},
  {id:'city', name:'City Ruins', desc:'Fire & rubble', fog:0x111017, fogDensity:0.012, ambient:'sirens', spawnBias:0.05},
  {id:'facility', name:'Quarantine Facility', desc:'Red alarms', fog:0x070707, fogDensity:0.0095, ambient:'alarms', spawnBias:0.12},
  {id:'forest', name:'Forest Outbreak', desc:'Rain & lightning', fog:0x08121a, fogDensity:0.015, ambient:'rain', spawnBias:-0.05},
  {id:'subway', name:'Subway Tunnels', desc:'Claustrophobic tunnels', fog:0x050405, fogDensity:0.018, ambient:'echo', spawnBias:0.2},
  {id:'harbor', name:'Harbor Docks', desc:'Fog over water', fog:0x081018, fogDensity:0.012, ambient:'waves', spawnBias:0},
  {id:'hospital', name:'Hospital Outbreak', desc:'Flickering lights & hallways', fog:0x060708, fogDensity:0.013, ambient:'machines', spawnBias:0.1},
  {id:'base', name:'Military Base', desc:'Searchlights & turrets', fog:0x0a0a0a, fogDensity:0.01, ambient:'alarms', spawnBias:0.18}
];
let selectedMap = maps[0];

/* build map UI */
maps.forEach((m,i)=>{
  const el = document.createElement('div');
  el.className = 'map-card';
  if(i===0) el.classList.add('active');
  el.textContent = m.name;
  el.title = m.desc;
  el.addEventListener('click', ()=> { document.querySelectorAll('.map-card').forEach(x=>x.classList.remove('active')); el.classList.add('active'); selectedMap = m; });
  mapRow.appendChild(el);
});

/* ----------------- Weapons & Items ----------------- */
const weapons = {
  pistol:{name:'Pistol',mag:12,reserve:48,fireRate:260,damage:4,automatic:false,reloadTime:900},
  shotgun:{name:'Shotgun',mag:6,reserve:36,fireRate:700,damage:6,pellets:7,automatic:false,reloadTime:1300},
  smg:{name:'SMG',mag:40,reserve:200,fireRate:90,damage:1,automatic:true,reloadTime:1100},
  rifle:{name:'Rifle',mag:30,reserve:120,fireRate:95,damage:1.8,automatic:true,reloadTime:1400},
  sniper:{name:'Sniper',mag:5,reserve:25,fireRate:900,damage:28,automatic:false,reloadTime:2200},
  flamethrower:{name:'Flamethrower',mag:120,reserve:400,fireRate:40,damage:0.18,automatic:true,reloadTime:2000},
  grenade:{name:'Grenade',mag:1,reserve:2,fireRate:800,damage:18,automatic:false,reloadTime:800}
};
let currentWeapon = 'pistol';
let weaponState = {};
for(const k in weapons) weaponState[k] = {ammo:weapons[k].mag, reserve:weapons[k].reserve, reloading:false, lastShot:0};

/* inventory / powerups */
let inventory = {grenades:2, batteries:1, medkits:1};
let activePowerups = {}; // {name:{expires:timestamp, ...}}

/* ----------------- Audio helpers ----------------- */
function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ audioCtx=null; console.warn('Audio not available'); } } }
function sfx(freq=440,dur=0.06,type='sine',vol=0.12){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination);
  g.gain.value = 0.0001; g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
  o.start(); o.stop(audioCtx.currentTime + dur);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
}

/* ----------------- Three scene & loading ----------------- */
function setProgress(p,text){ progressFill.style.width = Math.round(p*100)+'%'; if(text) loadingText.textContent = text; }
function initScene(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(selectedMap.fog, selectedMap.fogDensity);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2500);
  camera.position.set(0,1.6,0);
  renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  const hemi = new THREE.HemisphereLight(0x8888aa,0x222222,0.9); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff0c8,0.5); dir.position.set(8,12,6); scene.add(dir);

  // ground (map-specific style)
  const groundMat = new THREE.MeshStandardMaterial({color: (selectedMap.id==='forest'?0x0d2b12:0x0f0f10) });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(600,600,8,8), groundMat);
  ground.rotation.x = -Math.PI/2; scene.add(ground);

  // environment props per map (simple)
  props = [];
  if(selectedMap.id === 'graveyard'){
    for(let i=0;i<80;i++){
      if(Math.random()<0.7){
        const h = 0.6 + Math.random()*1.6;
        const t = new THREE.Mesh(new THREE.BoxGeometry(0.6,h,0.25), new THREE.MeshStandardMaterial({color:0x2b2b2b}));
        t.position.set((Math.random()-0.5)*160, h/2, (Math.random()-0.5)*160);
        t.rotation.y = Math.random()*Math.PI*2; scene.add(t); props.push(t);
      } else {
        const tree = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,1.6,6), new THREE.MeshStandardMaterial({color:0x3b2b1a}));
        tree.position.set((Math.random()-0.5)*160,0.8,(Math.random()-0.5)*160); scene.add(tree); props.push(tree);
      }
    }
  } else if(selectedMap.id === 'city'){
    for(let i=0;i<60;i++){
      const box = new THREE.Mesh(new THREE.BoxGeometry(2+Math.random()*6, 1+Math.random()*8, 1+Math.random()*6), new THREE.MeshStandardMaterial({color:0x1a1a1a}));
      box.position.set((Math.random()-0.5)*200, (box.geometry.parameters.height/2), (Math.random()-0.5)*200); box.rotation.y = Math.random()*Math.PI*2; scene.add(box); props.push(box);
    }
  } else if(selectedMap.id === 'facility' || selectedMap.id === 'hospital'){
    for(let i=0;i<40;i++){
      const crate = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.2,1.6), new THREE.MeshStandardMaterial({color:0x222222}));
      crate.position.set((Math.random()-0.5)*140, 0.6, (Math.random()-0.5)*140); scene.add(crate); props.push(crate);
    }
  } else {
    // generic props for other maps
    for(let i=0;i<60;i++){
      const prop = new THREE.Mesh(new THREE.BoxGeometry(1,1+Math.random()*3,1), new THREE.MeshStandardMaterial({color:0x25302a}));
      prop.position.set((Math.random()-0.5)*160, prop.geometry.parameters.height/2, (Math.random()-0.5)*160); scene.add(prop); props.push(prop);
    }
  }

  // some explosive barrels as hazards
  for(let i=0;i<12;i++){
    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.8,10), new THREE.MeshStandardMaterial({color:0x6b2b2b}));
    barrel.position.set((Math.random()-0.5)*120,0.4,(Math.random()-0.5)*120); barrel.userData = {explosive:true}; scene.add(barrel); props.push(barrel);
  }

  // particle pools
  particlePools = [];
  for(let i=0;i<4;i++){
    const max = 120; const geom = new THREE.BufferGeometry(); const arr = new Float32Array(max*3); geom.setAttribute('position', new THREE.BufferAttribute(arr,3));
    const mat = new THREE.PointsMaterial({size:0.08,transparent:true,opacity:0.9});
    const pts = new THREE.Points(geom, mat); pts.userData = {max, alive:[]}; scene.add(pts); particlePools.push(pts);
  }

  clock = new THREE.Clock();
  window.addEventListener('resize', onResize);
}

/* ----------------- Particles ----------------- */
function spawnParticles(pos, color=0x8b0000, count=12, speed=3){
  for(const pool of particlePools){
    const ud = pool.userData;
    if(ud.alive.length + count <= ud.max){
      for(let i=0;i<count;i++){
        ud.alive.push({px:pos.x,py:pos.y,pz:pos.z,vx:(Math.random()-0.5)*speed,vy:Math.random()*speed*0.6+0.6,vz:(Math.random()-0.5)*speed,life:0,max:0.4+Math.random()*0.6});
      }
      pool.material.color.setHex(color);
      pool.geometry.attributes.position.needsUpdate = true;
      return;
    }
  }
}
function updateParticles(delta){
  for(const pool of particlePools){
    const ud = pool.userData; const arr = pool.geometry.attributes.position.array; let k=0;
    for(let i = ud.alive.length-1; i>=0; i--){
      const p = ud.alive[i]; p.life += delta; p.vy -= 9.8*delta*0.7; p.px += p.vx*delta; p.py += p.vy*delta; p.pz += p.vz*delta;
      arr[k*3] = p.px; arr[k*3+1] = p.py; arr[k*3+2] = p.pz; k++;
      if(p.life >= p.max) ud.alive.splice(i,1);
    }
    pool.geometry.attributes.position.needsUpdate = true;
  }
}

/* ----------------- Zombies ----------------- */
function spawnZombie(type=null){
  const types = ['walker','runner','crawler','exploder','tank','dog','screamer','spitter'];
  const t = type || (Math.random()<0.06?'tank':(Math.random()<0.12?'runner':(Math.random()<0.07?'exploder':(Math.random()<0.06?'crawler':Math.random()<0.06?'screamer':(Math.random()<0.06?'spitter':'walker'))))));
  const colorMap = {walker:0x3db34b, runner:0x3b7fd9, crawler:0x8b5a2b, exploder:0xd94b3b, tank:0x7a2bd9, dog:0xf2f2f2, screamer:0x7bd3ff, spitter:0x8cf27a};
  const mat = new THREE.MeshStandardMaterial({color:colorMap[t] || 0x3db34b});
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.05,0.5), mat);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.45,0.45,0.45), new THREE.MeshStandardMaterial({color:0x4a5a33}));
  head.position.set(0,0.9,0);
  const g = new THREE.Group(); g.add(torso); g.add(head);

  // spawn near player (30..70)
  const angle = Math.random()*Math.PI*2;
  const r = 30 + Math.random()*40 + (selectedMap.spawnBias || 0)*20; // 30..70
  g.position.set(camera.position.x + Math.cos(angle)*r, 0.6, camera.position.z + Math.sin(angle)*r);

  // properties
  if(t==='tank') g.userData = {type:'tank', hp:10 + wave*2, speed:0.35, attack:14};
  else if(t==='runner') g.userData = {type:'runner', hp:3 + Math.floor(wave*0.2), speed:1.1, attack:6};
  else if(t==='crawler') g.userData = {type:'crawler', hp:2 + Math.floor(wave*0.4), speed:0.45, stealth:true, attack:5};
  else if(t==='exploder') g.userData = {type:'exploder', hp:3 + Math.floor(wave*0.4), speed:0.5, explodeRadius:2.4, attack:6};
  else if(t==='dog') g.userData = {type:'dog', hp:2, speed:1.4, attack:6};
  else if(t==='screamer') g.userData = {type:'screamer', hp:3, speed:0.6, attack:4, alert:true};
  else if(t==='spitter') g.userData = {type:'spitter', hp:3, speed:0.6, attack:6, ranged:true};
  else g.userData = {type:'walker', hp:3 + Math.floor(Math.random()*2 + wave*0.2), speed:0.45 + Math.random()*0.2, attack:6};

  scene.add(g);
  zombies.push(g);
  return g;
}

function killZombie(z){
  if(!z) return;
  spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.6,0)), 0x9b1b1b, 22, 4.2);
  // remove from scene + array
  try{ scene.remove(z); }catch(e){}
  const idx = zombies.indexOf(z); if(idx>=0) zombies.splice(idx,1);
  killsThisWave++; score += (z.userData.type==='tank'?30:10) + Math.floor(Math.random()*8); scoreVal.textContent = score;
  // loot drop
  if(Math.random() < 0.35){
    const pickType = Math.random()<0.5 ? 'ammo' : (Math.random()<0.2?'medkit':'grenade');
    const pick = spawnPickup(z.position.clone(), pickType);
    // slight offset
    pick.position.add(new THREE.Vector3((Math.random()-0.5)*1.2, 0.4, (Math.random()-0.5)*1.2));
  }
  // screamer spawns reinforcements
  if(z.userData && z.userData.type === 'screamer'){
    // spawn 2 extras
    for(let i=0;i<2;i++) setTimeout(()=>spawnZombie(), 700 + Math.random()*800);
  }
  checkWaveClear();
}

/* ----------------- Pickups & E-to-collect ----------------- */
function spawnPickup(pos, type='ammo'){
  const color = type==='ammo' ? 0x2b6cff : (type==='medkit' ? 0xff6b6b : 0xffe066);
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.28,10,10), new THREE.MeshStandardMaterial({color: color, emissive: color, emissiveIntensity:0.3}));
  mesh.position.copy(pos); mesh.userData = {pickup:true, type};
  scene.add(mesh);
  pickups.push(mesh);
  return mesh;
}
function tryPickup(){
  // find nearest pickup within 2 units
  let nearest = null, nd=Infinity;
  for(const p of pickups){
    const d = p.position.distanceTo(camera.position);
    if(d < 2 && d < nd){ nd = d; nearest = p; }
  }
  if(!nearest) return;
  const type = nearest.userData.type;
  scene.remove(nearest); pickups = pickups.filter(x=>x!==nearest);
  if(type === 'ammo'){
    // add ammo to each weapon reserves moderately
    for(const k in weaponState){ weaponState[k].reserve += 8 + Math.floor(Math.random()*14); }
    sfx(920,0.08,'triangle',0.12);
    showPickupToast('+Ammo');
  } else if(type === 'medkit'){
    playerHealth = Math.min(100, playerHealth + 30);
    healthVal.textContent = playerHealth; sfx(720,0.08,'sine',0.12); showPickupToast('+30 HP');
  } else if(type === 'grenade'){
    inventory.grenades = (inventory.grenades || 0) + 1; showPickupToast('+1 Grenade'); sfx(820,0.08,'sine',0.12);
  } else {
    showPickupToast('Picked up ' + type);
  }
  updateAmmoUI();
}
function showPickupToast(txt){
  const t = document.createElement('div'); t.className='save-toast'; t.textContent = txt; document.body.appendChild(t);
  setTimeout(()=> t.style.opacity = '0', 900); setTimeout(()=> t.remove(), 1400);
}

/* show on-screen E prompt when near a pickup */
function updatePickupPrompt(){
  let near=false;
  for(const p of pickups){ if(p.position.distanceTo(camera.position) < 2.0){ near=true; break; } }
  pickupPrompt.style.display = near ? 'block' : 'none';
}

/* ----------------- Shooting & raycasting ----------------- */
function changeWeapon(key){
  currentWeapon = key; weaponNameEl.textContent = weapons[key].name; updateAmmoUI();
}
function updateAmmoUI(){
  const st = weaponState[currentWeapon];
  ammoEl.textContent = Math.round(st.ammo); reserveEl.textContent = Math.round(st.reserve);
  weaponNameEl.textContent = weapons[currentWeapon].name;
}
function attemptShoot(){
  const k = currentWeapon, w = weapons[k], st = weaponState[k];
  if(st.reloading) return;
  const now = performance.now();
  if(now - st.lastShot < w.fireRate) return;
  if(st.ammo <= 0){ reloadWeapon(); return; }
  st.lastShot = now; st.ammo--; updateAmmoUI();
  ensureAudio(); sfx(900 + Math.random()*300, 0.05, 'square', 0.14);
  const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  if(k === 'shotgun'){
    for(let i=0;i<w.pellets;i++){
      const d = dir.clone().add(new THREE.Vector3((Math.random()-0.5)*0.16,(Math.random()-0.5)*0.16,(Math.random()-0.5)*0.16)).normalize();
      rayDamage(origin,d,w.damage+Math.floor(Math.random()*2),8);
    }
  } else if(k==='grenade'){
    // throw grenade to point 6 units ahead
    const pt = origin.clone().add(dir.multiplyScalar(6));
    spawnExplosion(pt, w.damage+6);
  } else if(k === 'flamethrower'){
    for(let i=0;i<6;i++){
      const d = dir.clone().add(new THREE.Vector3((Math.random()-0.5)*0.22,(Math.random()-0.5)*0.22,(Math.random()-0.5)*0.22)).normalize();
      rayDamage(origin,d,w.damage,6);
    }
    spawnParticles(origin.clone().add(dir.clone().multiplyScalar(0.8)), 0xff652b, 18, 2.2);
  } else {
    rayDamage(origin, dir, w.damage, (k==='rifle'?140:140));
  }
  flashMuzzle();
}
function rayDamage(origin, dir, damage, maxRange){
  const ray = new THREE.Raycaster(origin, dir, 0, maxRange);
  let hit=null, hitDist=Infinity;
  for(const z of zombies){
    const box = new THREE.Box3().setFromObject(z);
    if(ray.ray.intersectsBox(box)){
      const pt = ray.ray.intersectBox(box,new THREE.Vector3());
      const d = origin.distanceTo(pt);
      if(d < hitDist){ hitDist = d; hit = {z,pt}; }
    }
  }
  if(hit){
    const {z,pt} = hit; const falloff = Math.max(0.5, 1 - hitDist/maxRange); const applied = Math.max(1, Math.round(damage * falloff));
    z.userData.hp -= applied; spawnParticles(pt, 0x9b1b1b, 10, 3.2); sfx(220+Math.random()*120, 0.05, 'sawtooth', 0.11);
    // only show screen blood if player got hit (we handle elsewhere)
    if(z.userData.hp <= 0) killZombie(z);
    else {
      // small stagger: push back a bit
      z.position.add(new THREE.Vector3((Math.random()-0.5)*0.2,0,(Math.random()-0.5)*0.2));
    }
  } else {
    // miss particle
    spawnParticles(origin.clone().add(dir.clone().multiplyScalar(maxRange*0.9)), 0xffaa66, 4, 1.4);
  }
}
function flashMuzzle(){ const el = document.createElement('div'); el.style.position='fixed'; el.style.left='50%'; el.style.top='58%'; el.style.transform='translate(-50%,-50%)'; el.style.width='28px'; el.style.height='12px'; el.style.borderRadius='8px'; el.style.background='rgba(255,220,160,0.96)'; el.style.zIndex=9999; document.body.appendChild(el); setTimeout(()=>el.remove(),36); }

/* ----------------- Explosions ----------------- */
function spawnExplosion(pos, damage){
  spawnParticles(pos, 0xff9a2b, 28, 4.6);
  sfx(80, 0.6, 'sawtooth', 0.18);
  // affect zombies within radius
  for(const z of zombies.slice()){
    const d = z.position.distanceTo(pos);
    if(d < 4.2){ z.userData.hp -= Math.max(2, Math.round(damage * (1 - d/4.2))); if(z.userData.hp <= 0) killZombie(z); }
  }
  // also trigger nearby explosive props
  for(const p of props){
    if(p.userData && p.userData.explosive){
      const d = p.position.distanceTo(pos);
      if(d < 5.2){
        // trigger big explosion at prop
        spawnParticles(p.position, 0xff7a2b, 40, 6.0);
        try{ scene.remove(p); }catch(e){} // remove barrel
      }
    }
  }
}

/* ----------------- Wave system (fixed) ----------------- */
function spawnWave(count){
  zombiesThisWave = count; killsThisWave = 0; zLeft.textContent = zombiesThisWave - killsThisWave;
  // spawn in batches to avoid instant overcrowd
  for(let i=0;i<count;i++){
    setTimeout(()=> spawnZombie(), i*120 + Math.random()*400);
  }
}
function startWave(){
  wave++; waveVal.textContent = wave;
  // number scaling (you wanted kill a number per wave)
  const base = 8 + Math.floor(wave * 3);
  spawnWave(base + Math.floor(wave*1.5));
  sfx(720, 0.12, 'sine', 0.12);
}
function checkWaveClear(){
  const left = Math.max(0, zombiesThisWave - killsThisWave);
  zLeft.textContent = left;
  if(left === 0 && gameStarted){
    // intermission & countdown
    intermissionEnd = performance.now() + 5000; // 5s intermission (you asked for slow-mo)
    // drop a few pickups
    for(let i=0;i<3;i++){
      spawnPickup(camera.position.clone().add(new THREE.Vector3((Math.random()-0.5)*5,0,(Math.random()-0.5)*5)), Math.random()<0.5?'ammo':'medkit');
    }
    // autosave on wave complete
    z13_save && z13_save.save && z13_save.save(false);
    // show "wave cleared" banner (simple)
    showWaveBanner('Wave Cleared');
  }
}

/* show wave banner + slow motion effect */
function showWaveBanner(text){
  const b = document.createElement('div'); b.style.position='fixed'; b.style.left='50%'; b.style.top='12%'; b.style.transform='translateX(-50%)'; b.style.padding='8px 16px'; b.style.background='rgba(0,0,0,0.6)'; b.style.color='#fff'; b.style.fontWeight='800'; b.style.zIndex=900; b.style.borderRadius='10px'; b.textContent = text; document.body.appendChild(b);
  // slow-motion
  const origRAF = true;
  // fade after 4.5s
  setTimeout(()=> b.style.opacity = '0', 4200); setTimeout(()=> b.remove(), 4600);
}

/* ----------------- Input & Controls ----------------- */
let keys = {}, controlsEnabled = false, mouseHeld=false;
let sensitivity = 0.0022;
function initControls(){
  window.addEventListener('keydown', (e)=> {
    if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
    const k = e.key.toLowerCase();
    if(k==='w') keys.w=1; if(k==='s') keys.s=1; if(k==='a') keys.a=1; if(k==='d') keys.d=1;
    if(e.key === 'Shift') keys.shift = 1;
    if(k==='e'){ tryPickup(); }
    if(k==='r'){ reloadWeapon(); }
    if(k==='1') changeWeapon('pistol'); if(k==='2') changeWeapon('shotgun'); if(k==='3') changeWeapon('smg');
    if(k==='4') changeWeapon('rifle'); if(k==='5') changeWeapon('sniper'); if(k==='6') changeWeapon('flamethrower');
    if(k==='g'){ throwGrenade(); }
    if(e.key === 'Escape'){ togglePause(true); }
  });
  window.addEventListener('keyup', (e)=> {
    const k = e.key.toLowerCase();
    if(k==='w') keys.w=0; if(k==='s') keys.s=0; if(k==='a') keys.a=0; if(k==='d') keys.d=0; if(e.key==='Shift') keys.shift=0;
  });
  window.addEventListener('mousemove', (e)=> {
    if(!controlsEnabled) return;
    const mvX = e.movementX || 0, mvY = e.movementY || 0;
    camera.rotation.order = 'YXZ';
    camera.rotation.y -= mvX * sensitivity;
    camera.rotation.x -= mvY * sensitivity;
    camera.rotation.x = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, camera.rotation.x));
  });
  window.addEventListener('mousedown', (e)=> {
    if(!gameStarted || paused) return;
    if(e.button === 0){ mouseHeld = true; attemptShoot(); }
    if(e.button === 2) {} // right-click could aim
  });
  window.addEventListener('mouseup', ()=> { mouseHeld = false; });
  document.addEventListener('pointerlockchange', ()=> {
    controlsEnabled = (document.pointerLockElement === canvas);
    pointerHint.style.display = controlsEnabled ? 'none' : 'block';
  });
  window.addEventListener('contextmenu', e => e.preventDefault());
}

/* grenade */
function throwGrenade(){
  if(inventory.grenades > 0){
    inventory.grenades--; const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
    const pt = origin.add(dir.multiplyScalar(6));
    spawnExplosion(pt, 20);
    showPickupToast('-1 Grenade used');
  } else showPickupToast('No grenades');
}

/* ----------------- Reload ----------------- */
function reloadWeapon(){
  const st = weaponState[currentWeapon]; const w = weapons[currentWeapon];
  if(st.reloading) return; if(st.ammo >= w.mag) return; if(st.reserve <= 0) return;
  st.reloading = true; setTimeout(()=>{ const need = w.mag - st.ammo; const take = Math.min(need, st.reserve); st.reserve -= take; st.ammo += take; st.reloading = false; updateAmmoUI(); sfx(420,0.08,'sine',0.12); }, w.reloadTime);
}

/* ----------------- Update & Loop ----------------- */
function update(delta){
  // movement
  const speed = keys.shift ? 5.6 : 3.2;
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
  const move = new THREE.Vector3();
  if(keys.w) move.add(forward); if(keys.s) move.sub(forward); if(keys.a) move.sub(right); if(keys.d) move.add(right);
  if(move.lengthSq()>0){ move.normalize().multiplyScalar(speed * delta); camera.position.add(move); camera.position.x = Math.max(-280, Math.min(280, camera.position.x)); camera.position.z = Math.max(-280, Math.min(280, camera.position.z)); }

  // auto-fire for autos if holding
  if(mouseHeld && weapons[currentWeapon].automatic) attemptShoot();

  // spawn periodic extras
  if(performance.now() - lastSpawn > spawnInterval && !intermissionEnd && !paused && running){
    lastSpawn = performance.now();
    const count = 1 + Math.floor(Math.random()*Math.min(3, 1 + Math.floor(wave/4)));
    for(let i=0;i<count;i++) spawnZombie();
  }

  // zombies AI
  for(const z of zombies.slice()){
    const ud = z.userData; ud._t = (ud._t||0) + delta;
    const toPlayer = new THREE.Vector3().subVectors(camera.position, z.position);
    const dist = Math.hypot(toPlayer.x, toPlayer.z);
    // growl occasionally
    if(dist < 50 && (!ud._growl || performance.now() - ud._growl > 3000)){ ud._growl = performance.now(); sfx(120 + Math.random()*120, 0.12, 'triangle', 0.06); }
    // stealth
    if(ud.stealth){ if(dist < 6) ud.stealth=false; else z.visible = Math.random()<0.98?false:true; } else z.visible = true;
    // movement toward player
    const dir = camera.position.clone().setY(z.position.y).sub(z.position).normalize();
    const sep = computeSeparation(z).multiplyScalar(0.6);
    dir.add(sep).normalize();
    const spd = (ud.speed || 0.5) * (1 + wave*0.02);
    z.position.x += dir.x * spd * delta; z.position.z += dir.z * spd * delta;
    // ranged spit
    if(ud.ranged && dist < 10 && Math.random() < 0.008){ // spitter spit
      // create acid projectile particle (visual)
      spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.8,0)), 0x66ff66, 8, 2.4);
      // minor damage if in line
      if(dist < 3){ playerHit(6); }
    }
    // attack if close
    if(dist < 1.6 && (!ud._hit || performance.now() - ud._hit > 900)){
      ud._hit = performance.now();
      playerHit(ud.attack || 6);
    }
    z.lookAt(new THREE.Vector3(camera.position.x, z.position.y, camera.position.z));
  }

  // pickups bob
  for(const p of pickups) p.position.y = 0.5 + Math.sin(performance.now()/420 + p.position.x)*0.07;

  // particles update
  updateParticles(delta);

  // intermission timer
  if(intermissionEnd && performance.now() > intermissionEnd){
    intermissionEnd = 0;
    // start next wave with scaling
    const nextCount = 8 + Math.floor(wave*3.2);
    startWave();
  }

  // update pickup prompt
  updatePickupPrompt();
}

function computeSeparation(z){
  const sep = new THREE.Vector3(); let count=0;
  for(const o of zombies){ if(o===z) continue; const d = z.position.distanceTo(o.position); if(d < 2.0){ const diff = z.position.clone().sub(o.position).normalize().divideScalar(d); sep.add(diff); count++; } }
  if(count>0) sep.divideScalar(count);
  return sep;
}

/* player hit */
function playerHit(dmg){
  // if invincible powerup active ignore
  const now = performance.now();
  if(activePowerups['ghost'] && activePowerups['ghost'].expires > now) return;
  playerHealth -= dmg; healthVal.textContent = playerHealth; sfx(160,0.12,'sawtooth',0.12);
  // screen flash
  const v = document.createElement('div'); v.style.position='fixed'; v.style.inset='0'; v.style.pointerEvents='none'; v.style.zIndex=9998; v.style.background='radial-gradient(circle at 50% 20%, rgba(160,0,0,0.12), rgba(0,0,0,0))'; document.body.appendChild(v); setTimeout(()=> v.remove(), 160);
  if(playerHealth <= 0) endGame();
}

/* main loop */
let fpsTime=0, fpsCount=0;
function loop(){
  if(!running) return;
  const t = performance.now();
  const delta = Math.min(0.06, (t - lastFrame)/1000);
  lastFrame = t;
  if(!paused) {
    update(delta);
    renderer.render(scene, camera);
  }
  fpsCount++; fpsTime += (t - (lastFrame - delta*1000));
  if(fpsTime > 1000){ fpsEl.textContent = 'FPS: ' + Math.round(fpsCount / (fpsTime/1000)); fpsTime = 0; fpsCount = 0; }
  requestAnimationFrame(loop);
}

/* ----------------- Start / Pause / End ----------------- */
function startGame(){
  ensureAudio();
  initScene();
  initControls();
  // reset state
  playerHealth = 100; score = 0; wave = 0; killsThisWave = 0; zombiesThisWave = 0;
  healthVal.textContent = playerHealth; scoreVal.textContent = score; waveVal.textContent = wave; zLeft.textContent = 0;
  for(const k in weaponState){ weaponState[k].ammo = weapons[k].mag; weaponState[k].reserve = weapons[k].reserve; weaponState[k].reloading=false; weaponState[k].lastShot=0; }
  currentWeapon = 'pistol'; updateAmmoUI();
  // clean arrays
  zombies.forEach(z=>scene.remove(z)); zombies = [];
  pickups.forEach(p=>scene.remove(p)); pickups=[];
  props.forEach(p=>scene.remove(p)); props=[];
  // (recreate environment)
  initScene();
  menu.style.display = 'none';
  hud.style.display = 'block'; weaponUI.style.display = 'block'; crosshair.style.display = 'block'; fpsEl.style.display = 'block';
  // pointer lock
  try{ canvas.requestPointerLock(); }catch(e){ console.warn('Pointer lock request failed', e); }
  pointerHint.style.display = 'block';
  running = true; gameStarted = true; paused = false; lastFrame = performance.now(); lastSpawn = performance.now();
  startWave();
  loop();
}

function togglePause(show){
  if(!gameStarted) return;
  paused = show;
  if(show){
    pauseOverlay.style.display = 'flex';
    // unlock pointer
    document.exitPointerLock?.();
    // autosave
    z13_save && z13_save.save && z13_save.save(false);
  } else {
    pauseOverlay.style.display = 'none';
    canvas.requestPointerLock();
  }
}

function endGame(){
  running = false; gameOver.style.display = 'flex';
  document.getElementById('goScore').textContent = 'Score: ' + score;
  // store highscore
  const prev = parseInt(localStorage.getItem('z13_high')||'0',10);
  if(score > prev){ localStorage.setItem('z13_high', String(score)); }
  document.exitPointerLock?.();
}

/* ----------------- UI wiring ----------------- */
startBtn.addEventListener('click', ()=> { ensureAudio(); startBtn.disabled = true; setTimeout(()=> { startBtn.disabled=false; startGame(); }, 120); });
resumeBtn.addEventListener('click', ()=> togglePause(false));
restartBtn.addEventListener('click', ()=> { gameOver.style.display='none'; running=false; setTimeout(()=> startGame(), 120); });
menuBtn.addEventListener('click', ()=> { running=false; gameStarted=false; try{ renderer && renderer.clear(); }catch(e){} menu.style.display='flex'; hud.style.display='none'; weaponUI.style.display='none'; crosshair.style.display='none'; pointerHint.style.display='none'; });
retryBtn.addEventListener('click', ()=> { gameOver.style.display='none'; startGame();});
menuBtn2.addEventListener('click', ()=> { gameOver.style.display='none'; menu.style.display='flex'; hud.style.display='none'; weaponUI.style.display='none'; crosshair.style.display='none'; });

saveBtn.addEventListener('click', ()=> { z13_save && z13_save.save && z13_save.save(true); });

creditsBtn.addEventListener('click', ()=> alert('Z-13: The Quarantine\\nBuilt by Six â€” Single-file demo'));
settingsBtn.addEventListener('click', ()=> alert('Settings placeholder â€” sensitivity/volume'));

/* pickups: E binding handled in keydown listener earlier */

/* pointer lock re-request on canvas click */
canvas.addEventListener('click', ()=> { if(!document.pointerLockElement) try{ canvas.requestPointerLock(); } catch(e){} });

/* ----------------- Save System (integrated) ----------------- */
/* Paste of the previously-provided save system adapted to this file */
(function(){
  const SAVE_KEY = 'z13_save_v1';
  function buildSave(){
    try{
      const payload = {
        version:1,
        timestamp: Date.now(),
        player: {
          health: Math.max(0, Math.round(playerHealth || 0)),
          score: Math.round(score || 0),
          wave: Math.round(wave || 0),
          position: camera ? {x: camera.position.x, y: camera.position.y, z: camera.position.z} : null
        },
        map: { id: selectedMap && selectedMap.id ? selectedMap.id : null },
        weapons: {},
        inventory: {
          grenades: inventory.grenades || 0,
          batteries: inventory.batteries || 0,
          medkits: inventory.medkits || 0
        },
        meta: {
          userAgent: navigator.userAgent,
          savedAt: new Date().toISOString()
        }
      };
      if(window.weaponState){
        for(const k in window.weaponState){
          payload.weapons[k] = { ammo: window.weaponState[k].ammo, reserve: window.weaponState[k].reserve };
        }
      }
      return payload;
    }catch(e){ console.error('Save build failed', e); return null; }
  }
  function saveGame(manual=false){
    const data = buildSave(); if(!data) return false;
    try{ localStorage.setItem(SAVE_KEY, JSON.stringify(data)); showSaveToast(manual ? 'Game saved' : 'Auto-saved'); return true; } catch(e){ showSaveToast('Save failed'); return false; }
  }
  function loadGame(){
    try{
      const raw = localStorage.getItem(SAVE_KEY); if(!raw) return false;
      const data = JSON.parse(raw);
      if(data.player){
        playerHealth = data.player.health || 100; healthVal.textContent = playerHealth;
        score = data.player.score || 0; scoreVal.textContent = score;
        wave = data.player.wave || 0; waveVal.textContent = wave;
        if(data.player.position && camera) camera.position.set(data.player.position.x || 0, data.player.position.y || 1.6, data.player.position.z || 0);
      }
      if(data.map && data.map.id){
        const found = maps.find(m => m.id === data.map.id); if(found) selectedMap = found;
      }
      if(data.weapons){
        for(const k in data.weapons){ if(window.weaponState && window.weaponState[k]){ window.weaponState[k].ammo = data.weapons[k].ammo || window.weaponState[k].ammo; window.weaponState[k].reserve = data.weapons[k].reserve || window.weaponState[k].reserve; } }
        updateAmmoUI();
      }
      inventory.grenades = (data.inventory && data.inventory.grenades) || inventory.grenades;
      inventory.batteries = (data.inventory && data.inventory.batteries) || inventory.batteries;
      inventory.medkits = (data.inventory && data.inventory.medkits) || inventory.medkits;
      showSaveToast('Game loaded');
      return true;
    }catch(e){ console.error('Load failed', e); showSaveToast('Load failed'); return false; }
  }
  function deleteSave(){ localStorage.removeItem(SAVE_KEY); showSaveToast('Save deleted'); loadBtn.style.display='none'; deleteSaveBtn.style.display='none'; }
  function addMenuButtons(){
    // show Load/Delete if save exists
    const exists = !!localStorage.getItem(SAVE_KEY);
    if(exists){ loadBtn.style.display='inline-block'; deleteSaveBtn.style.display='inline-block'; } else { loadBtn.style.display='none'; deleteSaveBtn.style.display='none'; }
    loadBtn.onclick = ()=> { const ok = confirm('Load saved game? This will replace current session.'); if(ok){ if(loadGame()){ menu.style.display='none'; startGame(); } } };
    deleteSaveBtn.onclick = ()=> { const ok = confirm('Delete saved game?'); if(ok) deleteSave(); };
  }
  function showSaveToast(text){
    const t = document.createElement('div'); t.className='save-toast'; t.textContent=text; document.body.appendChild(t); setTimeout(()=> t.style.opacity=0,900); setTimeout(()=> t.remove(),1400);
  }
  // attach auto-save triggers
  let lastWaveSeen = wave;
  setInterval(()=> { try{ if(typeof wave !== 'undefined' && wave !== lastWaveSeen){ lastWaveSeen = wave; saveGame(false); addMenuButtons(); } }catch(e){} }, 2500);
  document.addEventListener('visibilitychange', ()=> { if(document.hidden) saveGame(false); });
  window.addEventListener('beforeunload', ()=> { saveGame(false); });
  document.addEventListener('DOMContentLoaded', ()=> { addMenuButtons(); });
  window.z13_save = { save: saveGame, load: loadGame, del: deleteSave };
})();

/* ----------------- Bootstrap loading simulation ----------------- */
setTimeout(()=> setProgress(0.15,'Preparing world...'), 80);
setTimeout(()=> setProgress(0.35,'Loading props...'), 200);
setTimeout(()=> setProgress(0.6,'Spawning test zombies...'), 420);
setTimeout(()=> setProgress(0.9,'Finalizing...'), 680);
setTimeout(()=> { setProgress(1,'Ready'); loading.style.display='none'; menu.style.display='flex'; }, 980);

/* ----------------- Helpers exposed for testing ----------------- */
window._spawnZombie = spawnZombie;
window._startWave = startWave;
window._killAll = ()=> { zombies.slice().forEach(z=>killZombie(z)); };
window._save = ()=> z13_save.save(true);
window._load = ()=> z13_save.load();

/* ----------------- Resize handler ----------------- */
function onResize(){ if(!camera || !renderer) return; camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

initControls(); // register control listeners early so E works in menu

</script>
</body>
</html>
