<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Z-13: The Quarantine — Expanded Prototype</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{--accent:#c73b3b;--muted:#b9bcc0;--hud-bg:rgba(6,6,8,0.72)}
  html,body{height:100%;margin:0;background:#020204;overflow:hidden;font-family:Inter,system-ui,Segoe UI,Helvetica,Arial}
  canvas{display:block;width:100%;height:100vh}
  .center-full{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:999}
  #loading{background:linear-gradient(#010103,#000);color:#fff;flex-direction:column}
  #progressBar{width:56%;height:14px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden}
  #progressFill{height:100%;width:0%;background:linear-gradient(90deg,#c73b3b,#ff7b7b)}
  .menu-card{width:min(1120px,96%);padding:18px;border-radius:12px;background:rgba(0,0,0,0.6);text-align:center;color:#fff}
  .btn{background:var(--accent);border:none;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer;margin:6px}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  #hud{position:fixed;left:12px;top:12px;z-index:950;background:var(--hud-bg);color:#fff;padding:12px;border-radius:12px;min-width:420px;display:none}
  #weaponUI{position:fixed;right:12px;bottom:12px;z-index:950;background:var(--hud-bg);color:#fff;padding:12px;border-radius:12px;min-width:260px;display:none}
  #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:945;color:#fff;display:none;font-size:20px}
  #pickupPrompt,#interactPrompt{position:fixed;left:50%;bottom:18%;transform:translateX(-50%);z-index:944;background:rgba(0,0,0,0.65);color:#fff;padding:8px 12px;border-radius:8px;display:none}
  #missionBox{position:fixed;right:12px;top:12px;z-index:950;background:rgba(0,0,0,0.6);padding:10px;border-radius:10px;color:#fff;min-width:260px;display:none}
  #dialogBox{position:fixed;left:50%;bottom:6%;transform:translateX(-50%);z-index:960;background:rgba(0,0,0,0.8);padding:12px;border-radius:10px;color:#fff;display:none;min-width:560px}
  #pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:980}
  .pause-card{background:rgba(0,0,0,0.72);padding:16px;border-radius:12px;color:#fff;text-align:center;width:520px}
  #gameOver{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:990;background:rgba(0,0,0,0.96);color:#fff}
  .save-toast{position:fixed;right:12px;bottom:12px;padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.6);color:#fff;z-index:995}
  .info-card{ width:920px; max-width:94%; padding:18px; border-radius:10px; background:rgba(8,8,10,0.8); text-align:left; max-height:86vh; overflow:auto; color:#fff;}
  #minimapContainer { position: fixed; right: 18px; bottom: 18px; width: 220px; height: 220px; border-radius: 10px; overflow: hidden; background: rgba(2,2,2,0.45); border: 2px solid rgba(0,200,140,0.12); box-shadow: 0 6px 14px rgba(0,0,0,0.6); z-index: 1200; display:flex; align-items:center; justify-content:center; }
  #minimapCanvas{width:100%;height:100%;display:block}
  #minimapLegend{position:absolute;left:8px;top:8px;font-size:11px;color:#cfe;text-shadow:0 1px 0 #0008;opacity:0.9;z-index:1202;pointer-events:none}
  #minimapLarge { position: fixed; right: 18px; bottom: 18px; width: 420px; height: 420px; z-index:1201; border-radius:12px; border:2px solid rgba(255,255,255,0.03); display:none; }
  .small-ind{ font-size:12px;color:var(--muted) }
</style>
</head>
<body>
  <div id="loading" class="center-full" style="display:flex">
    <div style="text-align:center">
      <h2 style="margin:0">LOADING Z-13: THE QUARANTINE — Expanded</h2>
      <div style="height:12px"></div>
      <div id="progressBar"><div id="progressFill"></div></div>
      <div id="loadingText" style="color:var(--muted);margin-top:8px">Preparing assets & systems...</div>
    </div>
  </div>

  <div id="menu" class="center-full" style="display:none">
    <div class="menu-card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="font-size:32px;font-weight:900">Z-13: The Quarantine</div>
          <div style="color:var(--muted)">Expanded Prototype — Infection, AI, Interiors, Minimap</div>
        </div>
      </div>
      <div style="margin-top:12px;color:var(--muted)">Campaign</div>
      <div style="margin-top:8px">Prologue → Outskirts → Factory → Facility</div>
      <div style="margin-top:12px">
        <button id="startBtn" class="btn">Start Campaign</button>
        <button id="quickBtn" class="btn ghost">Quick Wave</button>
        <button id="howBtn" class="btn ghost">How to Play</button>
      </div>
      <div style="margin-top:12px;color:var(--muted)">Tip: Press <strong>M</strong> for big map. Collect antivirals to lower infection.</div>
    </div>
  </div>

  <div id="howto" style="display:none" class="center-full"><div class="info-card"><h2>How to Play</h2>
    <p>WASD move, mouse look, left click shoot, R reload, 1–6 switch weapons, F flashlight, E pick up/open, T talk, G grenade, V melee, M toggle large map, Esc pause.</p>
    <p>Infection grows when bitten — use antivirals to reduce it. Interiors contain loot & lore. Complete objectives to progress chapters.</p>
    <div style="text-align:right"><button id="howBack" class="btn">Back</button></div>
  </div></div>

  <div id="pickupPrompt">[E] Pick up / Open</div>
  <div id="interactPrompt">[T] Interact</div>
  <div id="missionBox" style="display:none"></div>
  <div id="dialogBox"></div>

  <div id="hud" style="display:none">
    <div style="display:flex;justify-content:space-between"><div>HP</div><div id="healthVal">100</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Score</div><div id="scoreVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Wave</div><div id="waveVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Z Left</div><div id="zLeft">0</div></div>
    <div style="margin-top:8px" class="hud-row">
      <div class="small-ind">Battery: <span id="batteryVal">100%</span></div>
      <div class="small-ind">Infection: <span id="infectVal">0%</span></div>
      <div class="small-ind">Flash: <span id="flashVal">OFF</span></div>
    </div>
  </div>

  <div id="weaponUI" style="display:none">
    <div id="weaponName">Pistol</div>
    <div style="font-size:13px;margin-top:6px">Ammo: <span id="ammoVal">12</span>/<span id="reserveVal">48</span></div>
    <div id="invList" style="margin-top:8px;font-size:12px;color:var(--muted)"></div>
  </div>

  <div id="crosshair">+</div>

  <div id="pauseOverlay" style="display:none"><div class="pause-card">
    <h2>Paused</h2>
    <div style="margin-top:10px"><button id="resumeBtn" class="btn">Resume</button> <button id="saveBtn" class="btn">Save</button> <button id="restartBtn" class="btn">Restart</button> <button id="menuBtn" class="btn ghost">Main Menu</button></div>
  </div></div>

  <div id="tradeBox" style="display:none;position:fixed;left:50%;top:60%;transform:translate(-50%,-50%);z-index:995;background:rgba(0,0,0,0.85);color:#fff;padding:12px;border-radius:10px;width:360px;text-align:center">
    <div id="tradeText">Trader</div>
    <div style="margin-top:10px">
      <button id="buyAmmoBtn" class="btn">Buy Ammo (50)</button>
      <button id="buyMedBtn" class="btn">Buy Medkit (80)</button>
      <button id="closeTrade" class="btn ghost">Close</button>
    </div>
  </div>

  <div id="gameOver" style="display:none"><div style="background:rgba(0,0,0,0.6);padding:20px;border-radius:12px;text-align:center;color:#fff">
    <h1 id="gameOverTitle">You Died</h1>
    <div id="finalScore" style="margin-top:8px">Score: 0</div>
    <div style="margin-top:12px"><button id="retryBtn" class="btn">Retry Chapter</button><button id="menuBtnEnd" class="btn ghost">Main Menu</button></div>
  </div></div>

  <div id="minimapContainer" style="display:none"><div id="minimapLegend"></div><canvas id="minimapCanvas"></canvas></div>
  <canvas id="minimapLarge" style="display:none"></canvas>

  <canvas id="gameCanvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/* Z-13 Expanded Prototype — single file
   - Campaign, Infection, Advanced AI, Interiors, Minimap
   - Procedural assets; Three.js only dependency (CDN)
*/

/* ==== Basic refs ==== */
const canvas = document.getElementById('gameCanvas');
const loading = document.getElementById('loading'), fill = document.getElementById('progressFill'), ltxt = document.getElementById('loadingText');
const menu = document.getElementById('menu'), startBtn = document.getElementById('startBtn'), quickBtn = document.getElementById('quickBtn');
const hud = document.getElementById('hud'), healthVal = document.getElementById('healthVal'), scoreVal = document.getElementById('scoreVal'), waveVal = document.getElementById('waveVal'), zLeft = document.getElementById('zLeft');
const batteryVal = document.getElementById('batteryVal'), flashVal = document.getElementById('flashVal'), infectVal = document.getElementById('infectVal');
const pickupPrompt = document.getElementById('pickupPrompt'), interactPrompt = document.getElementById('interactPrompt');
const dialogBox = document.getElementById('dialogBox'), missionBox = document.getElementById('missionBox');
const tradeBox = document.getElementById('tradeBox'), tradeText = document.getElementById('tradeText');
const pauseOverlay = document.getElementById('pauseOverlay'), resumeBtn=document.getElementById('resumeBtn'), saveBtn=document.getElementById('saveBtn'), restartBtn=document.getElementById('restartBtn'), menuBtn=document.getElementById('menuBtn');
const gameOver = document.getElementById('gameOver'), retryBtn=document.getElementById('retryBtn'), menuBtnEnd=document.getElementById('menuBtnEnd');
const minimapContainer = document.getElementById('minimapContainer'), minimapCanvas = document.getElementById('minimapCanvas'), minimapLegend = document.getElementById('minimapLegend'), minimapLarge = document.getElementById('minimapLarge');
const howBtn = document.getElementById('howBtn'), howto = document.getElementById('howto'), howBack = document.getElementById('howBack');

/* ==== global state ==== */
let scene, camera, renderer, clock;
let running=false, gameStarted=false, paused=false;
let playerHealth=100, batteryCharge=100, infection=0, hunger=100, thirst=100;
let score=0, wave=0;
let zombies=[], pickups=[], props=[], survivors=[], lorePages=[];
let weaponState={}, currentWeapon='pistol';
let audioCtx=null;
let lastFrame=performance.now(), lastSpawn=0, spawnInterval=1200, intermissionEnd=0;
let settings = {particles:'full', maxZombies:60, shadows:true};

/* ==== maps & campaign ==== */
const maps = [
  {id:'city', name:'City Ruins', rain:true, fog:0x0f1116, fogDensity:0.012},
  {id:'forest', name:'Forest Outskirts', rain:false, fog:0x071217, fogDensity:0.018},
  {id:'factory', name:'Factory Powerdown', rain:false, fog:0x060506, fogDensity:0.01},
  {id:'facility', name:'Research Facility', rain:false, fog:0x0a0a0b, fogDensity:0.009}
];
const CAMPAIGN = [
  {id:'prologue', map:'city', name:'Prologue — City Ruins', objective:'Escape the avenue'},
  {id:'outskirts', map:'forest', name:'Chapter 1 — Outskirts', objective:'Find survivor outpost'},
  {id:'factory', map:'factory', name:'Chapter 2 — Factory', objective:'Restore the generator'},
  {id:'facility', map:'facility', name:'Finale — Research Facility', objective:'Retrieve core'}
];
let currentChapterIndex = 0, selectedMap = maps[0], chapterState = {};

/* ==== weapons (simple) ==== */
const weapons = {
  pistol:{name:'Pistol',mag:12,reserve:72,rate:260,damage:7,auto:false,reload:900},
  shotgun:{name:'Shotgun',mag:6,reserve:36,rate:800,damage:12,pellets:8,auto:false,reload:1500},
  smg:{name:'SMG',mag:40,reserve:160,rate:70,damage:2,auto:true,reload:1200},
  sniper:{name:'Sniper',mag:5,reserve:20,rate:900,damage:48,auto:false,reload:2000},
  flamethrower:{name:'Flamethrower',mag:100,reserve:300,rate:60,damage:0.8,area:true,auto:true,reload:4000},
  bat:{name:'Bat',mag:1,reserve:0,rate:400,damage:14,melee:true,auto:false}
};
for(const k in weapons) weaponState[k] = {ammo:weapons[k].mag, reserve:weapons[k].reserve, reloading:false, lastShot:0};

/* ==== audio helper ==== */
function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ audioCtx=null; } } }
function sfx(freq=440,dur=0.06,type='sine',vol=0.12){ if(!audioCtx) return; const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(audioCtx.destination); g.gain.value=0.0001; g.gain.linearRampToValueAtTime(vol,audioCtx.currentTime+0.01); o.start(); o.stop(audioCtx.currentTime+dur); g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+dur); }

/* ==== loading simulation ==== */
async function doLoad(){
  const assets = ['core','maps','ai','infections','interiors','minimap','ui'];
  for(let i=0;i<assets.length;i++){ fill.style.width = Math.round(((i+1)/assets.length)*100) + '%'; ltxt.textContent = 'Loading ' + assets[i] + '...'; await new Promise(r=>setTimeout(r, 60 + Math.random()*120)); }
  loading.style.display='none'; menu.style.display='flex';
}
doLoad();

/* ==== scene init & map generators ==== */
let moonLight=null, ambientLight=null, flashlight=null;
function initScene(){
  scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(selectedMap.fog || 0x0a0a0b, selectedMap.fogDensity || 0.01);
  camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 4000);
  camera.position.set(0,1.6,0);
  renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,1.5));
  renderer.shadowMap.enabled = settings.shadows;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  moonLight = new THREE.DirectionalLight(0x9fbfff, 0.9); moonLight.position.set(-48,140,18); moonLight.castShadow=true;
  moonLight.shadow.camera.left = -1600; moonLight.shadow.camera.right = 1600; moonLight.shadow.camera.top=1600; moonLight.shadow.camera.bottom=-1600;
  scene.add(moonLight);

  ambientLight = new THREE.AmbientLight(0x202225, 0.45); scene.add(ambientLight);

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000,4000,2,2), new THREE.MeshStandardMaterial({color:0x0b0d0f,roughness:1}));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow=true; scene.add(ground);

  // clear arrays and repopulate
  props.forEach(p=>{ try{ if(p.mesh) scene.remove(p.mesh); }catch(e){} }); props=[]; pickups.forEach(p=>{ try{ scene.remove(p); }catch(e){} }); pickups=[]; zombies.forEach(z=>{ try{ scene.remove(z); }catch(e){} }); zombies=[]; survivors.forEach(s=>{ try{ scene.remove(s); }catch(e){} }); survivors=[]; lorePages=[];

  // spawn map-specific content
  if(selectedMap.id === 'city') generateCity();
  else if(selectedMap.id === 'forest') generateForest();
  else if(selectedMap.id === 'factory') generateFactory(); // improved
  else generateFacility(); // improved
}

/* ---- city/factory/forest/facility generators (procedural) ---- */
function generateCity(){
  selectedMap = maps.find(m=>m.id==='city'); for(let i=0;i<60;i++){ const bW=10+Math.random()*24, bH=8+Math.floor(Math.random()*40), bD=10+Math.random()*22; const x=(Math.random()-0.5)*700, z=(Math.random()-0.5)*700; const m = new THREE.Mesh(new THREE.BoxGeometry(bW,bH,bD), new THREE.MeshStandardMaterial({color:0x22272b,roughness:0.95})); m.position.set(x,bH/2,z); m.castShadow=true; scene.add(m); props.push({type:'building',mesh:m}); if(Math.random()<0.18){ spawnPickup(new THREE.Vector3(x,(Math.random()*bH*0.6)+0.6,z),'ammo'); } }
  for(let i=0;i<10;i++) spawnSurvivor(new THREE.Vector3((Math.random()-0.5)*360,0,(Math.random()-0.5)*360));
  for(let i=0;i<18;i++) createLore('city-'+i,'City Log '+(i+1),'Short fragment about the breach.');
}
function generateForest(){
  selectedMap = maps.find(m=>m.id==='forest'); for(let i=0;i<300;i++){ if(Math.random()<0.72){ const t = new THREE.Mesh(new THREE.CylinderGeometry(0.28,0.6,3+Math.random()*4,6), new THREE.MeshStandardMaterial({color:0x3b2b1a})); t.position.set((Math.random()-0.5)*1600,(t.geometry.parameters.height/2),(Math.random()-0.5)*1600); t.castShadow=true; scene.add(t); props.push({type:'tree',mesh:t}); } else { const rock = new THREE.Mesh(new THREE.BoxGeometry(1+Math.random()*1.4,0.6+Math.random()*0.8,1+Math.random()*1.4), new THREE.MeshStandardMaterial({color:0x242b27})); rock.position.set((Math.random()-0.5)*1400,rock.geometry.parameters.height/2,(Math.random()-0.5)*1400); scene.add(rock); props.push({type:'rock',mesh:rock}); } }
  for(let i=0;i<6;i++) createLore('forest-'+i,'Forest Note '+(i+1),'A torn page.');
  for(let i=0;i<6;i++) spawnSurvivor(new THREE.Vector3((Math.random()-0.5)*900,0,(Math.random()-0.5)*900));
}

/* Factory Powerdown — improved: multi-floor conveyors, generator objective, sparks, interiors */
function generateFactory(){
  selectedMap = maps.find(m=>m.id==='factory');
  // large boxes & catwalks
  for(let i=0;i<260;i++){ const box = new THREE.Mesh(new THREE.BoxGeometry(1+Math.random()*4,1+Math.random()*3,1+Math.random()*3), new THREE.MeshStandardMaterial({color:0x2a2a2a})); box.position.set((Math.random()-0.5)*900, box.geometry.parameters.height/2, (Math.random()-0.5)*900); box.castShadow=true; scene.add(box); props.push({type:'crate',mesh:box}); }
  // generator region (objective)
  const genPos = new THREE.Vector3(12,0,8);
  const gen = new THREE.Mesh(new THREE.BoxGeometry(2.2,1.4,1.6), new THREE.MeshStandardMaterial({color:0xffaa22}));
  gen.position.copy(genPos); scene.add(gen); props.push({type:'generator',mesh:gen,pos:genPos,active:false});
  // conveyor belts (visual)
  for(let i=0;i<16;i++){ const conv = new THREE.Mesh(new THREE.BoxGeometry(10,0.6,3), new THREE.MeshStandardMaterial({color:0x202020})); conv.position.set(-120 + i*30, 0.3, -40 + (Math.floor(i/4)*15)); conv.castShadow=true; scene.add(conv); props.push({type:'conveyor',mesh:conv}); }
  // sparks & particle nodes
  for(let i=0;i<20;i++){ if(Math.random()<0.4) props.push({type:'spark',pos:new THREE.Vector3((Math.random()-0.5)*600,0.6,(Math.random()-0.5)*600)}); }
  // survivors & loot & lore
  for(let i=0;i<14;i++){ if(Math.random()<0.6) spawnPickup(new THREE.Vector3((Math.random()-0.5)*600,0.4,(Math.random()-0.5)*600),'ammo'); }
  for(let i=0;i<8;i++) spawnSurvivor(new THREE.Vector3((Math.random()-0.5)*600,0,(Math.random()-0.5)*600));
  for(let i=0;i<12;i++) createLore('factory-'+i,'Factory Note '+(i+1),'Generator logs and alarm records.');
}

/* Research Facility — improved: labs, containment pods, core, puzzles */
function generateFacility(){
  selectedMap = maps.find(m=>m.id==='facility');
  // lab tables
  for(let i=0;i<140;i++){ const table=new THREE.Mesh(new THREE.BoxGeometry(2+Math.random()*2,0.6,1+Math.random()*1.2), new THREE.MeshStandardMaterial({color:0xdfe6ea})); table.position.set((Math.random()-0.5)*520, table.geometry.parameters.height/2 + 0.3, (Math.random()-0.5)*520); table.castShadow=true; scene.add(table); props.push({type:'table',mesh:table}); }
  // containment pods & core (boss)
  const corePos = new THREE.Vector3(18,0,18); const core = new THREE.Mesh(new THREE.SphereGeometry(0.9,12,12), new THREE.MeshStandardMaterial({color:0x66ddff,emissive:0x66ddff,emissiveIntensity:0.6})); core.position.copy(corePos); scene.add(core); props.push({type:'core',mesh:core,pos:corePos});
  // console for upload
  const console = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.9,0.7), new THREE.MeshStandardMaterial({color:0x33aaee})); console.position.set(corePos.x+3,0.45,corePos.z+1.2); scene.add(console); props.push({type:'console',mesh:console,pos:console.position});
  // lore + survivors
  for(let i=0;i<12;i++) createLore('facility-'+i,'Facility Log '+(i+1),'Research notes and warnings.');
  spawnSurvivor(new THREE.Vector3(10,0,20));
}

/* ==== particles pool for impacts ==== */
let particlePools = [];
function initParticlePools(){
  particlePools = []; const pools = settings.particles === 'low' ? 3 : settings.particles === 'medium' ? 5 : 8;
  for(let i=0;i<pools;i++){ const max = settings.particles === 'low'? 120 : settings.particles === 'medium'? 240 : 420; const geom = new THREE.BufferGeometry(); const arr = new Float32Array(max*3); geom.setAttribute('position', new THREE.BufferAttribute(arr,3)); const mat = new THREE.PointsMaterial({size:0.08,transparent:true,opacity:0.95}); const pts = new THREE.Points(geom, mat); pts.userData = {max, alive:[]}; scene.add(pts); particlePools.push(pts); }
}
function spawnParticles(pos,color=0x8b0000,count=12,speed=3){
  for(const pool of particlePools){ const ud = pool.userData; if(ud.alive.length + count <= ud.max){ for(let i=0;i<count;i++){ ud.alive.push({px:pos.x,py:pos.y,pz:pos.z,vx:(Math.random()-0.5)*speed,vy:Math.random()*speed*0.6+0.6,vz:(Math.random()-0.5)*speed,life:0,max:0.4+Math.random()*0.6}); } pool.material.color.setHex(color); pool.geometry.attributes.position.needsUpdate=true; return; } }
}
function updateParticles(delta){
  for(const pool of particlePools){ const ud=pool.userData; const arr=pool.geometry.attributes.position.array; let k=0; for(let i=ud.alive.length-1;i>=0;i--){ const p=ud.alive[i]; p.life += delta; p.vy -= 9.8*delta*0.7; p.px += p.vx*delta; p.py += p.vy*delta; p.pz += p.vz*delta; arr[k*3] = p.px; arr[k*3+1] = p.py; arr[k*3+2] = p.pz; k++; if(p.life >= p.max) ud.alive.splice(i,1); } pool.geometry.attributes.position.needsUpdate=true; }
}

/* ==== lore system ==== */
let loreDB = {}, collectedLore = {};
function createLore(id,title,text){ loreDB[id] = {id,title,text}; const pos = new THREE.Vector3((Math.random()-0.5)*500,0.6 + Math.random()*1.6,(Math.random()-0.5)*500); const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.26,10,10), new THREE.MeshStandardMaterial({color:0x9ad4ff,emissive:0x9ad4ff,emissiveIntensity:0.6})); mesh.position.copy(pos); mesh.userData={lore:true,id}; scene && scene.add(mesh); lorePages.push(mesh); }
function collectLore(id){ if(collectedLore[id]) return; collectedLore[id] = true; localStorage.setItem('z13_lore_expanded', JSON.stringify(collectedLore)); showToast('Lore collected: ' + (loreDB[id]?.title||id)); }

/* ==== survivors / traders ==== */
function spawnSurvivor(pos){
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.6,1.2,0.4), new THREE.MeshStandardMaterial({color:0x8fb38f}));
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.36,0.36,0.36), new THREE.MeshStandardMaterial({color:0xd9bba6}));
  const g = new THREE.Group(); g.add(body); g.add(head); g.position.set(pos.x,0,pos.z); g.userData={type:'survivor',trade:{ammo:50,medkit:80},hp:100,dialog:['We hold here.']}; scene.add(g); survivors.push(g);
}

/* ==== pickups ==== */
function spawnPickup(pos,type='ammo'){ const color = type==='ammo'?0x2b6cff:(type==='medkit'?0xff6b6b:(type==='antiviral'?0x7af2c7:0xffd46b)); const m = new THREE.Mesh(new THREE.SphereGeometry(0.28,10,10), new THREE.MeshStandardMaterial({color:color,emissive:color,emissiveIntensity:0.28})); m.position.copy(pos); m.userData={pickup:true,type}; m.castShadow=true; scene.add(m); pickups.push(m); return m; }
function tryPickup(){
  for(const l of lorePages){ if(l && l.position.distanceTo(camera.position) < 2.0){ const id = l.userData?.id; if(id){ collectLore(id); try{ scene.remove(l); }catch(e){} lorePages = lorePages.filter(x=>x!==l); } return; } }
  let near=null, nd=Infinity;
  for(const p of pickups){ const d = p.position.distanceTo(camera.position); if(d<2 && d<nd){ nd=d; near=p; } }
  if(!near) return;
  const t = near.userData.type; try{ scene.remove(near); }catch(e){} pickups = pickups.filter(x=>x!==near);
  if(t==='ammo'){ for(const k in weaponState) weaponState[k].reserve += 12 + Math.floor(Math.random()*24); showToast('+ Ammo'); sfx(920,0.06,'triangle',0.12); }
  else if(t==='medkit'){ playerHealth = Math.min(100, playerHealth+45); healthVal.textContent=Math.floor(playerHealth); showToast('+40 HP'); sfx(720,0.08,'sine',0.12); }
  else if(t==='antiviral'){ infection = Math.max(0, infection - 42); infectVal.textContent = Math.floor(infection) + '%'; showToast('Antiviral used'); sfx(760,0.08,'triangle',0.12); }
  else if(t==='loot'){ score += 20 + Math.floor(Math.random()*40); scoreVal.textContent = score; showToast('Loot found'); sfx(820,0.08,'sine',0.12); }
  updateWeaponUI();
}

/* ==== weapons behavior ==== */
function changeWeapon(k){ if(!weapons[k]) return; currentWeapon=k; updateWeaponUI(); }
function updateWeaponUI(){ const st = weaponState[currentWeapon]; document.getElementById('weaponName').textContent = weapons[currentWeapon].name; document.getElementById('ammoVal').textContent = st.ammo; document.getElementById('reserveVal').textContent = st.reserve; document.getElementById('invList').textContent = `Grenades:${(inventory.grenades||0)} Medkits:${inventory.medkits} Armor:${inventory.armorPlates}`; batteryVal.textContent = Math.max(0,Math.floor(batteryCharge)) + '%'; infectVal.textContent = Math.floor(infection) + '%'; flashVal.textContent = flashlightOn?'ON':'OFF'; }
function attemptShoot(){ const w = weapons[currentWeapon], st = weaponState[currentWeapon]; if(st.reloading) return; const now = performance.now(); if(now - st.lastShot < w.rate) return; if(st.ammo <= 0){ reloadWeapon(); return; } st.lastShot = now; st.ammo--; updateWeaponUI(); ensureAudio();
  if(w.melee){ sfx(360,0.08,'square',0.12); const origin = new THREE.Vector3(); camera.getWorldPosition(origin); const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); meleeHit(origin,dir,2.4,w.damage); }
  else if(currentWeapon==='shotgun'){ for(let i=0;i<(w.pellets||8);i++){ const origin = new THREE.Vector3(); camera.getWorldPosition(origin); const spread = new THREE.Vector3((Math.random()-0.5)*0.16,(Math.random()-0.5)*0.12,(Math.random()-0.5)*0.16); const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize().add(spread).normalize(); rayDamage(origin,dir,w.damage+Math.floor(Math.random()*5),10); } sfx(680+Math.random()*120,0.06,'sawtooth',0.16); }
  else if(currentWeapon==='sniper'){ const origin=new THREE.Vector3(); camera.getWorldPosition(origin); const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); rayDamage(origin,dir,w.damage,800); sfx(1100,0.08,'triangle',0.2); }
  else if(currentWeapon==='flamethrower'){ flameBurst(); }
  else { const origin=new THREE.Vector3(); camera.getWorldPosition(origin); const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); rayDamage(origin,dir,w.damage,240); sfx(920+Math.random()*200,0.05,'sine',0.12); }
}
function reloadWeapon(){ const st = weaponState[currentWeapon], w = weapons[currentWeapon]; if(st.reloading) return; if(st.ammo >= w.mag) return; if(st.reserve <= 0) return; st.reloading = true; setTimeout(()=>{ const need = w.mag - st.ammo; const take = Math.min(need, st.reserve); st.reserve -= take; st.ammo += take; st.reloading=false; updateWeaponUI(); sfx(420,0.08,'sine',0.12); }, w.reload); }
function meleeHit(origin,dir,range,dmg){ for(const z of zombies.slice()){ const v = z.position.clone().sub(origin); const d = Math.hypot(v.x,v.z); if(d < range){ const angle = dir.angleTo(v.normalize()); if(angle < Math.PI*0.45){ z.userData.hp -= dmg; spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.6,0)),0x8b1b1b,10,3.4); if(z.userData.hp<=0) killZombie(z); } } } }
function rayDamage(origin,dir,damage,maxRange){ const ray = new THREE.Raycaster(origin,dir,0,maxRange); let hit=null, hitDist=Infinity; for(const z of zombies){ const box = new THREE.Box3().setFromObject(z); if(ray.ray.intersectsBox(box)){ const pt = ray.ray.intersectBox(box,new THREE.Vector3()); const d = origin.distanceTo(pt); if(d < hitDist){ hitDist=d; hit={z,pt}; } } } if(hit){ const {z,pt} = hit; const falloff = Math.max(0.4,1 - hitDist/maxRange); const applied = Math.max(1, Math.round(damage*falloff)); z.userData.hp -= applied; spawnParticles(pt,0x8b1b1b, 6 + Math.floor(Math.random()*12), 3.4); if(z.userData.hp <= 0) killZombie(z); } else spawnParticles(origin.clone().add(dir.clone().multiplyScalar(maxRange*0.9)),0xffaa66,3,1.8); }

/* flamethrower */
let flameActive=false;
function flameBurst(){ flameActive=true; const origin=new THREE.Vector3(); camera.getWorldPosition(origin); const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); for(let i=0;i<8;i++){ const spread=dir.clone().add(new THREE.Vector3((Math.random()-0.5)*0.35,(Math.random()-0.2)*0.2,(Math.random()-0.5)*0.35)).normalize(); const pos=origin.clone().add(spread.clone().multiplyScalar(1.2+Math.random()*2.8)); spawnParticles(pos,0xff7a2b,6,3.6); } for(const z of zombies.slice()){ const d = z.position.distanceTo(origin); if(d<6){ z.userData.hp -= 0.8 + Math.random()*1.6; if(z.userData.hp<=0) killZombie(z); } } }

/* ==== zombie spawning & AI variants ==== */
function spawnZombie(type=null){
  const r=Math.random(); let t=type;
  if(!t){ if(r<0.06) t='brute'; else if(r<0.26) t='runner'; else if(r<0.4) t='spitter'; else if(r<0.52) t='crawler'; else if(r<0.58) t='bloater'; else t='walker'; }
  const cmap = {walker:0x4aa24a, runner:0x8f2b2b, spitter:0x28a28a, crawler:0x2e2e2e, brute:0x6b6b7d, bloater:0x6b2b2b};
  const mat = new THREE.MeshStandardMaterial({color:cmap[t]||0x4aa24a, roughness:0.95});
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.05,0.5), mat); torso.castShadow=true;
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.45,0.45,0.45), new THREE.MeshStandardMaterial({color:0x4a5a33})); head.position.set(0,0.9,0);
  const g = new THREE.Group(); g.add(torso); g.add(head);
  const angle = Math.random()*Math.PI*2, radius = 14 + Math.random()*36;
  g.position.set(camera.position.x + Math.cos(angle)*radius, 0.6, camera.position.z + Math.sin(angle)*radius);
  if(t==='brute') g.userData = {type:'brute', hp:28 + wave*6, speed:0.22, attack:18};
  else if(t==='runner') g.userData = {type:'runner', hp:6 + Math.floor(wave*0.5), speed:1.6, attack:6};
  else if(t==='spitter') g.userData = {type:'spitter', hp:7 + Math.floor(wave*0.4), speed:0.42, attack:6, spitCooldown:2000};
  else if(t==='crawler') g.userData = {type:'crawler', hp:4 + Math.floor(wave*0.3), speed:0.38, attack:5, stealth:true};
  else if(t==='bloater') g.userData = {type:'bloater', hp:40 + wave*6, speed:0.18, attack:22, explode:true};
  else g.userData = {type:'walker', hp:4 + Math.floor(wave*0.3), speed:0.48, attack:6};
  scene.add(g); zombies.push(g);
  addMinimapMarkerFor(g,'zombie');
  return g;
}
function killZombie(z){
  if(!z) return;
  spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.6,0)),0x8b1b1b,26,5.2);
  try{ scene.remove(z); }catch(e){} const idx = zombies.indexOf(z); if(idx>=0) zombies.splice(idx,1);
  removeMinimapMarkerFor(z);
  score += (z.userData.type==='brute'?60:14) + Math.floor(Math.random()*18); scoreVal.textContent = score;
  if(Math.random() < 0.45) spawnPickup(z.position.clone(), Math.random()<0.5?'ammo':'loot');
  // bloater death explosion
  if(z.userData.type === 'bloater'){ spawnExplosion(z.position, 42); }
  checkWaveClear();
}

/* spitter acid projectile */
function spitAcid(from,target){
  const dir = target.clone().sub(from).normalize();
  const proj = {pos: from.clone().add(new THREE.Vector3(0,1,0)), vel: dir.clone().multiplyScalar(5.6), life:0, max:2.4};
  const interval = setInterval(()=>{ proj.pos.add(proj.vel.clone().multiplyScalar(0.06)); spawnParticles(proj.pos,0x33bb66,2,1.2); if(proj.pos.distanceTo(camera.position) < 1.2){ playerHit(10); clearInterval(interval); } proj.life += 0.06; if(proj.life > proj.max) clearInterval(interval); }, 60);
}

/* explosion */
function spawnExplosion(pos,damage){
  spawnParticles(pos,0xff7a2b,48,6.6); sfx(80,0.6,'sawtooth',0.18);
  for(const z of zombies.slice()){ const d = z.position.distanceTo(pos); if(d < 6.2){ z.userData.hp -= Math.max(6, Math.round(damage*(1 - d/6.2))); if(z.userData.hp <= 0) killZombie(z); } }
}

/* ==== waves and mission progression ==== */
let zombiesThisWave=0, killsThisWave=0;
function spawnWave(count){
  zombiesThisWave = count; killsThisWave = 0; zLeft.textContent = zombiesThisWave - killsThisWave;
  for(let i=0;i<count;i++) setTimeout(()=> spawnZombie(), i*120 + Math.random()*420);
}
function startWave(){ wave++; waveVal.textContent = wave; const base = 6 + Math.floor(wave*2.4); spawnWave(Math.min(settings.maxZombies, base + Math.floor(wave*1.6))); sfx(720,0.12,'sine',0.12); }
function checkWaveClear(){ const left = Math.max(0, zombiesThisWave - killsThisWave); zLeft.textContent = left; if(left === 0 && gameStarted){ intermissionEnd = performance.now() + 4200; for(let i=0;i<3;i++) spawnPickup(camera.position.clone().add(new THREE.Vector3((Math.random()-0.5)*5,0,(Math.random()-0.5)*5)), Math.random()<0.6?'ammo':'medkit'); showWaveBanner('Wave Cleared'); autoSave(); // mission checks (simple)
    if(currentChapter().id === 'prologue' && !chapterState.prologueEscaped){ chapterState.prologueEscaped = true; missionComplete(); }
    if(currentChapter().id === 'outskirts' && !chapterState.outskirtsFoundOutpost){ chapterState.outskirtsFoundOutpost = true; missionComplete(); }
  } }
function showWaveBanner(txt){ const b = document.createElement('div'); b.style.position='fixed'; b.style.left='50%'; b.style.top='10%'; b.style.transform='translateX(-50%)'; b.style.padding='8px 14px'; b.style.background='rgba(0,0,0,0.6)'; b.style.color='#fff'; b.style.fontWeight='800'; b.style.zIndex=999; b.style.borderRadius='8px'; b.textContent = txt; document.body.appendChild(b); setTimeout(()=> b.style.opacity='0',4200); setTimeout(()=> b.remove(),4600); }

/* ==== AI update (per-frame) ==== */
function computeSeparation(z){ const sep = new THREE.Vector3(); let count=0; for(const o of zombies){ if(o===z) continue; const d = z.position.distanceTo(o.position); if(d < 2.2){ const diff = z.position.clone().sub(o.position).normalize().divideScalar(d); sep.add(diff); count++; } } if(count>0) sep.divideScalar(count); return sep; }
function playerHit(dmg,infectAdd=0){
  let mitigated = dmg; if(inventory.armorPlates && inventory.armorPlates>0) mitigated = dmg * 0.6;
  playerHealth -= mitigated; healthVal.textContent = Math.max(0, Math.floor(playerHealth));
  if(infectAdd) { infection = Math.min(100, infection + infectAdd); infectVal.textContent = Math.floor(infection) + '%'; }
  sfx(160,0.12,'sawtooth',0.12);
  const v = document.createElement('div'); v.style.position='fixed'; v.style.inset='0'; v.style.zIndex=998; v.style.pointerEvents='none'; v.style.background='radial-gradient(circle at 50% 20%, rgba(160,0,0,0.12), rgba(0,0,0,0))'; document.body.appendChild(v); setTimeout(()=> v.remove(), 160);
  if(playerHealth <= 0 || infection >= 100) chapterFailed();
}

/* ==== controls & flashlight ==== */
let keys = {}, controlsEnabled=false, mouseHeld=false;
let sensitivity = 0.0028;
function initControls(){
  window.addEventListener('keydown', e=>{ if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return; const k=e.key.toLowerCase();
    if(k==='w') keys.w=1; if(k==='s') keys.s=1; if(k==='a') keys.a=1; if(k==='d') keys.d=1; if(e.key==='Shift') keys.shift=1;
    if(k==='e'){ tryPickup(); tryToggleObjective(); }
    if(k==='r') reloadWeapon();
    if(k==='1') changeWeapon('pistol'); if(k==='2') changeWeapon('shotgun'); if(k==='3') changeWeapon('smg'); if(k==='4') changeWeapon('sniper'); if(k==='5') changeWeapon('flamethrower'); if(k==='6') changeWeapon('bat');
    if(k==='g'){ if(inventory.grenades && inventory.grenades>0){ inventory.grenades--; const origin=new THREE.Vector3(); camera.getWorldPosition(origin); const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); const pt = origin.add(dir.multiplyScalar(6)); spawnExplosion(pt,28); showToast('-1 Grenade'); } else showToast('No grenades'); }
    if(k==='f'){ toggleFlashlight(); }
    if(k==='v'){ const origin=new THREE.Vector3(); camera.getWorldPosition(origin); const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); meleeHit(origin,dir,2.6,14); }
    if(k==='t'){ if(activeTrader) openTrader(activeTrader); }
    if(e.key === 'Escape'){ togglePause(true); }
    if(k==='m'){ toggleMinimapLarge(); }
    if(k==='+'||k==='='){ mini.settings.zoom = Math.max(0.4, mini.settings.zoom - 0.15); }
    if(k==='-'){ mini.settings.zoom = Math.min(2.2, mini.settings.zoom + 0.15); }
  });
  window.addEventListener('keyup', e=>{ const k=e.key.toLowerCase(); if(k==='w') keys.w=0; if(k==='s') keys.s=0; if(k==='a') keys.a=0; if(k==='d') keys.d=0; if(e.key==='Shift') keys.shift=0; });
  window.addEventListener('mousemove', e=>{ if(!controlsEnabled) return; const mvX=e.movementX||0, mvY=e.movementY||0; camera.rotation.order='YXZ'; camera.rotation.y -= mvX * sensitivity; camera.rotation.x -= mvY * sensitivity; camera.rotation.x = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, camera.rotation.x)); });
  window.addEventListener('mousedown', e=>{ if(!gameStarted || paused) return; if(e.button===0){ mouseHeld=true; attemptShoot(); }});
  window.addEventListener('mouseup', ()=>{ mouseHeld=false; flameActive=false; });
  document.addEventListener('pointerlockchange', ()=>{ controlsEnabled = (document.pointerLockElement === canvas); });
  window.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('click', ()=>{ try{ canvas.requestPointerLock(); }catch(e){} });
}

/* flashlight */
function ensureFlashlight(){ if(!flashlight){ flashlight = new THREE.SpotLight(0xffffff,0.0,44,Math.PI*0.12,0.6,1); flashlight.castShadow = settings.shadows; flashlight.shadow.mapSize.width = 1024; flashlight.shadow.mapSize.height = 1024; scene.add(flashlight); flashlight.target = new THREE.Object3D(); scene.add(flashlight.target); } }
let flickerTimer = 0; let flashlightOn = false;
function toggleFlashlight(){ ensureFlashlight(); if(batteryCharge <= 0 && !flashlightOn){ showToast('Battery dead'); return; } flashlightOn = !flashlightOn; flashlight.visible = flashlightOn; flashVal.textContent = flashlightOn ? 'ON' : 'OFF'; sfx(620,0.06,'sine',0.08); }

/* ==== mission/campaign flow ==== */
function currentChapter(){ return CAMPAIGN[currentChapterIndex]; }
function startChapter(index){
  currentChapterIndex = index; chapterState = {}; selectedMap = maps.find(m=>m.id === CAMPAIGN[index].map); initScene(); initParticlePools(); camera.position.set(0,1.6,2); hud.style.display='block'; document.getElementById('crosshair').style.display='block'; document.getElementById('weaponUI').style.display='block';
  missionBox.style.display='block'; missionBox.innerHTML = `<strong>${CAMPAIGN[index].name}</strong><div style="color:var(--muted);margin-top:6px">${CAMPAIGN[index].objective}</div>`;
  wave = 0; waveVal.textContent = wave;
  // chapter-specific start
  if(CAMPAIGN[index].id==='prologue'){ startWave(); showDialog('You awake in Z-13 Quarantine. Escape the avenue.'); }
  if(CAMPAIGN[index].id==='outskirts'){ startWave(); showDialog('Search the outskirts for the survivor outpost.'); }
  if(CAMPAIGN[index].id==='factory'){ showDialog('Restore the generator in the factory.'); startWave(); }
  if(CAMPAIGN[index].id==='facility'){ showDialog('Retrieve the core and upload the cure.'); startWave(); }
  updateWeaponUI();
  running=true; gameStarted=true; paused=false; lastFrame=performance.now(); lastSpawn=performance.now(); loop();
}
function missionComplete(){ showDialog('Objective complete. Preparing transit...'); setTimeout(()=>{ currentChapterIndex++; if(currentChapterIndex >= CAMPAIGN.length){ victoryCampaign(); } else { fadeOutIn(()=> startChapter(currentChapterIndex)); } }, 2200); }
function chapterFailed(){ running=false; gameOver.style.display='flex'; document.getElementById('finalScore').textContent = 'Score: ' + score; }
function restartChapter(){ gameOver.style.display='none'; fadeOutIn(()=> startChapter(currentChapterIndex)); }
function victoryCampaign(){ running=false; showDialog('You uploaded the cure. Campaign complete.'); }

/* toggles for objectives (generator console / core console) */
function tryToggleObjective(){ for(const p of props){ if(p.type === 'generator' && p.pos && p.pos.distanceTo(camera.position) < 2.2){ if(!p.active){ p.active = true; p.mesh.material.color.set(0x22ff66); showToast('Generator rebooted'); chapterState.factoryGeneratorRepaired = true; missionComplete(); } else showToast('Generator already running'); return; } if(p.type === 'core' && p.pos && p.pos.distanceTo(camera.position) < 2.2){ showToast('Core acquired'); chapterState.corePicked = true; return; } if(p.type === 'console' && p.pos && p.pos.distanceTo(camera.position) < 2.2){ if(chapterState.corePicked){ showToast('Uploading cure...'); showDialog('Uploading...'); setTimeout(()=>{ missionComplete(); }, 2400); } else showToast('No core'); return; } } }

/* ==== saving system ==== */
function autoSave(){ try{ const payload = {chapter: currentChapterIndex, player:{hp:playerHealth, score:score, battery:batteryCharge, infection:infection, pos:{x:camera.position.x,y:camera.position.y,z:camera.position.z}}, collectedLore:collectedLore}; localStorage.setItem('z13_save_expanded', JSON.stringify(payload)); showToast('Auto-saved'); }catch(e){} }
function loadSave(){ try{ const raw = localStorage.getItem('z13_save_expanded'); if(!raw) return false; const d = JSON.parse(raw); if(typeof d.chapter === 'number') startChapter(d.chapter); if(d.player && camera) camera.position.set(d.player.pos.x||0,d.player.pos.y||1.6,d.player.pos.z||0); if(d.collectedLore) collectedLore = d.collectedLore; return true; }catch(e){ return false; } }

/* ==== UI helpers ==== */
function showToast(txt){ const t=document.createElement('div'); t.className='save-toast'; t.textContent = txt; document.body.appendChild(t); setTimeout(()=> t.style.opacity='0',900); setTimeout(()=> t.remove(),1400); }
function showDialog(txt,duration=3200){ dialogBox.style.display='block'; dialogBox.innerHTML = `<div>${txt}</div>`; setTimeout(()=> dialogBox.style.display='none', duration); }
function fadeOutIn(cb){ const overlay=document.createElement('div'); overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.background='#000'; overlay.style.opacity='0'; overlay.style.zIndex=9999; overlay.style.transition='opacity 600ms'; document.body.appendChild(overlay); setTimeout(()=> overlay.style.opacity='1',10); setTimeout(()=>{ cb(); setTimeout(()=> overlay.style.opacity='0',60); setTimeout(()=> overlay.remove(),700); }, 700); }

/* ==== main update loop ==== */
function loop(){
  if(!running) return;
  const t = performance.now(); const delta = Math.min(0.06, (t - lastFrame)/1000); lastFrame = t;
  if(!paused){
    update(delta);
    renderer.render(scene, camera);
    updateMinimap();
  }
  requestAnimationFrame(loop);
}

/* ==== per-frame update logic ==== */
let thunderTimer = Math.random()*16000 + 6000;
let inventory = {grenades:2, medkits:1, armorPlates:0};
function update(delta){
  // flashlight follow
  if(flashlight){
    const pos = new THREE.Vector3(); camera.getWorldPosition(pos);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
    flashlight.position.copy(pos.clone().add(dir.clone().multiplyScalar(0.18)));
    flashlight.target.position.copy(pos.clone().add(dir.clone().multiplyScalar(9)));
    flashlight.target.updateMatrixWorld();
    if(flashlightOn){ batteryCharge = Math.max(0, batteryCharge - delta * 2.0); if(batteryCharge < 12){ flickerTimer += delta; if(flickerTimer > 0.08){ flashlight.intensity = 0.6 + Math.random()*1.8 * (batteryCharge/12); flickerTimer=0; } } else flashlight.intensity = 2.4 * Math.max(0.18, batteryCharge/100); flashlight.visible = true; } else { flashlight.intensity = 0; flashlight.visible=false; }
    if(batteryCharge <= 0 && flashlightOn){ flashlightOn=false; flashlight.visible=false; flashVal.textContent='OFF'; showToast('Battery depleted'); }
    batteryVal.textContent = Math.max(0,Math.floor(batteryCharge)) + '%';
  }

  // infection effects (if high)
  if(infection > 50){ // low stamina or blur effect placeholder
    // could apply postprocessing; here we use audio cue
    if(Math.random() < 0.002) sfx(160,0.06,'sine',0.08);
  }

  // movement
  const speed = keys.shift ? 5.6 : 3.2;
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
  const mv = new THREE.Vector3();
  if(keys.w) mv.add(forward); if(keys.s) mv.sub(forward); if(keys.a) mv.sub(right); if(keys.d) mv.add(right);
  if(mv.lengthSq()>0){ mv.normalize().multiplyScalar(speed*delta); camera.position.add(mv); camera.position.x = Math.max(-1600, Math.min(1600, camera.position.x)); camera.position.z = Math.max(-1600, Math.min(1600, camera.position.z)); }

  if(mouseHeld && weapons[currentWeapon].auto) attemptShoot();
  if(flameActive && currentWeapon==='flamethrower') flameBurst();

  // spawn periodic ambient zombies
  if(performance.now() - lastSpawn > spawnInterval && !intermissionEnd && !paused && running){
    lastSpawn = performance.now();
    const count = 1 + Math.floor(Math.random()*Math.min(6, 1 + Math.floor(wave/3)));
    for(let i=0;i<count;i++) spawnZombie();
  }

  // survivors wander
  for(const s of survivors){ if(!s.userData._dir || Math.random()<0.002) s.userData._dir = new THREE.Vector3((Math.random()-0.5)*0.6,0,(Math.random()-0.5)*0.6); s.position.add(s.userData._dir.clone().multiplyScalar(delta)); }

  // zombie AI
  for(const z of zombies.slice()){
    const ud = z.userData; ud._t = (ud._t || 0) + delta;
    const toPlayer = new THREE.Vector3().subVectors(camera.position, z.position); const dist = Math.hypot(toPlayer.x,toPlayer.z);
    if(dist < 60 && (!ud._growl || performance.now() - ud._growl > 3200)){ ud._growl = performance.now(); sfx(110+Math.random()*120,0.12,'triangle',0.06); }
    const dir = camera.position.clone().setY(z.position.y).sub(z.position).normalize();
    const sep = computeSeparation(z).multiplyScalar(0.6); dir.add(sep).normalize();
    // detect flashlight -> chance to stun
    const toZombie = z.position.clone().sub(camera.position).normalize();
    const facing = camera.getWorldDirection(new THREE.Vector3()).dot(toZombie);
    if(flashlightOn && facing > 0.86 && dist < 18){ if(Math.random() < 0.06) { z.userData._stunTimer = 1.2; } }
    if(ud._stunTimer && ud._stunTimer > 0){ ud._stunTimer -= delta; continue; }
    if(ud.type === 'runner') z.position.add(dir.multiplyScalar(ud.speed * 1.5 * delta));
    else if(ud.type === 'brute') { if(dist > 2.2) z.position.add(dir.multiplyScalar(ud.speed * delta)); }
    else if(ud.type === 'spitter'){ if(dist > 8 && dist < 24 && (!ud._lastSpit || performance.now() - ud._lastSpit > (1200 + Math.random()*1200))){ ud._lastSpit = performance.now(); spitAcid(z.position.clone(), camera.position.clone()); } z.position.add(dir.multiplyScalar(ud.speed * delta)); }
    else if(ud.type === 'bloater'){ // slow, releases gas (on death)
      z.position.add(dir.multiplyScalar(ud.speed * delta));
    } else z.position.add(dir.multiplyScalar(ud.speed * delta));
    // attack
    if(dist < 1.6 && (!ud._hit || performance.now() - ud._hit > 900)){ ud._hit = performance.now(); playerHit(ud.attack || 6, ud.type==='crawler'?0: (ud.type==='runner'?0: 4)); } // add infection on attack
    z.lookAt(new THREE.Vector3(camera.position.x, z.position.y, camera.position.z));
  }

  // bob pickups
  for(const p of pickups) p.position.y = 0.5 + Math.sin(performance.now()/420 + p.position.x)*0.07;

  updateParticles(delta);
  if(intermissionEnd && performance.now() > intermissionEnd){ intermissionEnd = 0; startWave(); }
  updatePickupPrompt();
}

/* ==== pickup prompt etc ==== */
let activeTrader = null;
function updatePickupPrompt(){
  let near=false;
  for(const p of pickups) if(p.position.distanceTo(camera.position) < 2.0) { near=true; break; }
  for(const l of lorePages) if(l.position.distanceTo(camera.position) < 2.0) { near=true; break; }
  pickupPrompt.style.display = near ? 'block' : 'none';
  let nearSur=false; activeTrader=null;
  for(const s of survivors) if(s.position.distanceTo(camera.position) < 2.4){ nearSur=true; activeTrader=s; break; }
  interactPrompt.style.display = nearSur ? 'block' : 'none';
}

/* ==== minimap module (drop-in) ==== */
let mini = { renderer:null, scene:null, camera:null, dom:null, markers:new Map(), playerMarker:null, settings:{size:220,zoom:1.0,large:false}, colors:{zombie:0xff5a5a,loot:0xffd46b,survivor:0xffffff,objective:0x5aa7ff} };
function initMinimap(){
  minimapContainer.style.display = 'flex';
  minimapLegend.innerHTML = '<span style="color:#6ff">N</span> • <span style="color:#5f5">You</span> <span style="margin-left:8px;color:#f55">Z</span> <span style="margin-left:8px;color:#ffb">Loot</span>';
  const c = minimapCanvas; c.width = mini.settings.size; c.height = mini.settings.size;
  mini.renderer = new THREE.WebGLRenderer({canvas: c, alpha: true, antialias: true});
  mini.renderer.setSize(c.width, c.height); mini.renderer.setPixelRatio(1);
  mini.scene = new THREE.Scene();
  const s = 120; mini.camera = new THREE.OrthographicCamera(-s,s,s,-s,0.1,2000); mini.camera.up.set(0,0,-1);
  const grid = new THREE.GridHelper(2000,40,0x222222,0x111111); grid.rotation.x = Math.PI/2; grid.material.opacity = 0.25; grid.material.transparent = true; mini.scene.add(grid);
  mini.playerMarker = createMiniSprite(0x40ff7a,1.4); mini.scene.add(mini.playerMarker);
  // large canvas
  minimapLarge.width = 420; minimapLarge.height = 420;
  window.addEventListener('keydown', (e)=>{ if(e.key==='m'||e.key==='M'){ toggleMinimapLarge(); } if(e.key==='+'||e.key==='='){ mini.settings.zoom = Math.max(0.4, mini.settings.zoom - 0.15); } if(e.key==='-'){ mini.settings.zoom = Math.min(2.2, mini.settings.zoom + 0.15); }});
}
function createMiniSprite(hex,scale=1.0){ const mat = new THREE.SpriteMaterial({color:hex,transparent:true,opacity:1.0}); const s = new THREE.Sprite(mat); s.scale.set(6*scale,6*scale,1); return s; }
function addMinimapMarkerFor(worldObject,type='zombie'){ if(!worldObject || !worldObject.uuid) return; if(mini.markers.has(worldObject.uuid)){ const old = mini.markers.get(worldObject.uuid); mini.scene.remove(old); mini.markers.delete(worldObject.uuid); } const color = mini.colors[type]||0xffff66; const sp = createMiniSprite(color, type==='zombie'?1.0:(type==='loot'?0.9:1.2)); sp.userData = {world:worldObject,type}; mini.markers.set(worldObject.uuid, sp); mini.scene.add(sp); return sp; }
function removeMinimapMarkerFor(worldObject){ if(!worldObject || !worldObject.uuid) return; const m = mini.markers.get(worldObject.uuid); if(m){ try{ mini.scene.remove(m); }catch(e){} mini.markers.delete(worldObject.uuid); } }
function updateMinimap(){
  if(!mini.renderer || !camera) return;
  const px = camera.position.x, pz = camera.position.z;
  const viewSize = 120 * mini.settings.zoom;
  mini.camera.left = -viewSize; mini.camera.right = viewSize; mini.camera.top = viewSize; mini.camera.bottom = -viewSize;
  mini.camera.position.set(px, 180, pz); mini.camera.updateProjectionMatrix();
  mini.playerMarker.position.set(px,1,pz); const yaw = camera.rotation.y || 0; mini.playerMarker.material.rotation = -yaw;
  for(const [id, sprite] of mini.markers){ const w = sprite.userData.world; if(!w) continue; let worldPos = new THREE.Vector3(); if(w.position) worldPos.copy(w.position); else if(w.userData && w.userData.pos) worldPos.copy(w.userData.pos); else continue; sprite.position.set(worldPos.x,1.0,worldPos.z); const d = Math.hypot(worldPos.x - px, worldPos.z - pz); sprite.material.opacity = d > 120 * mini.settings.zoom ? 0.0 : 1.0; }
  mini.renderer.render(mini.scene, mini.camera);
  if(mini.settings.large){ if(!mini.largeRenderer){ mini.largeRenderer = new THREE.WebGLRenderer({canvas: minimapLarge, alpha:true, antialias:true}); mini.largeRenderer.setSize(minimapLarge.width, minimapLarge.height); mini.largeRenderer.setPixelRatio(1); } mini.largeRenderer.render(mini.scene, mini.camera); }
}
function toggleMinimapLarge(){ mini.settings.large = !mini.settings.large; minimapLarge.style.display = mini.settings.large ? 'block' : 'none'; minimapContainer.style.display = mini.settings.large ? 'none' : 'flex'; }

/* ==== integration notes: ensure when spawning objects call addMinimapMarkerFor(...) and removeMinimapMarkerFor(...) on removal ==== */

/* ==== UI wiring ==== */
startBtn.addEventListener('click', ()=>{ menu.style.display='none'; startChapter(0); initControls(); ensureAudio(); initMinimap(); });
quickBtn.addEventListener('click', ()=>{ menu.style.display='none'; selectedMap = maps[0]; initScene(); initParticlePools(); initControls(); ensureAudio(); initMinimap(); hud.style.display='block'; document.getElementById('weaponUI').style.display='block'; document.getElementById('crosshair').style.display='block'; running=true; gameStarted=true; lastFrame=performance.now(); startWave(); loop(); });
howBtn.addEventListener('click', ()=>{ menu.style.display='none'; howto.style.display='flex'; });
howBack.addEventListener('click', ()=>{ howto.style.display='none'; menu.style.display='flex'; });
resumeBtn.addEventListener('click', ()=> togglePause(false));
saveBtn.addEventListener('click', ()=>{ autoSave(); showToast('Saved'); });
restartBtn.addEventListener('click', ()=>{ fadeOutIn(()=> startChapter(currentChapterIndex)); });
menuBtn.addEventListener('click', ()=>{ running=false; gameStarted=false; menu.style.display='flex'; hud.style.display='none'; document.getElementById('weaponUI').style.display='none'; document.getElementById('crosshair').style.display='none'; });
retryBtn.addEventListener('click', ()=>{ gameOver.style.display='none'; fadeOutIn(()=> startChapter(currentChapterIndex)); });
menuBtnEnd.addEventListener('click', ()=>{ gameOver.style.display='none'; menu.style.display='flex'; });

// trading
document.getElementById('buyAmmoBtn').addEventListener('click', ()=>{ if(score>=50){ score-=50; weaponState.pistol.reserve += 48; weaponState.smg.reserve += 120; updateWeaponUI(); scoreVal.textContent=score; showToast('Bought ammo'); } else showToast('Not enough score'); });
document.getElementById('buyMedBtn').addEventListener('click', ()=>{ if(score>=80){ score-=80; inventory.medkits++; updateWeaponUI(); scoreVal.textContent=score; showToast('Bought medkit'); } else showToast('Not enough score'); });
document.getElementById('closeTrade').addEventListener('click', ()=>{ tradeBox.style.display='none'; });

/* ==== helper debug ==== */
window._spawnZombie = spawnZombie; window._save = autoSave; window._load = loadSave;

/* ==== final notes ==== */
/* This single-file prototype adds infection, improved AI, furnished factory/facility (procedural), and a minimap.
   Performance tuning: pause -> settings to reduce particles/shadows or lower maxZombies.
   Want further improvements? Tell me:
   - More mutations (e.g., Shrieker, Stalker),
   - Crafting system UI (full),
   - Navmesh pathfinding (three-pathfinding integration),
   - Or replace procedural props with glTF assets (I can export a ZIP).
*/

</script>
</body>
</html>
