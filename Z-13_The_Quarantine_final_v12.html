<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Z-13: The Quarantine — Final (Graveyard)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root { --accent:#c73b3b; --muted:#c7c9cf; --hud-bg: rgba(6,6,8,0.64); }
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui,Segoe UI,Helvetica,Arial}
  canvas{display:block;width:100%;height:100vh}
  /* Loading overlay */
  #loading { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:110; background:linear-gradient(rgba(0,0,0,0.85), rgba(0,0,0,0.95)); color:#fff; flex-direction:column; }
  #progressBar{width:60%;height:14px;border-radius:8px;background:rgba(255,255,255,0.06);overflow:hidden;margin-top:16px}
  #progressFill{height:100%;width:0%;background:linear-gradient(90deg,#c73b3b,#ff7b7b)}
  #loadingText{font-size:16px;margin-top:8px;color:var(--muted)}
  /* Menu */
  #menu { position:fixed; inset:0; z-index:100; display:flex; align-items:center; justify-content:center; background:linear-gradient(rgba(0,0,0,0.55), rgba(0,0,0,0.92)); color:#fff; }
  .menu-card { width:min(920px,94%); padding:26px; border-radius:12px; text-align:center; background:rgba(0,0,0,0.45); box-shadow:0 20px 50px rgba(0,0,0,0.8); }
  h1.title { margin:0; font-size:44px; letter-spacing:1.6px; color:#ffefe6; text-shadow:0 8px 24px rgba(0,0,0,0.8); }
  .subtitle{ color:var(--muted); margin-top:6px; font-size:14px; }
  .btn{ background:var(--accent); color:#fff; border:none; padding:10px 16px; border-radius:8px; cursor:pointer; font-weight:700; margin:6px; }
  .btn.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; }
  .credits{ margin-top:12px; font-size:13px; color:var(--muted); }
  /* HUD */
  #hud{ position:fixed; left:12px; top:12px; z-index:95; color:#fff; background:var(--hud-bg); padding:10px; border-radius:10px; min-width:260px; font-weight:700}
  #weaponUI{ position:fixed; right:12px; bottom:12px; z-index:95; color:#fff; background:var(--hud-bg); padding:10px; border-radius:10px; min-width:220px }
  #crosshair{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:92; pointer-events:none; font-size:20px; color:rgba(255,255,255,0.9) }
  #gameOver{ display:none; position:fixed; inset:0; z-index:120; background:rgba(0,0,0,0.95); display:flex; align-items:center; justify-content:center; color:#fff }
  .game-over-card{ background:rgba(0,0,0,0.6); padding:24px; border-radius:12px; text-align:center; }
  .pickup{ position:fixed; left:50%; transform:translateX(-50%); bottom:110px; z-index:97; color:#fff; pointer-events:none; font-weight:800; padding:6px 10px; border-radius:8px; background:rgba(0,0,0,0.6) }
  #bloodOverlay{ position:fixed; inset:0; pointer-events:none; z-index:98; opacity:0; background:radial-gradient(circle at 50% 20%, rgba(120,0,0,0.22), rgba(0,0,0,0) 35%); transition:opacity .12s }
  #fps{ position:fixed; right:8px; top:8px; color:#bbb; z-index:130; font-size:12px; }
  /* small note when audio blocked */
  #note { position:fixed; left:12px; bottom:12px; z-index:130; color:#ddd; font-size:13px; background:rgba(0,0,0,0.45); padding:6px 10px; border-radius:8px; }
</style>
</head>
<body>
  <div id="loading" aria-hidden="false">
    <div style="font-size:22px;font-weight:700">LOADING Z-13: THE QUARANTINE...</div>
    <div id="progressBar"><div id="progressFill"></div></div>
    <div id="loadingText">Preparing the graveyard...</div>
  </div>

  <div id="menu" aria-hidden="true" style="display:none">
    <div class="menu-card">
      <h1 class="title">Z-13: The Quarantine</h1>
      <div class="subtitle">No one left the walls... until you did.</div>
      <div style="margin-top:10px;color:var(--muted)">Year 2139 — Sector Z-13 sealed after outbreak. Survive. Restore the generator. Escape.</div>
      <div style="margin-top:14px;">
        <button id="startBtn" class="btn">Start Game</button>
        <button id="settingsBtn" class="btn ghost">Settings</button>
        <button id="creditsBtn" class="btn ghost">Credits</button>
        <button id="quitBtn" class="btn ghost">Quit</button>
      </div>
      <div class="credits">Developed by Six</div>
    </div>
  </div>

  <div id="hud" aria-live="polite" style="display:none">
    <div style="display:flex;justify-content:space-between"><div>Health</div><div id="healthVal">100</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Score</div><div id="scoreVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Wave</div><div id="waveVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>High</div><div id="highVal">0</div></div>
  </div>

  <div id="weaponUI" style="display:none">
    <div id="weaponName">Pistol</div>
    <div style="font-size:13px;margin-top:6px">Ammo: <span id="ammoVal">12</span> / <span id="reserveVal">36</span></div>
    <div id="reloadText" style="display:none;margin-top:6px;font-size:13px;color:var(--muted)">Reloading...</div>
  </div>

  <div id="crosshair" style="display:none">+</div>
  <div id="pickupText" class="pickup" style="display:none"></div>
  <div id="bloodOverlay"></div>

  <div id="gameOver">
    <div class="game-over-card">
      <h1 id="goTitle">You Died</h1>
      <div id="goScore" style="margin-top:8px">Score: 0</div>
      <div style="margin-top:12px"><button id="retryBtn" class="btn">Retry</button></div>
    </div>
  </div>

  <div id="fps" style="display:none"></div>
  <div id="note" style="display:none">Audio may be blocked — click Start to enable sound.</div>

  <canvas id="gameCanvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* Z-13: The Quarantine — Final single-file (Graveyard)
   - Proper loading screen + progress updates
   - Scene uses Three.js primitives (no large assets)
   - All systems initialized after loading
   - Weapons 1..6 + Grenade wired; independent states
   - Zombies spawn closer (40..150) with colored types
   - Procedural WebAudio for ambient and sfx
   - Fixed "You Died" start bug: game only starts after pressing Start
*/

/* ----------------- UI elements ----------------- */
const loading = document.getElementById('loading');
const progressFill = document.getElementById('progressFill');
const loadingText = document.getElementById('loadingText');
const menu = document.getElementById('menu');
const startBtn = document.getElementById('startBtn');
const settingsBtn = document.getElementById('settingsBtn');
const creditsBtn = document.getElementById('creditsBtn');
const quitBtn = document.getElementById('quitBtn');
const hud = document.getElementById('hud');
const hudHealth = document.getElementById('healthVal');
const hudScore = document.getElementById('scoreVal');
const hudWave = document.getElementById('waveVal');
const highEl = document.getElementById('highVal');
const weaponUI = document.getElementById('weaponUI');
const weaponNameEl = document.getElementById('weaponName');
const ammoEl = document.getElementById('ammoVal');
const reserveEl = document.getElementById('reserveVal');
const reloadText = document.getElementById('reloadText');
const crosshair = document.getElementById('crosshair');
const pickupText = document.getElementById('pickupText');
const bloodOverlay = document.getElementById('bloodOverlay');
const gameOverDiv = document.getElementById('gameOver');
const retryBtn = document.getElementById('retryBtn');
const fpsEl = document.getElementById('fps');
const note = document.getElementById('note');

/* ----------------- core state ----------------- */
let scene, camera, renderer, clock;
let initialized = false;
let running = false;
let playerHealth = 100;
let score = 0, wave = 0;
let zombies = [], pickups = [], props = [];
const worldSize = 120;
let lastSpawn = 0, spawnInterval = 1500, lastWaveTime = 0;
let lastFrame = performance.now();

/* Audio */
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx) {
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); console.log('AudioContext created'); }
    catch(e){ audioCtx = null; console.warn('AudioContext unavailable:', e); note.style.display = 'block'; }
  }
}

/* procedural sfx */
function sfx(freq=440,dur=0.06,type='sine',vol=0.12){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  o.connect(g); g.connect(audioCtx.destination);
  g.gain.value = 0.0001;
  g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
  o.start(); o.stop(audioCtx.currentTime + dur);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
}

/* menu ambience (simple) */
let menuAmb = null;
function startMenuAmbience(){
  if(!audioCtx) return;
  stopMenuAmbience();
  const o1 = audioCtx.createOscillator(), o2 = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o1.type = 'sine'; o2.type = 'sine';
  o1.frequency.value = 38; o2.frequency.value = 56;
  o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
  g.gain.value = 0.0001; g.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 0.2);
  o1.start(); o2.start();
  menuAmb = {o1,o2,g};
  setInterval(()=> { if(!menuAmb) return; try{ menuAmb.o1.frequency.setTargetAtTime(30 + Math.random()*40, audioCtx.currentTime, 1.5); menuAmb.o2.frequency.setTargetAtTime(45 + Math.random()*45, audioCtx.currentTime, 1.5); }catch(e){} }, 4200);
}
function stopMenuAmbience(){ if(!menuAmb) return; try{ menuAmb.o1.stop(); menuAmb.o2.stop(); }catch(e){} menuAmb = null; }

/* ----------------- weapons ----------------- */
const weapons = {
  pistol: {name:'Pistol', mag:12, reserve:96, fireRate:260, damage:3, automatic:false, reloadTime:900, hipSpread:0.06, adsSpread:0.01},
  shotgun: {name:'Shotgun', mag:6, reserve:48, fireRate:680, damage:6, pellets:7, spread:0.18, automatic:false, reloadTime:1200, hipSpread:0.18, adsSpread:0.06},
  smg: {name:'SMG', mag:40, reserve:200, fireRate:80, damage:1, automatic:true, reloadTime:1200, hipSpread:0.07, adsSpread:0.02},
  rifle: {name:'Rifle', mag:30, reserve:150, fireRate:95, damage:1.6, automatic:true, reloadTime:1400, hipSpread:0.045, adsSpread:0.005},
  flamethrower: {name:'Flamethrower', mag:120, reserve:400, fireRate:40, damage:0.18, automatic:true, reloadTime:2000, range:6},
  sniper: {name:'Sniper', mag:5, reserve:25, fireRate:900, damage:28, automatic:false, reloadTime:2200, hipSpread:0.002, adsSpread:0.0008},
  grenade: {name:'Grenade', mag:1, reserve:3, fireRate:800, damage:14, automatic:false, reloadTime:800}
};
let currentWeaponKey = 'pistol';
let weaponState = {};
for(const k in weapons) weaponState[k] = {ammo:weapons[k].mag, reserve:weapons[k].reserve, reloading:false, lastShot:0};
let aiming = false, mouseHeld = false, meleeCooldown = 0;

/* ----------------- three init & loading pipeline ----------------- */
const loadSteps = [
  {name:'three', fn: loadThree},
  {name:'scene', fn: buildScene},
  {name:'pools', fn: createParticlePools},
  {name:'ui', fn: setupUI},
  {name:'finalize', fn: finalize},
];
let loadIndex = 0;

function updateProgress(){
  const pct = Math.round((loadIndex / loadSteps.length) * 100);
  progressFill.style.width = pct + '%';
  loadingText.textContent = `${loadSteps[loadIndex-1]?.name || 'starting'}... (${pct}%)`;
}

/* called by window.onload */
window.onload = async function(){
  // step through loadSteps sequentially
  for(loadIndex = 1; loadIndex <= loadSteps.length; loadIndex++){
    try{
      updateProgress();
      await loadSteps[loadIndex-1].fn();
      console.log(`✅ Loaded: ${loadSteps[loadIndex-1].name}`);
    } catch(e){
      console.error('Load error at', loadSteps[loadIndex-1].name, e);
      loadingText.textContent = 'Error loading. Check console.';
      throw e;
    }
  }
  // done loading
  progressFill.style.width = '100%';
  loadingText.textContent = 'Ready';
  setTimeout(()=> {
    loading.style.display = 'none';
    menu.style.display = 'flex';
    menu.style.opacity = '1';
    menu.setAttribute('aria-hidden','false');
    hud.style.display = 'block';
    weaponUI.style.display = 'block';
    crosshair.style.display = 'block';
    fpsEl.style.display = 'block';
    // initially hide until Start pressed
    hud.style.display = 'none';
    weaponUI.style.display = 'none';
    crosshair.style.display = 'none';
    fpsEl.style.display = 'none';
    console.log('All systems ready');
    initialized = true;
    // start menu ambience on first user gesture (start button will attempt)
  }, 320);
};

/* ------------- load step functions ------------- */

function loadThree(){ return new Promise((res)=> { console.log('three lib loaded'); setTimeout(res,80); }); }

function buildScene(){
  return new Promise((res) => {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0135);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2500);
    camera.position.set(0,1.6,0);
    renderer = new THREE.WebGLRenderer({canvas: document.getElementById('gameCanvas'), antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio ? devicePixelRatio : 1);
    const hemi = new THREE.HemisphereLight(0x8888aa, 0x222222, 0.9); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xfff0c8, 0.6); dir.position.set(8,12,6); scene.add(dir);

    // ground (dark graveyard)
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(worldSize*2, worldSize*2, 8,8), new THREE.MeshStandardMaterial({color:0x0f0f10}));
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    // props: gravestones & trees
    const tombMat = new THREE.MeshStandardMaterial({color:0x232323});
    for(let i=0;i<120;i++){
      if(Math.random() < 0.55){
        const h = 0.6 + Math.random()*1.6;
        const tomb = new THREE.Mesh(new THREE.BoxGeometry(0.6, h, 0.25), tombMat);
        tomb.position.set((Math.random()-0.5)*worldSize, h/2, (Math.random()-0.5)*worldSize);
        tomb.rotation.y = Math.random()*Math.PI*2;
        scene.add(tomb); props.push(tomb);
      } else {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,1.6,6), new THREE.MeshStandardMaterial({color:0x3b2b1a}));
        const leaves = new THREE.Mesh(new THREE.SphereGeometry(0.8,6,6), new THREE.MeshStandardMaterial({color:0x0f3b13}));
        const x=(Math.random()-0.5)*worldSize,z=(Math.random()-0.5)*worldSize;
        trunk.position.set(x,0.8,z); leaves.position.set(x,1.6,z);
        scene.add(trunk); scene.add(leaves); props.push(trunk); props.push(leaves);
      }
    }

    // simple safehouse box
    const safehouse = new THREE.Mesh(new THREE.BoxGeometry(6,3.5,6), new THREE.MeshStandardMaterial({color:0x101018}));
    safehouse.position.set(12,1.75,-8); scene.add(safehouse); props.push(safehouse);

    // small lights
    for(let i=0;i<10;i++){
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,2,6), new THREE.MeshStandardMaterial({color:0x444444}));
      pole.position.set((Math.random()-0.5)*worldSize,1,(Math.random()-0.5)*worldSize);
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.12,6,6), new THREE.MeshStandardMaterial({emissive:0xfff1c6, emissiveIntensity:0.3, color:0x222222}));
      bulb.position.set(pole.position.x, pole.position.y+1, pole.position.z);
      scene.add(pole); scene.add(bulb);
      setInterval(()=>{ bulb.material.emissiveIntensity = 0.12 + Math.random()*0.5; }, 900 + Math.random()*1600);
    }

    window.addEventListener('resize', onResize);
    clock = new THREE.Clock();

    // small initial camera wiggle so menu background isn't static
    camera.rotation.x = -0.03;
    console.log('Scene built');
    setTimeout(res, 80);
  });
}

function createParticlePools(){
  return new Promise((res) => {
    // create 5 particle pools
    window.particlePools = [];
    for(let i=0;i<5;i++){
      const max = 120;
      const geom = new THREE.BufferGeometry();
      const arr = new Float32Array(max*3);
      geom.setAttribute('position', new THREE.BufferAttribute(arr,3));
      const mat = new THREE.PointsMaterial({size:0.08, transparent:true, opacity:0.9});
      const pts = new THREE.Points(geom, mat);
      pts.userData = {max, alive:[]};
      scene.add(pts);
      window.particlePools.push(pts);
    }
    console.log('Particle pools created');
    setTimeout(res,60);
  });
}

function setupUI(){
  return new Promise((res)=>{
    // populate small demo zombies so menu looks alive
    for(let i=0;i<4;i++) spawnZombie(null, true);
    // show highscore
    const high = parseInt(localStorage.getItem('z13_high') || '0', 10);
    highEl.textContent = high;
    console.log('UI prepared');
    setTimeout(res,60);
  });
}

function finalize(){
  return new Promise((res)=> {
    // attach controls (but they only matter after Start)
    initControls();
    console.log('Finalize complete');
    setTimeout(res,40);
  });
}

/* ------------- particle helpers (used by many functions) ------------- */
function spawnParticles(pos, color=0x8b0000, count=12, speed=3){
  for(const pool of window.particlePools || []){
    const ud = pool.userData;
    if(ud.alive.length + count <= ud.max){
      for(let i=0;i<count;i++){
        ud.alive.push({px:pos.x, py:pos.y, pz:pos.z, vx:(Math.random()-0.5)*speed, vy:Math.random()*speed*0.6 + 0.6, vz:(Math.random()-0.5)*speed, life:0, max:0.4 + Math.random()*0.6});
      }
      pool.material.color.setHex(color);
      pool.geometry.attributes.position.needsUpdate = true;
      return;
    }
  }
}
function updateParticles(delta){
  for(const pool of window.particlePools || []){
    const ud = pool.userData;
    const arr = pool.geometry.attributes.position.array;
    let k = 0;
    for(let i = ud.alive.length - 1; i >= 0; i--){
      const p = ud.alive[i];
      p.life += delta;
      p.vy -= 9.8 * delta * 0.7;
      p.px += p.vx * delta; p.py += p.vy * delta; p.pz += p.vz * delta;
      arr[k*3] = p.px; arr[k*3 + 1] = p.py; arr[k*3 + 2] = p.pz;
      k++;
      if(p.life >= p.max) ud.alive.splice(i,1);
    }
    pool.geometry.attributes.position.needsUpdate = true;
  }
}

/* ------------- zombies (colored types) ------------- */
function spawnZombie(type=null, fromEdge=true){
  // type probabilities for variety
  const t = type || (Math.random() < 0.06 ? 'tank' : (Math.random() < 0.12 ? 'runner' : (Math.random() < 0.07 ? 'exploder' : (Math.random() < 0.08 ? 'crawler' : (Math.random() < 0.06 ? 'dog' : 'walker')))));
  const colorMap = { walker:0x3db34b, runner:0x3b7fd9, crawler:0x8b5a2b, exploder:0xd94b3b, tank:0x7a2bd9, dog:0xf2f2f2 };
  const mat = new THREE.MeshStandardMaterial({color:colorMap[t], roughness:1});
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.15,0.5), mat);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color:0x556633}));
  head.position.set(0,0.95,0);
  const g = new THREE.Group(); g.add(torso); g.add(head);

  // spawn distance: closer (40..150), 10% chance further (150..300)
  const angle = Math.random()*Math.PI*2;
  const r = (Math.random() < 0.10) ? (150 + Math.random()*150) : (40 + Math.random()*110);
  g.position.set(Math.cos(angle)*r, 0.6, Math.sin(angle)*r);

  if(type === 'boss'){
    g.scale.set(2.1,2.1,2.1);
    g.userData = {type:'boss', hp:220 + wave*40, baseSpeed:0.28, state:'chase', stateTime:0, lastDamage:0};
  } else {
    if(t==='walker') g.userData = {type:'walker', hp:3 + Math.floor(Math.random()*2 + wave*0.2), baseSpeed:0.5 + Math.random()*0.2, state:'wander', stateTime:0, targetOffset:new THREE.Vector3()};
    if(t==='runner') g.userData = {type:'runner', hp:2 + Math.floor(wave*0.08), baseSpeed:0.9 + Math.random()*0.8, state:'wander', stateTime:0, targetOffset:new THREE.Vector3()};
    if(t==='crawler') g.userData = {type:'crawler', hp:2 + Math.floor(wave*0.5), baseSpeed:0.45 + Math.random()*0.2, state:'wander', stateTime:0, stealth:true, targetOffset:new THREE.Vector3()};
    if(t==='exploder') g.userData = {type:'exploder', hp:3 + Math.floor(wave*0.4), baseSpeed:0.5 + Math.random()*0.25, explodeRadius:2.3, state:'wander', stateTime:0, targetOffset:new THREE.Vector3()};
    if(t==='tank') g.userData = {type:'tank', hp:8 + Math.floor(wave*1.2), baseSpeed:0.35 + Math.random()*0.15, state:'wander', stateTime:0, targetOffset:new THREE.Vector3()};
    if(t==='dog') g.userData = {type:'dog', hp:2, baseSpeed:1.4 + Math.random()*0.6, state:'wander', stateTime:0, targetOffset:new THREE.Vector3()};
  }

  scene.add(g);
  zombies.push(g);
}

/* ------------- AI helpers ------------- */
function computeSeparation(z){
  const sep = new THREE.Vector3(); let count = 0;
  for(const o of zombies){ if(o===z) continue; const d = z.position.distanceTo(o.position); if(d < 2.0){ const diff = z.position.clone().sub(o.position).normalize().divideScalar(d); sep.add(diff); count++; } }
  if(count>0) sep.divideScalar(count);
  return sep;
}
function inFOV(z, maxAngle=50*Math.PI/180, maxDist=22){
  const toZ = new THREE.Vector3().subVectors(z.position, camera.position); const horiz = Math.hypot(toZ.x,toZ.z);
  if(horiz > maxDist) return false;
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
  const toZNorm = toZ.clone(); toZNorm.y=0; toZNorm.normalize();
  const angle = Math.acos(Math.max(-1, Math.min(1, forward.dot(toZNorm))));
  return angle < maxAngle;
}

/* ------------- shooting & weapons ------------- */
function changeWeapon(key){
  currentWeaponKey = key;
  weaponNameEl.textContent = weapons[key].name;
  updateAmmoUI();
}
function updateAmmoUI(){
  const st = weaponState[currentWeaponKey];
  ammoEl.textContent = Math.round(st.ammo);
  reserveEl.textContent = Math.round(st.reserve);
}
function attemptShoot(){
  const k = currentWeaponKey, w = weapons[k], st = weaponState[k];
  if(st.reloading) return;
  const now = performance.now();
  if(now - st.lastShot < w.fireRate) return;
  if(st.ammo <= 0){ reloadWeapon(); return; }
  st.lastShot = now; st.ammo--; updateAmmoUI();
  ensureAudio(); sfx(900 + Math.random()*300, 0.05, 'square', 0.14);

  const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
  const dirBase = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();

  if(k === 'shotgun'){
    const spread = aiming ? w.adsSpread : w.hipSpread;
    for(let i=0;i<w.pellets;i++){
      const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
      rayDamage(origin, d, w.damage + Math.floor(Math.random()*2), 6.5 + wave*0.1);
    }
  } else if(k === 'flamethrower'){
    const spread = 0.28 * (aiming ? 0.6 : 1);
    for(let i=0;i<8;i++){
      const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
      rayDamage(origin, d, w.damage, w.range);
    }
    spawnFlame(origin, dirBase);
  } else if(k === 'grenade'){
    const pt = origin.clone().add(dirBase.multiplyScalar(6));
    spawnExplosion(pt, w.damage + 6);
  } else {
    const spread = aiming ? (w.adsSpread || w.hipSpread*0.4) : w.hipSpread;
    const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
    rayDamage(origin, d, w.damage, k==='rifle'?90:140);
  }
  flashMuzzle();
}
function rayDamage(origin, dir, damage, maxRange){
  const ray = new THREE.Raycaster(origin, dir, 0, maxRange);
  let hit = null, hitDist = Infinity;
  for(const z of zombies){
    const box = new THREE.Box3().setFromObject(z);
    if(ray.ray.intersectsBox(box)){
      const pt = ray.ray.intersectBox(box, new THREE.Vector3());
      const d = origin.distanceTo(pt);
      if(d < hitDist){ hitDist = d; hit = {z,pt}; }
    }
  }
  if(hit){
    const {z, pt} = hit;
    const falloff = Math.max(0.5, 1 - hitDist/maxRange);
    const applied = Math.max(1, Math.round(damage * falloff));
    z.userData.hp -= applied;
    spawnParticles(pt, 0x8b0000, 12, 3.2);
    sfx(220 + Math.random()*120, 0.05, 'sawtooth', 0.12);
    flashHit();
    if(z.userData.hp <= 0) killZombie(z);
    else { if(z.userData.stealth) z.userData.stealth=false; if(z.userData.type === 'runner' && Math.random() < 0.28){ z.userData.state='dodge'; z.userData.stateTime = 0; } }
  } else {
    const miss = origin.clone().add(dir.clone().multiplyScalar(maxRange*0.9));
    spawnParticles(miss, 0xffaa66, 6, 1.6);
  }
}
function flashMuzzle(){
  const el = document.createElement('div');
  el.style.position='fixed'; el.style.left='50%'; el.style.top='58%';
  el.style.transform='translate(-50%,-50%)'; el.style.width='26px'; el.style.height='14px';
  el.style.borderRadius='8px'; el.style.background='rgba(255,220,160,0.96)'; el.style.zIndex=9999;
  document.body.appendChild(el); setTimeout(()=>el.remove(),36);
}
function flashHit(){ bloodOverlay.style.opacity = 0.85; setTimeout(()=> bloodOverlay.style.opacity = 0, 140); }

/* flame & explosion */
function spawnFlame(origin, dir){
  const base = origin.clone().add(dir.clone().multiplyScalar(0.8));
  spawnParticles(base, 0xff652b, 22, 2.2);
}
function spawnExplosion(pos, damage){
  spawnParticles(pos, 0xff9a2b, 26, 4.6);
  sfx(80, 0.6, 'sawtooth', 0.18);
  for(const z of zombies.slice()){
    const d = z.position.distanceTo(pos);
    if(d < 4.2){ z.userData.hp -= Math.max(2, Math.round(damage * (1 - d/4.2))); if(z.userData.hp <= 0) killZombie(z); }
  }
}

/* ------------- kill / pickups ------------- */
function killZombie(z){
  spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.6,0)), 0x8b0000, 24, 4.2);
  scene.remove(z); zombies = zombies.filter(x => x !== z);
  let gain = 10; if(z.userData.type === 'runner') gain+=3; if(z.userData.type === 'tank') gain+=12; if(z.userData.type === 'boss') gain+=300; if(z.userData.type === 'dog') gain+=6;
  score += gain + Math.floor(Math.random()*8) + wave*2; hudScore.textContent = score; sfx(160, 0.18, 'sine', 0.18);
  if(z.userData.type === 'exploder'){ for(const o of zombies.slice()){ const d = o.position.distanceTo(z.position); if(d < z.userData.explodeRadius){ o.userData.hp -= 2 + Math.floor(Math.random()*3); spawnParticles(o.position, 0xffaa44, 10, 2.6); if(o.userData.hp <= 0) killZombie(o); } } }
  if(Math.random() < 0.28) spawnPickup(z.position.clone());
}
function spawnPickup(pos){
  const type = Math.random() < 0.5 ? 'ammo' : 'health';
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.28,8,8), new THREE.MeshStandardMaterial({color: type==='ammo' ? 0x2b6cff : 0xff6b6b}));
  mesh.position.copy(pos).add(new THREE.Vector3(0,0.6,0));
  mesh.userData = {type};
  scene.add(mesh); pickups.push(mesh);
}
function tryPickup(){
  let nearest=null, nd=Infinity;
  for(const p of pickups){ const d = p.position.distanceTo(camera.position); if(d < 2.0 && d < nd){ nd = d; nearest = p; } }
  if(nearest){
    if(nearest.userData.type === 'health'){ playerHealth = Math.min(100, playerHealth + 50); hudHealth.textContent = playerHealth; showPickupText('+50 HP'); sfx(640,0.08,'triangle',0.12); }
    else { for(const k of Object.keys(weaponState)) weaponState[k].reserve += 8 + Math.floor(Math.random()*12); updateAmmoUI(); showPickupText('Ammo Pack'); sfx(920,0.08,'triangle',0.12); }
    scene.remove(nearest); pickups = pickups.filter(p=>p!==nearest);
  }
}
function showPickupText(txt){ pickupText.textContent = txt; pickupText.style.display = 'block'; setTimeout(()=> pickupText.style.display = 'none', 1200); }

/* reload & melee */
function reloadWeapon(){
  const key = currentWeaponKey; const w = weapons[key]; const st = weaponState[key];
  if(st.reloading) return; if(st.ammo >= w.mag) return; if(st.reserve <= 0) return;
  st.reloading = true; reloadText.style.display = 'block';
  setTimeout(()=> { const need = w.mag - st.ammo; const take = Math.min(need, st.reserve); st.reserve -= take; st.ammo += take; st.reloading = false; reloadText.style.display = 'none'; updateAmmoUI(); sfx(420,0.08,'sine',0.12); }, w.reloadTime);
}
function meleeAttack(){
  if(performance.now() < meleeCooldown) return;
  meleeCooldown = performance.now() + 900;
  sfx(480,0.06,'square',0.13);
  const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  const ray = new THREE.Raycaster(origin, dir, 0, 1.8);
  for(const z of zombies){
    const box = new THREE.Box3().setFromObject(z);
    if(ray.ray.intersectsBox(box)){ z.userData.hp -= 6 + Math.floor(Math.random()*4); spawnParticles(z.position.clone(), 0x8b0000, 10, 3.2); if(z.userData.hp <= 0) killZombie(z); break; }
  }
}

/* ------------- wave & between-wave ------------- */
function startWave(){
  wave++; hudWave.textContent = wave;
  spawnInterval = Math.max(600, 1500 - (wave-1)*70);
  const initial = 3 + Math.floor(1.5 * wave);
  for(let i=0;i<initial;i++){
    if(wave % 6 === 0 && i === 0) spawnZombie('boss', true);
    else spawnZombie(null, true);
  }
}
let pausedBetween = false;
function beginBetweenWave(){ pausedBetween = true; playerHealth = Math.min(100, playerHealth + 14); hudHealth.textContent = playerHealth; setTimeout(()=> { pausedBetween = false; startWave(); }, 2400); }

/* ------------- controls & input ------------- */
let controlsEnabled = false;
const keys = {w:0,a:0,s:0,d:0,shift:0};
function initControls(){
  window.addEventListener('keydown', (e)=>{ if(e.repeat) return; if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return; const k = e.key.toLowerCase(); if(k==='w') keys.w=1; if(k==='a') keys.a=1; if(k==='s') keys.s=1; if(k==='d') keys.d=1; if(e.key==='Shift') keys.shift=1; if(k==='r') reloadWeapon(); if(k==='1') changeWeapon('pistol'); if(k==='2') changeWeapon('shotgun'); if(k==='3') changeWeapon('smg'); if(k==='4') changeWeapon('rifle'); if(k==='5') changeWeapon('flamethrower'); if(k==='6') changeWeapon('sniper'); if(k==='g') { /* grenade key handled below */ } if(k==='f') meleeAttack(); if(k==='e') tryPickup(); if(k==='v') {/* view toggle placeholder */} if(k==='escape') document.exitPointerLock?.(); });
  window.addEventListener('keyup', (e)=>{ const k = e.key.toLowerCase(); if(k==='w') keys.w=0; if(k==='a') keys.a=0; if(k==='s') keys.s=0; if(k==='d') keys.d=0; if(e.key==='Shift') keys.shift=0; });
  window.addEventListener('mousemove', (e)=>{ if(!controlsEnabled) return; const mvX = e.movementX || 0, mvY = e.movementY || 0; camera.rotation.order = 'YXZ'; camera.rotation.y -= mvX * 0.0024; camera.rotation.x -= mvY * 0.0024; camera.rotation.x = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, camera.rotation.x)); });
  window.addEventListener('mousedown', (e)=>{ if(!running) return; if(e.button === 0){ mouseHeld = true; attemptShoot(); } if(e.button === 2) aiming = true; });
  window.addEventListener('mouseup', (e)=>{ mouseHeld = false; if(e.button === 2) aiming = false; });
  window.addEventListener('contextmenu', e => e.preventDefault());
}

/* ------------- update & render ------------- */
let lastTime = performance.now();
function update(delta){
  // player movement
  const speed = (keys.shift ? 6.2 : 3.4);
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
  const move = new THREE.Vector3();
  if(keys.w) move.add(forward); if(keys.s) move.sub(forward); if(keys.a) move.sub(right); if(keys.d) move.add(right);
  if(move.lengthSq() > 0){ move.normalize().multiplyScalar(speed * delta); camera.position.add(move); camera.position.x = Math.max(-worldSize, Math.min(worldSize, camera.position.x)); camera.position.z = Math.max(-worldSize, Math.min(worldSize, camera.position.z)); }

  // auto fire
  if(mouseHeld && weapons[currentWeaponKey].automatic) attemptShoot();

  // spawn periodically
  if(performance.now() - lastSpawn > spawnInterval && !pausedBetween){
    lastSpawn = performance.now();
    const count = 1 + Math.floor(Math.random()*Math.min(4, 1 + Math.floor(wave/2)));
    for(let i=0;i<count;i++) spawnZombie(null, true);
  }

  // AI update
  for(const z of zombies.slice()){
    const ud = z.userData; ud.stateTime = (ud.stateTime || 0) + delta;
    const toPlayer = new THREE.Vector3().subVectors(camera.position, z.position);
    const dist = Math.hypot(toPlayer.x, toPlayer.z);

    // proximity growl
    if(dist < 50 && (!ud._growl || performance.now() - ud._growl > 4200)){ ud._growl = performance.now(); sfx(120 + Math.random()*120, 0.12, 'triangle', 0.07); }

    if(ud.stealth){
      if(inFOV(z, 30*Math.PI/180, 14) || dist < 6) ud.stealth = false;
      else z.visible = Math.random() < 0.98 ? false : true;
    } else z.visible = true;

    if(ud.type === 'boss'){
      const dir = camera.position.clone().setY(z.position.y).sub(z.position).normalize();
      z.position.x += dir.x * ud.baseSpeed * (1 + wave*0.02) * delta * 0.9;
      z.position.z += dir.z * ud.baseSpeed * (1 + wave*0.02) * delta * 0.9;
      if(dist < 2.2 && (!ud.lastDamage || performance.now() - ud.lastDamage > 900)){
        ud.lastDamage = performance.now(); playerHealth -= 18; hudHealth.textContent = playerHealth; sfx(160,0.16,'sawtooth',0.16); shakeScreen(8);
        if(playerHealth <= 0) endGame();
      }
    } else {
      if(ud.state === 'wander'){
        if(dist < (ud.type === 'runner' ? 16 : 12) || inFOV(z)){ ud.state = 'chase'; ud.stateTime = 0; ud.targetOffset.set((Math.random()-0.5)*1.6,0,(Math.random()-0.5)*1.6); }
        else { z.position.x += (Math.random()-0.5)*0.01; z.position.z += (Math.random()-0.5)*0.01; }
      } else if(ud.state === 'chase' || ud.state === 'flank'){
        const desired = camera.position.clone().setY(z.position.y);
        const offsetRot = ud.targetOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), camera.rotation.y);
        desired.add(offsetRot);
        const dir = desired.clone().sub(z.position).setY(0).normalize();
        const sep = computeSeparation(z).multiplyScalar(0.6); dir.add(sep).normalize();
        const spd = ud.baseSpeed * (1 + Math.min(0.8, wave*0.03));
        z.position.x += dir.x * spd * delta; z.position.z += dir.z * spd * delta;
        if(dist < (ud.type === 'dog' ? 1.1 : 1.15)){ ud.state = 'attack'; ud.stateTime = 0; }
        else if(ud.state === 'chase' && Math.random() < 0.002 + wave*0.0008){ ud.state = 'flank'; ud.stateTime = 0; ud.targetOffset.set((Math.random()-0.5)*2,0,(Math.random()-0.5)*2); }
      } else if(ud.state === 'dodge'){
        const side = (Math.random() < 0.5 ? 1 : -1); z.position.x += Math.cos(camera.rotation.y + side) * ud.baseSpeed * 3.6 * delta; z.position.z += Math.sin(camera.rotation.y + side) * ud.baseSpeed * 3.6 * delta;
        if(ud.stateTime > 0.35) ud.state = 'chase';
      } else if(ud.state === 'attack'){
        if(!ud.lastDamage || performance.now() - ud.lastDamage > 900){
          ud.lastDamage = performance.now();
          const dmg = ud.type === 'tank' ? 12 : (ud.type === 'runner' ? 6 : 6);
          playerHealth -= dmg; hudHealth.textContent = playerHealth; sfx(180,0.06,'sawtooth',0.12); shakeScreen(6);
          if(playerHealth <= 0) endGame();
        }
        if(ud.stateTime > 0.9) ud.state = 'chase';
      }
    }
    const lookAt = new THREE.Vector3(camera.position.x, z.position.y, camera.position.z);
    z.lookAt(lookAt);
  }

  // pickups bob
  for(const p of pickups) p.position.y = 0.5 + Math.sin(performance.now()/420 + p.position.x)*0.07;

  // particles
  updateParticles(delta);

  // wave check
  if(zombies.length < Math.max(1, 2 + Math.floor(wave/2)) && performance.now() - lastWaveTime > 4000){
    lastWaveTime = performance.now(); beginBetweenWave();
  }
}

let fpsTime=0, fpsCount=0;
function loop(){
  if(!running) return;
  const t = performance.now();
  const delta = Math.min(0.06, (t - lastFrame)/1000);
  lastFrame = t;
  update(delta);
  renderer.render(scene, camera);
  fpsCount++; fpsTime += (t - (lastFrame - delta*1000));
  if(fpsTime > 1000){ fpsEl.textContent = 'FPS: ' + Math.round(fpsCount / (fpsTime/1000)); fpsTime = 0; fpsCount = 0; }
  requestAnimationFrame(loop);
}

/* ------------- start/end and utilities ------------- */
function startGame(){
  if(!initialized) return;
  // ensure audio opened by user gesture
  ensureAudio(); startMenuAmbience();
  // set initial player health and UI
  playerHealth = 100; hudHealth.textContent = playerHealth;
  score = 0; hudScore.textContent = score;
  wave = 0; hudWave.textContent = wave;
  // reset arrays
  zombies.forEach(z => scene.remove(z)); zombies = [];
  pickups.forEach(p => scene.remove(p)); pickups = [];
  for(const k in weaponState){ weaponState[k].ammo = weapons[k].mag; weaponState[k].reserve = weapons[k].reserve; weaponState[k].reloading=false; weaponState[k].lastShot=0; }
  changeWeapon('pistol'); updateAmmoUI();
  // hide menu & show in-game HUD
  menu.style.display = 'none';
  hud.style.display = 'block'; weaponUI.style.display = 'block'; crosshair.style.display = 'block'; fpsEl.style.display = 'block';
  // start
  running = true; lastFrame = performance.now(); lastSpawn = performance.now(); lastWaveTime = performance.now();
  startWave(); loop(); sfx(720,0.08,'sine',0.14);
}
function endGame(){
  running = false; gameOverDiv.style.display = 'flex'; document.exitPointerLock?.();
  document.getElementById('goScore').textContent = 'Score: ' + score;
  const prev = parseInt(localStorage.getItem('z13_high') || '0', 10);
  if(score > prev){ localStorage.setItem('z13_high', String(score)); highEl.textContent = score; sfx(960,0.28,'sine',0.2); } else sfx(120,0.6,'sawtooth',0.16);
}

/* shake */
let shakeTime = 0;
function shakeScreen(str=6){
  shakeTime = Math.max(shakeTime, str);
  const orig = camera.position.clone();
  const tick = setInterval(()=> {
    if(shakeTime <= 0){ clearInterval(tick); camera.position.lerp(orig, 0.6); }
    else { camera.position.x += (Math.random()-0.5)*0.03*(shakeTime/8); camera.position.y += (Math.random()-0.5)*0.03*(shakeTime/8); shakeTime -= 0.8; }
  }, 16);
}

/* window resize */
function onResize(){ if(!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

/* initThree if not already (safe) */
function initThreeIfNeeded(){ if(!scene) buildScene(); }

/* ------------- UI wiring ------------- */
startBtn.addEventListener('click', ()=> {
  ensureAudio();
  startMenuAmbience();
  startBtn.disabled = true;
  setTimeout(()=> { startBtn.disabled = false; startGame(); }, 200);
});
retryBtn.addEventListener('click', ()=> {
  gameOverDiv.style.display = 'none'; startGame();
});
creditsBtn.addEventListener('click', ()=> { alert('Z-13: The Quarantine\\nDeveloped by Six\\nSingle-file demo built with Three.js'); });
settingsBtn.addEventListener('click', ()=> { alert('Settings (placeholder)'); });
quitBtn.addEventListener('click', ()=> { menu.style.display = 'none'; stopMenuAmbience(); });

window.addEventListener('mousedown', ()=> mouseHeld = true);
window.addEventListener('mouseup', ()=> mouseHeld = false);

/* prevent context menu */
window.addEventListener('contextmenu', e => e.preventDefault());

/* End of script */
</script>
</body>
</html>
