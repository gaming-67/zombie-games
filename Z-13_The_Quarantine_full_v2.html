<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Z-13: The Quarantine â€” Full v2</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
:root{--accent:#c73b3b;--muted:#b9bcc0;--hud-bg:rgba(6,6,8,0.72)}
html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui,Segoe UI,Helvetica,Arial}
canvas{display:block;width:100%;height:100vh}
#loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:900;background:linear-gradient(#020204,#000)}
#loading h2{color:#fff;margin:0 0 12px 0}
#progressWrap{width:56%;background:rgba(255,255,255,0.04);height:14px;border-radius:8px;overflow:hidden}
#progressFill{height:100%;width:0%;background:linear-gradient(90deg,#c73b3b,#ff7b7b)}
#menu{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:880;color:#fff}
.menu-card{width:min(980px,94%);padding:24px;border-radius:12px;background:rgba(0,0,0,0.5);text-align:center}
.title{font-size:40px;color:#ffefe6;margin:0;text-shadow:0 8px 28px rgba(0,0,0,0.8)}
.subtitle{color:var(--muted);margin-top:6px;font-size:13px}
.map-row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}
.map-card{padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.03);cursor:pointer;font-weight:700}
.map-card.active{outline:2px solid rgba(199,59,59,0.9)}
.btn{background:var(--accent);border:none;color:#fff;padding:10px 14px;border-radius:8px;cursor:pointer;margin:6px}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
#hud{position:fixed;left:12px;top:12px;z-index:860;background:var(--hud-bg);color:#fff;padding:10px;border-radius:10px;min-width:260px;display:none}
#weaponUI{position:fixed;right:12px;bottom:12px;z-index:860;background:var(--hud-bg);color:#fff;padding:10px;border-radius:10px;min-width:220px;display:none}
#crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:855;color:#fff;display:none;font-size:20px}
#pickupPrompt{position:fixed;left:50%;bottom:18%;transform:translateX(-50%);z-index:854;background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:8px;display:none}
#pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:870}
.pause-card{background:rgba(0,0,0,0.6);padding:18px;border-radius:12px;color:#fff;text-align:center}
#gameOver{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:890;background:rgba(0,0,0,0.96);color:#fff}
.save-toast{position:fixed;right:12px;bottom:12px;padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.6);color:#fff;z-index:920}
#pointerHint{position:fixed;left:50%;top:78%;transform:translateX(-50%);z-index:855;padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.36);color:#fff;display:none}
#fps{position:fixed;right:8px;top:8px;color:#ddd;z-index:920;display:none}
</style>
</head>
<body>
  <div id="loading" aria-hidden="false">
    <h2>LOADING Z-13: THE QUARANTINEâ€¦</h2>
    <div id="progressWrap"><div id="progressFill"></div></div>
    <div id="loadingText" style="color:var(--muted);margin-top:10px">Preparing assets...</div>
  </div>

  <div id="menu" aria-hidden="true">
    <div class="menu-card">
      <div class="title">Z-13: The Quarantine</div>
      <div class="subtitle">Realistic survival â€¢ Waves â€¢ E to pick up â€¢ Save/load</div>
      <div style="margin-top:12px;color:var(--muted)">Select Map</div>
      <div class="map-row" id="mapRow"></div>
      <div style="margin-top:14px">
        <button id="startBtn" class="btn">Start Game</button>
        <button id="loadBtn" class="btn ghost" style="display:none">Load Save</button>
        <button id="deleteBtn" class="btn ghost" style="display:none">Delete Save</button>
        <button id="creditsBtn" class="btn ghost">Credits</button>
      </div>
    </div>
  </div>

  <div id="pointerHint">ðŸŽ¯ Click to lock mouse â€¢ ESC to unlock</div>
  <div id="pickupPrompt">[E] Pick up</div>
  <div id="hud">
    <div style="display:flex;justify-content:space-between"><div>Health</div><div id="healthVal">100</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Score</div><div id="scoreVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Wave</div><div id="waveVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Zombies Left</div><div id="zLeft">0</div></div>
  </div>

  <div id="weaponUI">
    <div id="weaponName">Pistol</div>
    <div style="font-size:13px;margin-top:6px">Ammo: <span id="ammoVal">12</span>/<span id="reserveVal">36</span></div>
    <div id="puList" style="margin-top:8px;font-size:12px;color:var(--muted)"></div>
  </div>

  <div id="crosshair">+</div>

  <div id="pauseOverlay"><div class="pause-card blur">
    <h2>Paused</h2>
    <div style="margin-top:8px">
      <button id="resumeBtn" class="btn">Resume</button>
      <button id="saveBtn" class="btn">Save</button>
      <button id="restartBtn" class="btn">Restart</button>
      <button id="mainMenuBtn" class="btn ghost">Main Menu</button>
    </div>
  </div></div>

  <div id="gameOver"><div style="background:rgba(0,0,0,0.6);padding:22px;border-radius:12px;text-align:center;color:#fff">
    <h1>You Died</h1>
    <div id="goScore" style="margin-top:8px">Score: 0</div>
    <div style="margin-top:12px"><button id="retryBtn" class="btn">Retry</button><button id="goMenuBtn" class="btn ghost">Main Menu</button></div>
  </div></div>

  <div id="fps"></div>

  <canvas id="gameCanvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
/* Z-13: The Quarantine â€” Full v2
   Compact but functional single-file build.
   Many systems are simplified for a single-file demo,
   but core features are implemented as you requested.
*/

///// UI refs
const loading = document.getElementById('loading'), progressFill = document.getElementById('progressFill'), loadingText = document.getElementById('loadingText');
const menu = document.getElementById('menu'), mapRow = document.getElementById('mapRow'), startBtn = document.getElementById('startBtn');
const loadBtn = document.getElementById('loadBtn'), deleteBtn = document.getElementById('deleteBtn'), creditsBtn = document.getElementById('creditsBtn');
const pointerHint = document.getElementById('pointerHint'), pickupPrompt = document.getElementById('pickupPrompt');
const hud = document.getElementById('hud'), healthVal = document.getElementById('healthVal'), scoreVal = document.getElementById('scoreVal');
const waveVal = document.getElementById('waveVal'), zLeft = document.getElementById('zLeft');
const weaponUI = document.getElementById('weaponUI'), weaponName = document.getElementById('weaponName'), ammoVal = document.getElementById('ammoVal'), reserveVal = document.getElementById('reserveVal');
const puList = document.getElementById('puList');
const crosshair = document.getElementById('crosshair');
const pauseOverlay = document.getElementById('pauseOverlay'), resumeBtn = document.getElementById('resumeBtn'), saveBtn = document.getElementById('saveBtn'), restartBtn = document.getElementById('restartBtn'), mainMenuBtn = document.getElementById('mainMenuBtn');
const gameOver = document.getElementById('gameOver'), retryBtn = document.getElementById('retryBtn'), goMenuBtn = document.getElementById('goMenuBtn');
const fpsEl = document.getElementById('fps');

const canvas = document.getElementById('gameCanvas');

///// Game state
let scene, camera, renderer, clock;
let running=false, gameStarted=false, paused=false;
let playerHealth=100, score=0, wave=0;
let zombies = [], pickups = [], props = [], particlePools = [];
let zombiesThisWave=0, killsThisWave=0;
let lastSpawn = 0, spawnInterval = 1200, intermissionEnd = 0;
let lastFrame = performance.now();
let audioCtx = null;

///// Maps
const maps = [
  {id:'graveyard', name:'Graveyard', fog:0x0b0b10, fogDensity:0.014, spawnBias:0},
  {id:'city', name:'City Ruins', fog:0x111017, fogDensity:0.012, spawnBias:0.05},
  {id:'facility', name:'Quarantine Facility', fog:0x070707, fogDensity:0.0095, spawnBias:0.12},
  {id:'forest', name:'Forest Outbreak', fog:0x08121a, fogDensity:0.015, spawnBias:-0.05}
];
let selectedMap = maps[0];

/* populate map selector */
maps.forEach((m, i) => {
  const el = document.createElement('div'); el.className='map-card'; if(i===0) el.classList.add('active');
  el.textContent = m.name; el.title = m.name; el.addEventListener('click', ()=>{ document.querySelectorAll('.map-card').forEach(x=>x.classList.remove('active')); el.classList.add('active'); selectedMap = m; });
  mapRow.appendChild(el);
});

///// Weapons
const weapons = {
  pistol:{name:'Pistol',mag:12,reserve:48,fireRate:260,damage:4,automatic:false,reload:900},
  shotgun:{name:'Shotgun',mag:6,reserve:36,fireRate:700,damage:6,pellets:7,automatic:false,reload:1300},
  smg:{name:'SMG',mag:40,reserve:200,fireRate:90,damage:1,automatic:true,reload:1100},
  rifle:{name:'Rifle',mag:30,reserve:120,fireRate:95,damage:1.8,automatic:true,reload:1400},
  sniper:{name:'Sniper',mag:5,reserve:25,fireRate:900,damage:28,automatic:false,reload:2200},
  flamethrower:{name:'Flamethrower',mag:120,reserve:400,fireRate:40,damage:0.18,automatic:true,reload:2000},
  grenade:{name:'Grenade',mag:1,reserve:2,fireRate:800,damage:18,automatic:false,reload:800}
};
let currentWeapon = 'pistol';
let weaponState = {}; for(const k in weapons) weaponState[k] = {ammo:weapons[k].mag, reserve:weapons[k].reserve, reloading:false, lastShot:0};

let inventory = {grenades:2, batteries:1, medkits:1};
let activePowerups = {};

///// Audio helper
function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ audioCtx=null; } } }
function sfx(freq=440,dur=0.06,type='sine',vol=0.12){ if(!audioCtx) return; const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type = type; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination); g.gain.value = 0.0001; g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime+0.01); o.start(); o.stop(audioCtx.currentTime+dur); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur); }

///// Loading (simulated asset loads so bar always moves)
async function simulatedLoad(){
  const assets = [
    'shaders','textures','sounds','zombieModels','uiSprites','maps','particles','weapons','menus','sfx1','sfx2','sfx3'
  ];
  for(let i=0;i<assets.length;i++){
    // simulate varied network/processing times
    await new Promise(res => setTimeout(res, 90 + Math.random()*220));
    progressFill.style.width = Math.round(((i+1)/assets.length)*100) + '%';
    loadingText.textContent = 'Loading ' + assets[i] + '...';
  }
  // small final pause
  await new Promise(r=>setTimeout(r,180));
  loading.style.display = 'none'; menu.style.display = 'flex';
  // show save buttons if save exists
  try{ const exists = !!localStorage.getItem('z13_save_v1'); loadBtn.style.display = exists ? 'inline-block' : 'none'; deleteBtn.style.display = exists ? 'inline-block' : 'none'; }catch(e){}
}

///// Three init & environment
function initScene(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(selectedMap.fog, selectedMap.fogDensity);
  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2500);
  camera.position.set(0,1.6,0);
  renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  const hemi = new THREE.HemisphereLight(0x8888aa, 0x222222, 0.9); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff0c8, 0.5); dir.position.set(8,12,6); scene.add(dir);
  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200,4,4), new THREE.MeshStandardMaterial({color:0x0f0f10}));
  ground.rotation.x = -Math.PI/2; scene.add(ground);
  // map props (lightweight)
  props = [];
  for(let i=0;i<80;i++){
    const p = new THREE.Mesh(new THREE.BoxGeometry(1+Math.random()*3, 1+Math.random()*3, 1+Math.random()*3), new THREE.MeshStandardMaterial({color:0x222222}));
    p.position.set((Math.random()-0.5)*200, p.geometry.parameters.height/2, (Math.random()-0.5)*200); scene.add(p); props.push(p);
  }
  // small barrels
  for(let i=0;i<14;i++){ const b = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.8,10), new THREE.MeshStandardMaterial({color:0x6b2b2b})); b.position.set((Math.random()-0.5)*120,0.4,(Math.random()-0.5)*120); b.userData={explosive:true}; scene.add(b); props.push(b); }

  // particle pools
  particlePools = []; for(let i=0;i<4;i++){ const max=120; const geom=new THREE.BufferGeometry(); const arr=new Float32Array(max*3); geom.setAttribute('position', new THREE.BufferAttribute(arr,3)); const mat=new THREE.PointsMaterial({size:0.08,transparent:true,opacity:0.9}); const pts=new THREE.Points(geom,mat); pts.userData={max,alive:[]}; scene.add(pts); particlePools.push(pts); }

  clock = new THREE.Clock();
  window.addEventListener('resize', onResize);
}

function spawnParticles(pos,color=0x8b0000,count=12,speed=3){
  for(const pool of particlePools){
    const ud = pool.userData;
    if(ud.alive.length + count <= ud.max){
      for(let i=0;i<count;i++) ud.alive.push({px:pos.x,py:pos.y,pz:pos.z,vx:(Math.random()-0.5)*speed,vy:Math.random()*speed*0.6+0.6,vz:(Math.random()-0.5)*speed,life:0,max:0.4+Math.random()*0.6});
      pool.material.color.setHex(color); pool.geometry.attributes.position.needsUpdate=true; return;
    }
  }
}
function updateParticles(delta){
  for(const pool of particlePools){
    const ud = pool.userData; const arr = pool.geometry.attributes.position.array; let k=0;
    for(let i=ud.alive.length-1;i>=0;i--){
      const p=ud.alive[i]; p.life+=delta; p.vy-=9.8*delta*0.7; p.px+=p.vx*delta; p.py+=p.vy*delta; p.pz+=p.vz*delta;
      arr[k*3]=p.px; arr[k*3+1]=p.py; arr[k*3+2]=p.pz; k++; if(p.life>=p.max) ud.alive.splice(i,1);
    }
    pool.geometry.attributes.position.needsUpdate=true;
  }
}

///// Zombies + AI
function spawnZombie(type=null){
  const t = type || (Math.random()<0.06?'tank':(Math.random()<0.12?'runner':(Math.random()<0.07?'exploder':'walker')));
  const colorMap = {walker:0x3db34b, runner:0x3b7fd9, exploder:0xd94b3b, tank:0x7a2bd9};
  const mat = new THREE.MeshStandardMaterial({color: colorMap[t] || 0x3db34b});
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.05,0.5), mat);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.45,0.45,0.45), new THREE.MeshStandardMaterial({color:0x4a5a33}));
  head.position.set(0,0.9,0);
  const g = new THREE.Group(); g.add(torso); g.add(head);
  const angle = Math.random()*Math.PI*2; const r = 30 + Math.random()*40 + (selectedMap.spawnBias||0)*20;
  g.position.set(camera.position.x + Math.cos(angle)*r, 0.6, camera.position.z + Math.sin(angle)*r);
  if(t==='tank') g.userData={type:'tank',hp:10+wave*2,speed:0.35,attack:14};
  else if(t==='runner') g.userData={type:'runner',hp:3+Math.floor(wave*0.2),speed:1.1,attack:6};
  else if(t==='exploder') g.userData={type:'exploder',hp:3+Math.floor(wave*0.4),speed:0.5,explodeRadius:2.4,attack:6};
  else g.userData={type:'walker',hp:3+Math.floor(Math.random()*2 + wave*0.2),speed:0.45+Math.random()*0.2,attack:6};
  scene.add(g); zombies.push(g); return g;
}
function killZombie(z){
  spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.6,0)),0x8b0000,20,4.2);
  try{ scene.remove(z); }catch(e){}
  const idx = zombies.indexOf(z); if(idx>=0) zombies.splice(idx,1);
  killsThisWave++; score += (z.userData.type==='tank'?30:10) + Math.floor(Math.random()*8); scoreVal.textContent = score;
  // loot drop
  if(Math.random() < 0.34){ const type = Math.random()<0.6?'ammo':(Math.random()<0.5?'medkit':'grenade'); const p = spawnPickup(z.position.clone(), type); p.position.add(new THREE.Vector3((Math.random()-0.5)*1,(Math.random()*0.8)+0.2,(Math.random()-0.5)*1)); }
  checkWaveClear();
}

///// Pickups
function spawnPickup(pos, type='ammo'){
  const color = type==='ammo'?0x2b6cff:(type==='medkit'?0xff6b6b:0xffe066);
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.28,10,10), new THREE.MeshStandardMaterial({color:color,emissive:color,emissiveIntensity:0.25}));
  mesh.position.copy(pos); mesh.userData={pickup:true,type}; scene.add(mesh); pickups.push(mesh); return mesh;
}
function tryPickup(){
  let nearest=null, nd=Infinity;
  for(const p of pickups){ const d = p.position.distanceTo(camera.position); if(d < 2 && d < nd){ nd = d; nearest = p; } }
  if(!nearest) return;
  const type = nearest.userData.type; scene.remove(nearest); pickups = pickups.filter(x=>x!==nearest);
  if(type==='ammo'){ for(const k in weaponState) weaponState[k].reserve += 8 + Math.floor(Math.random()*12); sfx(920,0.08,'triangle',0.12); showToast('+ Ammo'); }
  else if(type==='medkit'){ playerHealth = Math.min(100, playerHealth+30); healthVal.textContent = playerHealth; sfx(720,0.08,'sine',0.12); showToast('+30 HP'); }
  else if(type==='grenade'){ inventory.grenades = (inventory.grenades||0) + 1; showToast('+1 Grenade'); }
  updateAmmoUI();
}
function updatePickupPrompt(){
  let near=false;
  for(const p of pickups) if(p.position.distanceTo(camera.position) < 2.0) { near = true; break; }
  pickupPrompt.style.display = near ? 'block' : 'none';
}
function showToast(txt){
  const t = document.createElement('div'); t.className='save-toast'; t.textContent = txt; document.body.appendChild(t); setTimeout(()=> t.style.opacity = '0',900); setTimeout(()=> t.remove(),1400);
}

///// Shooting
function changeWeapon(k){ currentWeapon = k; weaponName.textContent = weapons[k].name; updateAmmoUI(); }
function updateAmmoUI(){ const st = weaponState[currentWeapon]; ammoVal.textContent = st.ammo; reserveVal.textContent = st.reserve; }
function attemptShoot(){
  const w = weapons[currentWeapon], st = weaponState[currentWeapon]; if(st.reloading) return; const now = performance.now(); if(now - st.lastShot < w.fireRate) return; if(st.ammo <= 0){ reload(); return; } st.lastShot = now; st.ammo--; updateAmmoUI(); ensureAudio(); sfx(900+Math.random()*300,0.05,'square',0.14);
  const origin = new THREE.Vector3(); camera.getWorldPosition(origin); const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  if(currentWeapon==='shotgun'){ for(let i=0;i<w.pellets;i++){ const d = dir.clone().add(new THREE.Vector3((Math.random()-0.5)*0.16,(Math.random()-0.5)*0.16,(Math.random()-0.5)*0.16)).normalize(); rayDamage(origin,d,w.damage+Math.floor(Math.random()*2),8); } }
  else if(currentWeapon==='grenade'){ const pt = origin.clone().add(dir.multiplyScalar(6)); spawnExplosion(pt,w.damage+6); }
  else if(currentWeapon==='flamethrower'){ for(let i=0;i<6;i++){ const d = dir.clone().add(new THREE.Vector3((Math.random()-0.5)*0.22,(Math.random()-0.5)*0.22,(Math.random()-0.5)*0.22)).normalize(); rayDamage(origin,d,w.damage,6); } spawnParticles(origin.clone().add(dir.clone().multiplyScalar(0.8)),0xff652b,18,2.2); }
  else rayDamage(origin,dir,w.damage,140);
  muzzleFlash();
}
function rayDamage(origin,dir,damage,maxRange){
  const ray = new THREE.Raycaster(origin,dir,0,maxRange); let hit=null, hitDist=Infinity;
  for(const z of zombies){ const box = new THREE.Box3().setFromObject(z); if(ray.ray.intersectsBox(box)){ const pt = ray.ray.intersectBox(box,new THREE.Vector3()); const d = origin.distanceTo(pt); if(d < hitDist){ hitDist = d; hit = {z,pt}; } } }
  if(hit){ const {z,pt} = hit; const falloff=Math.max(0.5,1 - hitDist/maxRange); const applied = Math.max(1, Math.round(damage * falloff)); z.userData.hp -= applied; spawnParticles(pt,0x9b1b1b,10,3.2); sfx(220+Math.random()*120,0.05,'sawtooth',0.11); if(z.userData.hp <= 0) killZombie(z); else z.position.add(new THREE.Vector3((Math.random()-0.5)*0.2,0,(Math.random()-0.5)*0.2)); }
  else spawnParticles(origin.clone().add(dir.clone().multiplyScalar(maxRange*0.9)),0xffaa66,4,1.4);
}
function muzzleFlash(){ const el = document.createElement('div'); el.style.position='fixed'; el.style.left='50%'; el.style.top='58%'; el.style.transform='translate(-50%,-50%)'; el.style.width='26px'; el.style.height='12px'; el.style.borderRadius='8px'; el.style.background='rgba(255,220,160,0.96)'; el.style.zIndex=9999; document.body.appendChild(el); setTimeout(()=>el.remove(),36); }

function reload(){
  const st = weaponState[currentWeapon]; const w = weapons[currentWeapon]; if(st.reloading) return; if(st.ammo >= w.mag) return; if(st.reserve <= 0) return;
  st.reloading = true; setTimeout(()=>{ const need = w.mag - st.ammo; const take = Math.min(need, st.reserve); st.reserve -= take; st.ammo += take; st.reloading = false; updateAmmoUI(); sfx(420,0.08,'sine',0.12); }, w.reload);
}

function spawnExplosion(pos, damage){
  spawnParticles(pos,0xff9a2b,28,4.6); sfx(80,0.6,'sawtooth',0.18);
  for(const z of zombies.slice()){ const d = z.position.distanceTo(pos); if(d<4.2){ z.userData.hp -= Math.max(2,Math.round(damage*(1-d/4.2))); if(z.userData.hp<=0) killZombie(z); } }
  for(const p of props){ if(p.userData && p.userData.explosive){ const d = p.position.distanceTo(pos); if(d < 5.2){ spawnParticles(p.position,0xff7a2b,40,6.0); try{ scene.remove(p); }catch(e){} } } }
}

///// Wave system (fixed)
function spawnWave(num){
  zombiesThisWave = num; killsThisWave = 0; zLeft.textContent = zombiesThisWave - killsThisWave;
  for(let i=0;i<num;i++){ setTimeout(()=> spawnZombie(), i*120 + Math.random()*400); }
}
function startWave(){
  wave++; waveVal.textContent = wave;
  const base = 8 + Math.floor(wave * 2.6);
  spawnWave(base + Math.floor(wave*1.2));
  sfx(720,0.12,'sine',0.12);
}
function checkWaveClear(){
  const left = Math.max(0, zombiesThisWave - killsThisWave);
  zLeft.textContent = left;
  if(left === 0 && gameStarted){
    intermissionEnd = performance.now() + 5000; // 5s intermission
    for(let i=0;i<3;i++) spawnPickup(camera.position.clone().add(new THREE.Vector3((Math.random()-0.5)*5,0,(Math.random()-0.5)*5)), Math.random()<0.6?'ammo':'medkit');
    showWaveBanner('Wave Cleared');
    // autosave
    z13_save && z13_save.save && z13_save.save(false);
  }
}
function showWaveBanner(txt){
  const b = document.createElement('div'); b.style.position='fixed'; b.style.left='50%'; b.style.top='10%'; b.style.transform='translateX(-50%)'; b.style.padding='8px 14px'; b.style.background='rgba(0,0,0,0.6)'; b.style.color='#fff'; b.style.fontWeight='800'; b.style.zIndex=999; b.style.borderRadius='8px'; b.textContent = txt; document.body.appendChild(b); setTimeout(()=> b.style.opacity='0',4200); setTimeout(()=> b.remove(),4600);
}

///// Controls
let keys = {}, controlsEnabled=false, mouseHeld=false;
let sensitivity = 0.0022;
function initControls(){
  window.addEventListener('keydown', (e)=>{ if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return; const k=e.key.toLowerCase();
    if(k==='w') keys.w=1; if(k==='s') keys.s=1; if(k==='a') keys.a=1; if(k==='d') keys.d=1; if(e.key==='Shift') keys.shift=1;
    if(k==='e') tryPickup();
    if(k==='r') reload();
    if(k==='1') changeWeapon('pistol'); if(k==='2') changeWeapon('shotgun'); if(k==='3') changeWeapon('smg'); if(k==='4') changeWeapon('rifle'); if(k==='5') changeWeapon('sniper'); if(k==='6') changeWeapon('flamethrower');
    if(k==='g') { if(inventory.grenades>0){ inventory.grenades--; throwGrenade(); } else showToast('No grenades'); }
    if(e.key==='Escape') togglePause(true);
  });
  window.addEventListener('keyup', (e)=>{ const k=e.key.toLowerCase(); if(k==='w') keys.w=0; if(k==='s') keys.s=0; if(k==='a') keys.a=0; if(k==='d') keys.d=0; if(e.key==='Shift') keys.shift=0; });
  window.addEventListener('mousemove', (e)=>{ if(!controlsEnabled) return; const mvX = e.movementX||0, mvY = e.movementY||0; camera.rotation.order='YXZ'; camera.rotation.y -= mvX*sensitivity; camera.rotation.x -= mvY*sensitivity; camera.rotation.x = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, camera.rotation.x)); });
  window.addEventListener('mousedown', (e)=>{ if(!gameStarted || paused) return; if(e.button===0){ mouseHeld = true; attemptShoot(); } });
  window.addEventListener('mouseup', ()=>{ mouseHeld=false; });
  document.addEventListener('pointerlockchange', ()=>{ controlsEnabled = (document.pointerLockElement === canvas); pointerHint.style.display = controlsEnabled ? 'none' : 'block'; });
  window.addEventListener('contextmenu', e=> e.preventDefault());
}

function throwGrenade(){ const origin = new THREE.Vector3(); camera.getWorldPosition(origin); const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); const pt = origin.add(dir.multiplyScalar(6)); spawnExplosion(pt, 20); showToast('-1 Grenade'); }

///// Player hit logic
function playerHit(dmg){
  if(activePowerups['ghost'] && activePowerups['ghost'].expires > performance.now()) return;
  playerHealth -= dmg; healthVal.textContent = playerHealth; sfx(160,0.12,'sawtooth',0.12);
  const v = document.createElement('div'); v.style.position='fixed'; v.style.inset='0'; v.style.pointerEvents='none'; v.style.zIndex=9998; v.style.background='radial-gradient(circle at 50% 20%, rgba(160,0,0,0.12), rgba(0,0,0,0))'; document.body.appendChild(v); setTimeout(()=> v.remove(),160);
  if(playerHealth<=0) endGame();
}

///// Update loop
let fpsTime=0, fpsCount=0;
function update(delta){
  // movement
  const speed = keys.shift ? 5.6 : 3.2;
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
  const move = new THREE.Vector3();
  if(keys.w) move.add(forward); if(keys.s) move.sub(forward); if(keys.a) move.sub(right); if(keys.d) move.add(right);
  if(move.lengthSq()>0){ move.normalize().multiplyScalar(speed*delta); camera.position.add(move); camera.position.x = Math.max(-280, Math.min(280, camera.position.x)); camera.position.z = Math.max(-280, Math.min(280, camera.position.z)); }

  if(mouseHeld && weapons[currentWeapon].automatic) attemptShoot();

  // periodic spawns
  if(performance.now() - lastSpawn > spawnInterval && !intermissionEnd && !paused && running){
    lastSpawn = performance.now();
    const count = 1 + Math.floor(Math.random()*Math.min(3,1 + Math.floor(wave/4)));
    for(let i=0;i<count;i++) spawnZombie();
  }

  // zombies AI
  for(const z of zombies.slice()){
    const ud = z.userData; ud._t = (ud._t||0) + delta;
    const toPlayer = new THREE.Vector3().subVectors(camera.position, z.position); const dist = Math.hypot(toPlayer.x,toPlayer.z);
    if(dist < 50 && (!ud._growl || performance.now() - ud._growl > 3000)){ ud._growl = performance.now(); sfx(110+Math.random()*100,0.12,'triangle',0.06); }
    const dir = camera.position.clone().setY(z.position.y).sub(z.position).normalize();
    const sep = computeSeparation(z).multiplyScalar(0.6); dir.add(sep).normalize();
    const spd = (ud.speed || 0.45) * (1 + wave*0.02);
    z.position.x += dir.x * spd * delta; z.position.z += dir.z * spd * delta;
    if(dist < 1.6 && (!ud._hit || performance.now() - ud._hit > 900)){ ud._hit = performance.now(); playerHit(ud.attack || 6); }
    z.lookAt(new THREE.Vector3(camera.position.x, z.position.y, camera.position.z));
  }

  // pickups bob
  for(const p of pickups) p.position.y = 0.5 + Math.sin(performance.now()/420 + p.position.x)*0.07;

  updateParticles(delta);

  // intermission -> start next wave
  if(intermissionEnd && performance.now() > intermissionEnd){ intermissionEnd = 0; startWave(); }

  updatePickupPrompt();
}

/* separation helper */
function computeSeparation(z){
  const sep = new THREE.Vector3(); let count=0;
  for(const o of zombies){ if(o===z) continue; const d = z.position.distanceTo(o.position); if(d < 2.0){ const diff = z.position.clone().sub(o.position).normalize().divideScalar(d); sep.add(diff); count++; } }
  if(count>0) sep.divideScalar(count); return sep;
}

function loop(){
  if(!running) return;
  const t = performance.now();
  const delta = Math.min(0.06, (t - lastFrame)/1000);
  lastFrame = t;
  if(!paused){ update(delta); renderer.render(scene, camera); }
  fpsCount++; fpsTime += (t - (lastFrame - delta*1000));
  if(fpsTime > 1000){ fpsEl.textContent = 'FPS: ' + Math.round(fpsCount / (fpsTime/1000)); fpsTime = 0; fpsCount = 0; }
  requestAnimationFrame(loop);
}

function onResize(){ if(!camera || !renderer) return; camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }

///// Start / pause / end
function startGame(){
  ensureAudio(); initScene(); initControls();
  playerHealth = 100; score = 0; wave = 0; killsThisWave = 0; zombiesThisWave = 0;
  healthVal.textContent = playerHealth; scoreVal.textContent = score; waveVal.textContent = wave; zLeft.textContent = 0;
  for(const k in weaponState){ weaponState[k].ammo = weapons[k].mag; weaponState[k].reserve = weapons[k].reserve; weaponState[k].reloading=false; weaponState[k].lastShot=0; }
  currentWeapon='pistol'; updateAmmoUI();
  // clear arrays
  zombies.forEach(z=>scene.remove(z)); zombies=[]; pickups.forEach(p=>scene.remove(p)); pickups=[]; props.forEach(p=>scene.remove(p)); props=[];
  // rebuild scene for map
  initScene();
  menu.style.display = 'none';
  hud.style.display = 'block'; weaponUI.style.display = 'block'; crosshair.style.display = 'block'; fpsEl.style.display = 'block';
  try{ canvas.requestPointerLock(); }catch(e){}
  pointerHint.style.display = 'block';
  running = true; gameStarted = true; paused = false; lastFrame = performance.now(); lastSpawn = performance.now();
  startWave(); loop();
}

function togglePause(show){
  if(!gameStarted) return;
  paused = show;
  if(show){ pauseOverlay.style.display = 'flex'; document.exitPointerLock?.(); z13_save && z13_save.save && z13_save.save(false); } else { pauseOverlay.style.display = 'none'; canvas.requestPointerLock?.(); }
}

function endGame(){
  running = false; gameOver.style.display = 'flex'; document.getElementById('goScore').textContent = 'Score: ' + score; document.exitPointerLock?.();
  const prev = parseInt(localStorage.getItem('z13_high')||'0',10); if(score>prev) localStorage.setItem('z13_high', String(score));
}

/* UI wiring */
startBtn.addEventListener('click', ()=> { ensureAudio(); startBtn.disabled=true; setTimeout(()=>{ startBtn.disabled=false; startGame(); }, 120); });
resumeBtn.addEventListener('click', ()=> togglePause(false));
restartBtn.addEventListener('click', ()=> { gameOver.style.display='none'; running=false; setTimeout(()=> startGame(), 120); });
mainMenuBtn.addEventListener('click', ()=> { running=false; gameStarted=false; try{ renderer && renderer.clear(); }catch(e){} menu.style.display='flex'; hud.style.display='none'; weaponUI.style.display='none'; crosshair.style.display='none'; pointerHint.style.display='none'; });
retryBtn.addEventListener('click', ()=> { gameOver.style.display='none'; startGame(); });
goMenuBtn.addEventListener('click', ()=> { gameOver.style.display='none'; menu.style.display='flex'; hud.style.display='none'; weaponUI.style.display='none'; crosshair.style.display='none'; });

creditsBtn.addEventListener('click', ()=> alert('Z-13: The Quarantine\\nBuilt by Six â€” single-file demo'));

loadBtn.addEventListener('click', ()=> { const ok = confirm('Load saved game? This will replace current session.'); if(ok){ z13_save && z13_save.load && z13_save.load(); menu.style.display='none'; startGame(); }});
deleteBtn.addEventListener('click', ()=> { const ok = confirm('Delete saved game?'); if(ok){ z13_save && z13_save.del && z13_save.del(); loadBtn.style.display='none'; deleteBtn.style.display='none'; }});

saveBtn.addEventListener('click', ()=> { z13_save && z13_save.save && z13_save.save(true); });

canvas.addEventListener('click', ()=> { if(!document.pointerLockElement) try{ canvas.requestPointerLock(); } catch(e){} });

///// grenade
function throwGrenade(){ if(inventory.grenades>0){ inventory.grenades--; const origin=new THREE.Vector3(); camera.getWorldPosition(origin); const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); const pt = origin.add(dir.multiplyScalar(6)); spawnExplosion(pt,18); showToast('-1 Grenade'); } else showToast('No grenades'); }

///// Save system (v1) - integrated
(function(){
  const SAVE_KEY = 'z13_save_v1';
  function buildSave(){
    try{
      const payload = {version:1,timestamp:Date.now(),player:{health:Math.max(0,Math.round(playerHealth||0)),score:Math.round(score||0),wave:Math.round(wave||0),position:camera?{x:camera.position.x,y:camera.position.y,z:camera.position.z}:null},map:{id:selectedMap&&selectedMap.id?selectedMap.id:null},weapons:{},inventory:{grenades:inventory.grenades||0,batteries:inventory.batteries||0,medkits:inventory.medkits||0},meta:{userAgent:navigator.userAgent,savedAt:new Date().toISOString()}}; if(window.weaponState){ for(const k in window.weaponState) payload.weapons[k] = {ammo:window.weaponState[k].ammo,reserve:window.weaponState[k].reserve}; } return payload;
    }catch(e){ console.error('Save build failed',e); return null; }
  }
  function saveGame(manual=false){
    const data = buildSave(); if(!data) return false; try{ localStorage.setItem(SAVE_KEY, JSON.stringify(data)); showToast(manual?'Game saved':'Auto-saved'); return true; }catch(e){ showToast('Save failed'); return false; }
  }
  function loadGame(){ try{ const raw = localStorage.getItem(SAVE_KEY); if(!raw) return false; const data = JSON.parse(raw); if(data.player){ playerHealth=data.player.health||100; healthVal.textContent=playerHealth; score=data.player.score||0; scoreVal.textContent=score; wave=data.player.wave||0; waveVal.textContent=wave; if(data.player.position && camera) camera.position.set(data.player.position.x||0,data.player.position.y||1.6,data.player.position.z||0); } if(data.map && data.map.id){ const found = maps.find(m=>m.id===data.map.id); if(found) selectedMap=found; } if(data.weapons){ for(const k in data.weapons) if(window.weaponState && window.weaponState[k]){ window.weaponState[k].ammo=data.weapons[k].ammo||window.weaponState[k].ammo; window.weaponState[k].reserve=data.weapons[k].reserve||window.weaponState[k].reserve; } updateAmmoUI(); } inventory.grenades = (data.inventory && data.inventory.grenades) || inventory.grenades; inventory.batteries = (data.inventory && data.inventory.batteries) || inventory.batteries; inventory.medkits = (data.inventory && data.inventory.medkits) || inventory.medkits; showToast('Game loaded'); return true; }catch(e){ showToast('Load failed'); return false; }
  function deleteSave(){ localStorage.removeItem(SAVE_KEY); showToast('Save deleted'); loadBtn.style.display='none'; deleteBtn.style.display='none'; }
  function addMenuButtons(){ const exists = !!localStorage.getItem(SAVE_KEY); loadBtn.style.display = exists ? 'inline-block' : 'none'; deleteBtn.style.display = exists ? 'inline-block' : 'none'; }
  let lastWaveSeen = wave;
  setInterval(()=>{ try{ if(typeof wave !== 'undefined' && wave !== lastWaveSeen){ lastWaveSeen = wave; saveGame(false); addMenuButtons(); } }catch(e){} }, 2500);
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden) saveGame(false); });
  window.addEventListener('beforeunload', ()=>{ saveGame(false); });
  document.addEventListener('DOMContentLoaded', ()=>{ addMenuButtons(); });
  window.z13_save = { save: saveGame, load: loadGame, del: deleteSave };
})();

///// Bootstrap
simulatedLoad(); // runs loader then shows menu
initControls(); // allow keyboard in menu

</script>
</body>
</html>
