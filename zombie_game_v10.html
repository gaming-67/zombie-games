<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Z-13: The Quarantine — Fixed Build</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root { --accent: #c73b3b; --muted: #c7c9cf; --hud-bg: rgba(6,6,8,0.64); }
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui,Segoe UI,Helvetica,Arial}
  canvas{display:block;width:100%;height:100vh}
  /* Menu */
  #menu { position:fixed; inset:0; z-index:60; display:flex; align-items:center; justify-content:center; background:linear-gradient(rgba(0,0,0,0.55), rgba(0,0,0,0.9)); color:#fff; transition:opacity .4s; }
  .menu-card { width:min(960px,94%); padding:26px; border-radius:12px; text-align:center; background:rgba(0,0,0,0.45); box-shadow:0 20px 50px rgba(0,0,0,0.8); }
  h1.title { margin:0; font-size:44px; letter-spacing:1.6px; color:#ffefe6; text-shadow:0 8px 24px rgba(0,0,0,0.8); }
  .subtitle { color:var(--muted); margin-top:6px; font-size:14px; }
  .btn { background:var(--accent); color:#fff; border:none; padding:10px 16px; border-radius:8px; cursor:pointer; font-weight:700; }
  .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; }
  .credits { margin-top:12px; font-size:13px; color:var(--muted); }

  /* HUD */
  #hud { position:fixed; left:12px; top:12px; z-index:50; color:#fff; background:var(--hud-bg); padding:10px; border-radius:10px; min-width:260px; font-weight:700;}
  #weaponUI { position:fixed; right:12px; bottom:12px; z-index:50; color:#fff; background:var(--hud-bg); padding:10px; border-radius:10px; min-width:220px;}
  #crosshair { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:49; pointer-events:none; font-size:20px; color:rgba(255,255,255,0.9) }
  #gameOver { display:none; position:fixed; inset:0; z-index:70; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; color:#fff; }
  .game-over-card { background:rgba(0,0,0,0.6); padding:24px; border-radius:12px; text-align:center; }
  .pickup { position:fixed; left:50%; transform:translateX(-50%); bottom:110px; z-index:51; color:#fff; pointer-events:none; font-weight:800; padding:6px 10px; border-radius:8px; background:rgba(0,0,0,0.6); }
  #bloodOverlay { position:fixed; inset:0; pointer-events:none; z-index:55; opacity:0; background:radial-gradient(circle at 50% 20%, rgba(120,0,0,0.22), rgba(0,0,0,0) 35%); transition:opacity .15s; }
  #fps { position:fixed; right:8px; top:8px; color:#bbb; z-index:80; font-size:12px; }
</style>
</head>
<body>
  <div id="menu" aria-hidden="false">
    <div class="menu-card">
      <h1 class="title">Z-13: The Quarantine</h1>
      <div class="subtitle">No one left the walls... until you did.</div>
      <div style="margin-top:10px;color:var(--muted)">Year 2139 — Sector Z-13 sealed after outbreak. Survive. Find the generator. Escape.</div>
      <div style="margin-top:14px;">
        <button id="startBtn" class="btn">Start Game</button>
        <button id="settingsBtn" class="btn ghost">Settings</button>
        <button id="creditsBtn" class="btn ghost">Credits</button>
        <button id="quitBtn" class="btn ghost">Quit</button>
      </div>
      <div class="credits">Developed by Six</div>
    </div>
  </div>

  <div id="hud" aria-live="polite">
    <div style="display:flex;justify-content:space-between"><div>Health</div><div id="healthVal">100</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Score</div><div id="scoreVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>Wave</div><div id="waveVal">0</div></div>
    <div style="display:flex;justify-content:space-between;margin-top:6px"><div>High</div><div id="highVal">0</div></div>
  </div>

  <div id="weaponUI">
    <div id="weaponName">Pistol</div>
    <div style="font-size:13px;margin-top:6px">Ammo: <span id="ammoVal">12</span> / <span id="reserveVal">36</span></div>
    <div id="reloadText" style="display:none;margin-top:6px;font-size:13px;color:var(--muted)">Reloading...</div>
  </div>

  <div id="crosshair">+</div>
  <div id="pickupText" class="pickup" style="display:none"></div>
  <div id="bloodOverlay"></div>

  <div id="gameOver">
    <div class="game-over-card">
      <h1 id="goTitle">You Died</h1>
      <div id="goScore" style="margin-top:8px">Score: 0</div>
      <div style="margin-top:12px"><button id="retryBtn" class="btn">Retry</button></div>
    </div>
  </div>

  <div id="fps"></div>

  <canvas id="gameCanvas"></canvas>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* Fixed single-file build of Z-13: The Quarantine
   - Start bug fixed: game only begins after Start Game pressed (health init moved)
   - All weapons (1-6 + G) properly wired with per-weapon state
   - Spawn radius tightened so zombies appear closer (40 - 150 units)
   - Muzzle flash, proximity growl, screen shake, menu fade
*/

///// UI refs
const canvas = document.getElementById('gameCanvas');
const menu = document.getElementById('menu');
const startBtn = document.getElementById('startBtn');
const settingsBtn = document.getElementById('settingsBtn');
const creditsBtn = document.getElementById('creditsBtn');
const quitBtn = document.getElementById('quitBtn');
const hudHealth = document.getElementById('healthVal');
const hudScore = document.getElementById('scoreVal');
const hudWave = document.getElementById('waveVal');
const highEl = document.getElementById('highVal');
const weaponNameEl = document.getElementById('weaponName');
const ammoEl = document.getElementById('ammoVal');
const reserveEl = document.getElementById('reserveVal');
const reloadText = document.getElementById('reloadText');
const pickupText = document.getElementById('pickupText');
const bloodOverlay = document.getElementById('bloodOverlay');
const gameOverDiv = document.getElementById('gameOver');
const retryBtn = document.getElementById('retryBtn');
const fpsEl = document.getElementById('fps');

///// Game state
let scene, camera, renderer, clock;
let running = false;
let playerHealth = 100;
let score = 0, wave = 0;
let zombies = [], pickups = [], props = [];
const worldSize = 120;
let lastSpawn = 0, spawnInterval = 1500, lastWaveTime = 0;
let lastFrame = performance.now();
let audioCtx = null;
let menuAmbienceNode = null;

function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function sfx(freq=440, dur=0.06, type='sine', vol=0.12){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  o.connect(g); g.connect(audioCtx.destination);
  g.start();
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
  o.stop(audioCtx.currentTime + dur);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
}

/* start menu ambience (requires user gesture to create audio context) */
function startMenuAmbience(){
  if(!audioCtx) return;
  stopMenuAmbience();
  const o1 = audioCtx.createOscillator(), o2 = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o1.type = 'sine'; o2.type = 'sine';
  o1.frequency.value = 40; o2.frequency.value = 55;
  o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 0.2);
  o1.start(); o2.start();
  menuAmbienceNode = {o1,o2,g};
  setInterval(()=> {
    if(!menuAmbienceNode) return;
    const f = 30 + Math.random()*30; const f2 = 45 + Math.random()*40;
    try { menuAmbienceNode.o1.frequency.setTargetAtTime(f, audioCtx.currentTime, 1.5); menuAmbienceNode.o2.frequency.setTargetAtTime(f2, audioCtx.currentTime, 1.5); } catch(e){}
  }, 4200);
}
function stopMenuAmbience(){
  if(!menuAmbienceNode) return;
  try{ menuAmbienceNode.o1.stop(); menuAmbienceNode.o2.stop(); } catch(e){}
  menuAmbienceNode = null;
}

/* Weapons config (per-weapon independent state) */
const weapons = {
  pistol: {name:'Pistol', mag:12, reserve:96, fireRate:260, damage:3, automatic:false, reloadTime:900, hipSpread:0.06, adsSpread:0.01},
  shotgun: {name:'Shotgun', mag:6, reserve:48, fireRate:680, damage:6, pellets:7, spread:0.18, automatic:false, reloadTime:1200, hipSpread:0.18, adsSpread:0.06},
  smg: {name:'SMG', mag:40, reserve:200, fireRate:80, damage:1, automatic:true, reloadTime:1200, hipSpread:0.07, adsSpread:0.02},
  rifle: {name:'Rifle', mag:30, reserve:150, fireRate:95, damage:1.6, automatic:true, reloadTime:1400, hipSpread:0.045, adsSpread:0.005},
  flamethrower: {name:'Flamethrower', mag:120, reserve:400, fireRate:40, damage:0.18, automatic:true, reloadTime:2000, range:6},
  sniper: {name:'Sniper', mag:5, reserve:25, fireRate:900, damage:28, automatic:false, reloadTime:2200, hipSpread:0.002, adsSpread:0.0008},
  grenade: {name:'Grenade', mag:1, reserve:3, fireRate:800, damage:14, automatic:false, reloadTime:800}
};
let currentWeaponKey = 'pistol';
let weaponState = {}; for(const k in weapons) weaponState[k] = {ammo:weapons[k].mag, reserve:weapons[k].reserve, reloading:false, lastShot:0};
let aiming = false, mouseHeld = false, meleeCooldown = 0;

/* Three.js setup */
function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.014);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2500);
  camera.position.set(0,1.6,0);

  renderer = new THREE.WebGLRenderer({canvas:canvas, antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio ? devicePixelRatio : 1);

  const hemi = new THREE.HemisphereLight(0x9999aa, 0x222222, 0.9); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff0c8, 0.6); dir.position.set(8,12,6); scene.add(dir);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(worldSize*2, worldSize*2, 16,16), new THREE.MeshStandardMaterial({color:0x0f0f10}));
  ground.rotation.x = -Math.PI/2; scene.add(ground);

  // props (gravestones/trees/barrels/safehouse)
  for(let i=0;i<160;i++){
    if(Math.random() < 0.56){
      const h = 0.6 + Math.random()*1.6;
      const box = new THREE.Mesh(new THREE.BoxGeometry(0.6,h,0.25), new THREE.MeshStandardMaterial({color:0x222222}));
      box.position.set((Math.random()-0.5)*worldSize, h/2, (Math.random()-0.5)*worldSize);
      box.rotation.y = Math.random()*Math.PI*2;
      scene.add(box); props.push(box);
    } else {
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,1.6,6), new THREE.MeshStandardMaterial({color:0x3b2b1a}));
      const leaves = new THREE.Mesh(new THREE.SphereGeometry(0.8,6,6), new THREE.MeshStandardMaterial({color:0x0f3b13}));
      const x=(Math.random()-0.5)*worldSize, z=(Math.random()-0.5)*worldSize;
      trunk.position.set(x,0.8,z); leaves.position.set(x,1.6,z);
      scene.add(trunk); scene.add(leaves); props.push(trunk); props.push(leaves);
    }
  }
  // safehouse
  const safehouse = new THREE.Mesh(new THREE.BoxGeometry(6,3.5,6), new THREE.MeshStandardMaterial({color:0x111118}));
  safehouse.position.set(12,1.75,-8); scene.add(safehouse); props.push(safehouse);

  // lamp posts
  for(let i=0;i<10;i++){
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,2,6), new THREE.MeshStandardMaterial({color:0x444444}));
    pole.position.set((Math.random()-0.5)*worldSize,1,(Math.random()-0.5)*worldSize);
    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.12,6,6), new THREE.MeshStandardMaterial({emissive:0xfff1c6, emissiveIntensity:0.32, color:0x222222}));
    bulb.position.set(pole.position.x, pole.position.y+1, pole.position.z);
    scene.add(pole); scene.add(bulb);
    setInterval(()=> { bulb.material.emissiveIntensity = 0.12 + Math.random()*0.6; }, 900 + Math.random()*1600);
  }

  clock = new THREE.Clock();
  window.addEventListener('resize', onResize);
  canvas.addEventListener('click', ()=>{ if(running) canvas.requestPointerLock?.(); });

  document.addEventListener('pointerlockchange', ()=>{ controlsEnabled = !!document.pointerLockElement; });

  window.addEventListener('mousedown', (e)=> { if(!running) return; if(e.button===0){ mouseHeld=true; attemptShoot(); } if(e.button===2) aiming=true; });
  window.addEventListener('mouseup', (e)=> { mouseHeld=false; if(e.button===2) aiming=false; });
  window.addEventListener('keydown', (e)=> {
    if(e.key === 'r' || e.key === 'R') reloadWeapon();
    if(e.key === '1') changeWeapon('pistol');
    if(e.key === '2') changeWeapon('shotgun');
    if(e.key === '3') changeWeapon('smg');
    if(e.key === '4') changeWeapon('rifle');
    if(e.key === '5') changeWeapon('flamethrower');
    if(e.key === '6') changeWeapon('sniper');
    if(e.key === 'g' || e.key === 'G') throwGrenade();
    if(e.key === 'f' || e.key === 'F') meleeAttack();
    if(e.key === 'e' || e.key === 'E') tryPickup();
    if(e.key === 'v' || e.key === 'V') toggleView();
    if(e.key === 'Escape') document.exitPointerLock?.();
  });

  // particle pools
  for(let i=0;i<5;i++) makeParticlePool();
}

/* Controls */
let controlsEnabled = false;
const keys = {w:0,a:0,s:0,d:0,shift:0};
function initControls(){
  window.addEventListener('keydown', (e)=>{ if(e.repeat) return; if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return; if(e.key.toLowerCase()==='w') keys.w=1; if(e.key.toLowerCase()==='a') keys.a=1; if(e.key.toLowerCase()==='s') keys.s=1; if(e.key.toLowerCase()==='d') keys.d=1; if(e.key==='Shift') keys.shift=1; });
  window.addEventListener('keyup', (e)=>{ if(e.key.toLowerCase()==='w') keys.w=0; if(e.key.toLowerCase()==='a') keys.a=0; if(e.key.toLowerCase()==='s') keys.s=0; if(e.key.toLowerCase()==='d') keys.d=0; if(e.key==='Shift') keys.shift=0; });
  window.addEventListener('mousemove', (e)=>{ if(!controlsEnabled) return; const mvX=e.movementX||0, mvY=e.movementY||0; camera.rotation.order='YXZ'; camera.rotation.y -= mvX * 0.0024; camera.rotation.x -= mvY * 0.0024; camera.rotation.x = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, camera.rotation.x)); });
}

/* Particle pool */
const particlePools = [];
function makeParticlePool(){ if(!scene) return; const max = 120; const geom = new THREE.BufferGeometry(); const arr = new Float32Array(max*3); geom.setAttribute('position', new THREE.BufferAttribute(arr,3)); const mat = new THREE.PointsMaterial({size:0.08, transparent:true, opacity:0.9}); const pts = new THREE.Points(geom, mat); pts.userData = {max, alive:[]}; scene.add(pts); particlePools.push(pts); }
function spawnParticles(pos, color=0x8b0000, count=14, speed=3){
  for(const pool of particlePools){
    const ud = pool.userData; if(ud.alive.length + count <= ud.max){
      for(let i=0;i<count;i++) ud.alive.push({px:pos.x,py:pos.y,pz:pos.z,vx:(Math.random()-0.5)*speed,vy:Math.random()*speed*0.6+0.6,vz:(Math.random()-0.5)*speed,life:0,max:0.5+Math.random()*0.6});
      pool.material.color.setHex(color); return;
    }
  }
}
function updateParticles(delta){
  for(const pool of particlePools){
    const ud = pool.userData; const arr = pool.geometry.attributes.position.array;
    let k=0;
    for(let i=ud.alive.length-1;i>=0;i--){
      const p = ud.alive[i];
      p.life += delta; p.vy -= 9.8 * delta * 0.7; p.px += p.vx*delta; p.py += p.vy*delta; p.pz += p.vz*delta;
      arr[k*3] = p.px; arr[k*3+1] = p.py; arr[k*3+2] = p.pz; k++;
      if(p.life >= p.max) ud.alive.splice(i,1);
    }
    pool.geometry.attributes.position.needsUpdate = true;
  }
}

/* Zombie spawn (closer radius) and colored types */
function spawnZombie(type=null, fromEdge=true){
  const types = ['walker','runner','crawler','exploder','tank','dog'];
  let t = type || (Math.random()<0.06 ? 'tank' : (Math.random()<0.12 ? 'runner' : (Math.random()<0.07 ? 'exploder' : (Math.random()<0.08 ? 'crawler' : (Math.random()<0.06 ? 'dog' : 'walker')))));
  const colorMap = { walker:0x3db34b, runner:0x3b7fd9, crawler:0x8b5a2b, exploder:0xd94b3b, tank:0x7a2bd9, dog:0xf2f2f2 };
  const mat = new THREE.MeshStandardMaterial({color:colorMap[t], roughness:1});
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.15,0.5), mat);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color:0x556633}));
  head.position.set(0,0.95,0);
  const group = new THREE.Group(); group.add(torso); group.add(head);

  // spawn distance: closer (40..150) with 10% chance further (150..300)
  const angle = Math.random()*Math.PI*2;
  let r;
  if(Math.random() < 0.10) r = 150 + Math.random()*150;
  else r = 40 + Math.random()*110; // 40..150
  group.position.set(Math.cos(angle)*r, 0.6, Math.sin(angle)*r);

  if(type === 'boss'){
    group.scale.set(2.1,2.1,2.1);
    group.userData = {type:'boss', hp:200 + wave*50, baseSpeed:0.28, state:'chase', stateTime:0, lastGroan:0, lastDamage:0};
  } else {
    if(t==='walker') group.userData = {type:'walker', hp:3 + Math.floor(Math.random()*2 + wave*0.2), baseSpeed:0.5 + Math.random()*0.2, state:'wander', stateTime:0, lastGroan:0, lastDamage:0, targetOffset:new THREE.Vector3()};
    if(t==='runner') group.userData = {type:'runner', hp:2 + Math.floor(wave*0.08), baseSpeed:0.9 + Math.random()*0.8, state:'wander', stateTime:0, lastGroan:0, lastDamage:0, targetOffset:new THREE.Vector3()};
    if(t==='crawler') group.userData = {type:'crawler', hp:2 + Math.floor(wave*0.5), baseSpeed:0.45 + Math.random()*0.2, state:'wander', stateTime:0, lastGroan:0, lastDamage:0, stealth:true, targetOffset:new THREE.Vector3()};
    if(t==='exploder') group.userData = {type:'exploder', hp:3 + Math.floor(wave*0.4), baseSpeed:0.5 + Math.random()*0.25, explodeRadius:2.3, state:'wander', stateTime:0, lastGroan:0, lastDamage:0, targetOffset:new THREE.Vector3()};
    if(t==='tank') group.userData = {type:'tank', hp:8 + Math.floor(wave*1.2), baseSpeed:0.35 + Math.random()*0.15, state:'wander', stateTime:0, lastGroan:0, lastDamage:0, targetOffset:new THREE.Vector3()};
    if(t==='dog') group.userData = {type:'dog', hp:2, baseSpeed:1.4 + Math.random()*0.6, state:'wander', stateTime:0, lastGroan:0, lastDamage:0, targetOffset:new THREE.Vector3()};
  }

  scene.add(group);
  zombies.push(group);
}

/* AI helpers */
function computeSeparation(z){
  const sep = new THREE.Vector3(); let count=0;
  for(const o of zombies){ if(o===z) continue; const d = z.position.distanceTo(o.position); if(d < 2.0){ const diff = z.position.clone().sub(o.position).normalize().divideScalar(d); sep.add(diff); count++; } }
  if(count>0) sep.divideScalar(count);
  return sep;
}
function inFOV(z, maxAngle=50*Math.PI/180, maxDist=22){
  const toZ = new THREE.Vector3().subVectors(z.position, camera.position); const horiz = Math.hypot(toZ.x,toZ.z);
  if(horiz > maxDist) return false;
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
  const toZNorm = toZ.clone(); toZNorm.y=0; toZNorm.normalize();
  const angle = Math.acos(Math.max(-1,Math.min(1, forward.dot(toZNorm))));
  return angle < maxAngle;
}

/* Weapons & shooting (fixed wiring) */
function changeWeapon(key){
  currentWeaponKey = key;
  weaponNameEl.textContent = weapons[key].name;
  updateAmmoUI();
}
function updateAmmoUI(){
  const st = weaponState[currentWeaponKey];
  ammoEl.textContent = Math.round(st.ammo);
  reserveEl.textContent = Math.round(st.reserve);
}
function attemptShoot(){
  const k = currentWeaponKey, w = weapons[k], st = weaponState[k];
  if(st.reloading) return;
  const now = performance.now();
  if(now - st.lastShot < w.fireRate) return;
  if(st.ammo <= 0){ reloadWeapon(); return; }
  st.lastShot = now; st.ammo--; updateAmmoUI();
  ensureAudio(); sfx(900 + Math.random()*300, 0.05, 'square', 0.16);

  const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
  const dirBase = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();

  if(k === 'shotgun'){
    const spread = aiming ? w.adsSpread : w.hipSpread;
    for(let i=0;i<w.pellets;i++){
      const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
      rayDamage(origin,d,w.damage + Math.floor(Math.random()*2), 6.5 + wave*0.1);
    }
  } else if(k === 'flamethrower'){
    const spread = 0.28 * (aiming ? 0.6 : 1);
    for(let i=0;i<8;i++){
      const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
      rayDamage(origin,d,w.damage, w.range);
    }
    spawnFlame(origin, dirBase);
  } else if(k === 'grenade'){
    const pt = origin.clone().add(dirBase.multiplyScalar(6));
    spawnExplosion(pt, w.damage + 6);
  } else {
    const spread = aiming ? (w.adsSpread || w.hipSpread*0.4) : w.hipSpread;
    const d = dirBase.clone().add(new THREE.Vector3((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread)).normalize();
    rayDamage(origin,d,w.damage, k==='rifle'?90:140);
  }
  flashMuzzle();
}

/* Ray/hit handling */
function rayDamage(origin,dir,damage,maxRange){
  const ray = new THREE.Raycaster(origin,dir,0,maxRange);
  let hit=null, hitDist=Infinity;
  for(const z of zombies){
    const box = new THREE.Box3().setFromObject(z);
    if(ray.ray.intersectsBox(box)){
      const pt = ray.ray.intersectBox(box,new THREE.Vector3());
      const d = origin.distanceTo(pt);
      if(d < hitDist){ hitDist = d; hit = {z,pt}; }
    }
  }
  if(hit){
    const {z,pt} = hit;
    const falloff = Math.max(0.5, 1 - hitDist/maxRange);
    const applied = Math.max(1, Math.round(damage * falloff));
    z.userData.hp -= applied;
    spawnParticles(pt, 0x8b0000, 12, 3.2);
    sfx(220 + Math.random()*120, 0.05, 'sawtooth', 0.12);
    flashHit();
    if(z.userData.hp <= 0) killZombie(z);
    else { if(z.userData.stealth) z.userData.stealth=false; if(z.userData.type === 'runner' && Math.random() < 0.28){ z.userData.state='dodge'; z.userData.stateTime=0; } }
  } else {
    const missPoint = origin.clone().add(dir.clone().multiplyScalar(maxRange*0.9));
    spawnParticles(missPoint, 0xffaa66, 6, 1.6);
  }
}
function flashMuzzle(){ const el=document.createElement('div'); el.style.position='fixed'; el.style.left='50%'; el.style.top='58%'; el.style.transform='translate(-50%,-50%)'; el.style.width='26px'; el.style.height='14px'; el.style.borderRadius='8px'; el.style.background='rgba(255,220,160,0.96)'; el.style.zIndex=9999; document.body.appendChild(el); setTimeout(()=> el.remove(), 36); }
function flashHit(){ bloodOverlay.style.opacity = 0.85; setTimeout(()=> bloodOverlay.style.opacity = 0, 140); }

/* pickups, grenades, explosion, flame */
function spawnPickup(pos){
  const type = Math.random() < 0.5 ? 'ammo' : 'health';
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.28,8,8), new THREE.MeshStandardMaterial({color: type==='ammo' ? 0x2b6cff : 0xff6b6b}));
  mesh.position.copy(pos).add(new THREE.Vector3(0,0.6,0));
  mesh.userData = {type};
  scene.add(mesh); pickups.push(mesh);
}
function tryPickup(){
  let nearest=null, nd=Infinity;
  for(const p of pickups){ const d = p.position.distanceTo(camera.position); if(d < 2.0 && d < nd){ nd=d; nearest=p; } }
  if(nearest){
    if(nearest.userData.type === 'health'){ playerHealth = Math.min(100, playerHealth + 50); hudHealth.textContent = playerHealth; showPickupText('+50 HP'); sfx(640,0.08,'triangle',0.12); }
    else { for(const k of Object.keys(weaponState)) weaponState[k].reserve += 8 + Math.floor(Math.random()*12); updateAmmoUI(); showPickupText('Ammo Pack'); sfx(920,0.08,'triangle',0.12); }
    scene.remove(nearest); pickups = pickups.filter(p => p !== nearest);
  }
}
function showPickupText(txt){ pickupText.textContent = txt; pickupText.style.display = 'block'; setTimeout(()=> pickupText.style.display = 'none', 1200); }
function throwGrenade(){ const origin = new THREE.Vector3(); camera.getWorldPosition(origin); const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); const pt = origin.clone().add(dir.multiplyScalar(6)); spawnExplosion(pt, 16); }
function spawnExplosion(pos, damage){ spawnParticles(pos, 0xff9a2b, 26, 4.6); sfx(80,0.6,'sawtooth',0.18); for(const z of zombies.slice()){ const d = z.position.distanceTo(pos); if(d < 4.2){ z.userData.hp -= Math.max(2, Math.round(damage * (1 - d/4.2))); if(z.userData.hp <= 0) killZombie(z); } } }
function spawnFlame(origin, dir){ const base = origin.clone().add(dir.clone().multiplyScalar(0.8)); spawnParticles(base, 0xff652b, 22, 2.2); }

/* kill and drop */
function killZombie(z){
  spawnParticles(z.position.clone().add(new THREE.Vector3(0,0.6,0)), 0x8b0000, 24, 4.2);
  scene.remove(z); zombies = zombies.filter(x => x !== z);
  let gain = 10; if(z.userData.type === 'runner') gain+=3; if(z.userData.type === 'tank') gain+=12; if(z.userData.type === 'boss') gain+=300; if(z.userData.type === 'dog') gain+=6;
  score += gain + Math.floor(Math.random()*8) + wave*2; hudScore.textContent = score; sfx(160,0.18,'sine',0.18);
  if(z.userData.type === 'exploder'){ for(const o of zombies.slice()){ const d = o.position.distanceTo(z.position); if(d < z.userData.explodeRadius){ o.userData.hp -= 2 + Math.floor(Math.random()*3); spawnParticles(o.position, 0xffaa44, 10, 2.6); if(o.userData.hp <= 0) killZombie(o); } } }
  if(Math.random() < 0.28) spawnPickup(z.position.clone());
}

/* reload & melee */
function reloadWeapon(){
  const key = currentWeaponKey; const w = weapons[key]; const st = weaponState[key];
  if(st.reloading) return; if(st.ammo >= w.mag) return; if(st.reserve <= 0) return;
  st.reloading = true; reloadText.style.display = 'block';
  setTimeout(()=> { const need = w.mag - st.ammo; const take = Math.min(need, st.reserve); st.reserve -= take; st.ammo += take; st.reloading = false; reloadText.style.display = 'none'; updateAmmoUI(); sfx(420,0.08,'sine',0.12); }, w.reloadTime);
}
function meleeAttack(){
  if(performance.now() < meleeCooldown) return;
  meleeCooldown = performance.now() + 900;
  sfx(480,0.06,'square',0.13);
  const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  const ray = new THREE.Raycaster(origin, dir, 0, 1.8);
  for(const z of zombies){
    const box = new THREE.Box3().setFromObject(z);
    if(ray.ray.intersectsBox(box)){ z.userData.hp -= 6 + Math.floor(Math.random()*4); spawnParticles(z.position.clone(), 0x8b0000, 10, 3.2); if(z.userData.hp <= 0) killZombie(z); break; }
  }
}

/* wave & between wave */
function startWave(){
  wave++; hudWave.textContent = wave;
  spawnInterval = Math.max(600, 1500 - (wave-1)*70);
  const initial = 3 + Math.floor(1.5 * wave);
  for(let i=0;i<initial;i++){
    if(wave % 6 === 0 && i===0) spawnZombie('boss', true);
    else spawnZombie(null, true);
  }
}
let pausedBetween = false;
function beginBetweenWave(){
  pausedBetween = true;
  playerHealth = Math.min(100, playerHealth + 14); hudHealth.textContent = playerHealth;
  setTimeout(()=> { pausedBetween = false; startWave(); }, 2200);
}

/* update loop (AI, movement, particles) */
let lastTime = performance.now();
function update(delta){
  // movement
  const speed = (keys.shift ? 6.2 : 3.4);
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y = 0; right.normalize();
  const move = new THREE.Vector3();
  if(keys.w) move.add(forward); if(keys.s) move.sub(forward); if(keys.a) move.sub(right); if(keys.d) move.add(right);
  if(move.lengthSq() > 0){ move.normalize().multiplyScalar(speed * delta); camera.position.add(move); camera.position.x = Math.max(-worldSize, Math.min(worldSize, camera.position.x)); camera.position.z = Math.max(-worldSize, Math.min(worldSize, camera.position.z)); }

  // auto-fire
  if(mouseHeld && weapons[currentWeaponKey].automatic) attemptShoot();

  // spawn periodically (only when not pausedBetween)
  if(performance.now() - lastSpawn > spawnInterval && !pausedBetween){
    lastSpawn = performance.now();
    const count = 1 + Math.floor(Math.random()*Math.min(4, 1 + Math.floor(wave/2)));
    for(let i=0;i<count;i++) spawnZombie(null, true);
  }

  // AI update + proximity growl
  for(const z of zombies.slice()){
    const ud = z.userData; ud.stateTime = (ud.stateTime || 0) + delta;
    const toPlayer = new THREE.Vector3().subVectors(camera.position, z.position);
    const dist = Math.hypot(toPlayer.x, toPlayer.z);

    // proximity growl
    if(dist < 50 && (!ud._growlPlayed || performance.now() - ud._growlPlayed > 3500)){
      ud._growlPlayed = performance.now();
      ensureAudio(); sfx(120 + Math.random()*120, 0.12, 'triangle', 0.08);
    }

    if(ud.stealth){
      if(inFOV(z, 30*Math.PI/180, 14) || dist < 6) ud.stealth = false;
      else z.visible = Math.random() < 0.98 ? false : true;
    } else z.visible = true;

    if(ud.type === 'boss'){
      const dir = camera.position.clone().setY(z.position.y).sub(z.position).normalize();
      z.position.x += dir.x * ud.baseSpeed * (1 + wave*0.02) * delta * 0.9;
      z.position.z += dir.z * ud.baseSpeed * (1 + wave*0.02) * delta * 0.9;
      if(dist < 2.2 && (!ud.lastDamage || performance.now() - ud.lastDamage > 900)){
        ud.lastDamage = performance.now();
        playerHealth -= 18; hudHealth.textContent = playerHealth; sfx(160,0.16,'sawtooth',0.16); shakeScreen(8);
        if(playerHealth <= 0) endGame();
      }
    } else {
      if(ud.state === 'wander'){
        if(dist < (ud.type === 'runner' ? 16 : 12) || inFOV(z)){ ud.state = 'chase'; ud.stateTime = 0; ud.targetOffset.set((Math.random()-0.5)*1.6,0,(Math.random()-0.5)*1.6); }
        else { z.position.x += (Math.random()-0.5)*0.01; z.position.z += (Math.random()-0.5)*0.01; }
      } else if(ud.state === 'chase' || ud.state === 'flank'){
        const desired = camera.position.clone().setY(z.position.y);
        const offsetRot = ud.targetOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), camera.rotation.y);
        desired.add(offsetRot);
        const dir = desired.clone().sub(z.position).setY(0).normalize();
        const sep = computeSeparation(z).multiplyScalar(0.6); dir.add(sep).normalize();
        const spd = ud.baseSpeed * (1 + Math.min(0.8, wave*0.03));
        z.position.x += dir.x * spd * delta; z.position.z += dir.z * spd * delta;
        if(dist < (ud.type === 'dog' ? 1.1 : 1.15)){ ud.state = 'attack'; ud.stateTime = 0; }
        else if(ud.state === 'chase' && Math.random() < 0.002 + wave*0.0008){ ud.state = 'flank'; ud.stateTime = 0; ud.targetOffset.set((Math.random()-0.5)*2,0,(Math.random()-0.5)*2); }
      } else if(ud.state === 'dodge'){
        const side = (Math.random() < 0.5 ? 1 : -1);
        z.position.x += Math.cos(camera.rotation.y + side) * ud.baseSpeed * 3.6 * delta;
        z.position.z += Math.sin(camera.rotation.y + side) * ud.baseSpeed * 3.6 * delta;
        if(ud.stateTime > 0.35) ud.state = 'chase';
      } else if(ud.state === 'attack'){
        if(!ud.lastDamage || performance.now() - ud.lastDamage > 900){
          ud.lastDamage = performance.now();
          const dmg = ud.type === 'tank' ? 12 : (ud.type === 'runner' ? 6 : 6);
          playerHealth -= dmg; hudHealth.textContent = playerHealth; sfx(180,0.06,'sawtooth',0.12); shakeScreen(6);
          if(playerHealth <= 0) endGame();
        }
        if(ud.stateTime > 0.9) ud.state = 'chase';
      }
    }
    const lookAt = new THREE.Vector3(camera.position.x, z.position.y, camera.position.z);
    z.lookAt(lookAt);
  }

  // pickups bob
  for(const p of pickups) p.position.y = 0.5 + Math.sin(performance.now()/420 + p.position.x)*0.07;

  // update particles
  updateParticles(delta);

  // wave spawn check
  if(zombies.length < Math.max(1, 2 + Math.floor(wave/2)) && performance.now() - lastWaveTime > 4000){
    lastWaveTime = performance.now();
    beginBetweenWave();
  }
}

/* Main render loop */
let fpsTime=0, fpsCount=0;
function loop(){
  if(!running) return;
  const t = performance.now();
  const delta = Math.min(0.06, (t - lastFrame)/1000);
  lastFrame = t;
  update(delta);
  renderer.render(scene, camera);
  fpsCount++; fpsTime += (t - (lastFrame - delta*1000));
  if(fpsTime > 1000){ fpsEl.textContent = 'FPS: ' + Math.round(fpsCount / (fpsTime/1000)); fpsTime = 0; fpsCount = 0; }
  requestAnimationFrame(loop);
}

/* Start & end */
function startGame(){
  // initialize audio from user gesture
  ensureAudio(); startMenuAmbience();
  // reset game state
  playerHealth = 100; hudHealth.textContent = playerHealth;
  score = 0; hudScore.textContent = score;
  wave = 0; hudWave.textContent = wave;
  zombies.forEach(z=>scene.remove(z)); zombies = [];
  pickups.forEach(p=>scene.remove(p)); pickups = [];
  for(const k in weaponState){ weaponState[k].ammo = weapons[k].mag; weaponState[k].reserve = weapons[k].reserve; weaponState[k].reloading=false; weaponState[k].lastShot=0; }
  changeWeapon('pistol'); updateAmmoUI();
  // fade menu out smoothly
  menu.style.opacity = '0'; setTimeout(()=> { menu.style.display = 'none'; stopMenuAmbience(); }, 420);
  // start
  running = true; lastFrame = performance.now(); lastSpawn = performance.now(); lastWaveTime = performance.now();
  initThreeIfNeeded(); startWave(); loop();
  sfx(720,0.08,'sine',0.14);
}
function endGame(){
  running = false; gameOverDiv.style.display = 'flex'; document.exitPointerLock?.();
  goScore.textContent = 'Score: ' + score;
  const prev = parseInt(localStorage.getItem('z13_high') || '0',10);
  if(score > prev){ localStorage.setItem('z13_high', String(score)); highEl.textContent = score; sfx(960,0.28,'sine',0.2); } else sfx(120,0.6,'sawtooth',0.16);
}

/* Screen shake util */
let shakeTime = 0;
function shakeScreen(str=6){ shakeTime = Math.max(shakeTime, str); const orig = camera.position.clone(); const tick = setInterval(()=>{ if(shakeTime <= 0){ clearInterval(tick); camera.position.lerp(orig, 0.6); } else { camera.position.x += (Math.random()-0.5)*0.03*(shakeTime/8); camera.position.y += (Math.random()-0.5)*0.03*(shakeTime/8); shakeTime -= 0.8; } }, 16); }

/* Utilities */
function onResize(){ if(!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
function initThreeIfNeeded(){ if(!scene) initThree(); }
initThree(); initControls(); // preload so menu has scene/background

// demo zombies in menu so it feels alive (they won't attack)
for(let i=0;i<4;i++) spawnZombie(null, true);

// load highscore
const storedHigh = parseInt(localStorage.getItem('z13_high') || '0', 10); highEl.textContent = storedHigh;

/* UI wiring (start/retry etc) */
startBtn.addEventListener('click', ()=> {
  ensureAudio();
  startMenuAmbience();
  // small visual feedback then start
  startBtn.disabled = true;
  setTimeout(()=> { startBtn.disabled = false; startGame(); }, 300);
});
retryBtn.addEventListener('click', ()=> {
  gameOverDiv.style.display = 'none';
  menu.style.display = 'none';
  startGame();
});
creditsBtn.addEventListener('click', ()=> { alert('Z-13: The Quarantine\\nDeveloped by Six\\nThank you for playing.'); });
settingsBtn.addEventListener('click', ()=> { alert('Settings (placeholder)'); });
quitBtn.addEventListener('click', ()=> { menu.style.display = 'none'; menu.style.opacity = '0'; stopMenuAmbience(); });

/* weapon switching helper already bound in keydown; add mouse hold for autos */
window.addEventListener('mousedown', ()=> mouseHeld = true);
window.addEventListener('mouseup', ()=> mouseHeld = false);
window.addEventListener('contextmenu', e => e.preventDefault());

/* small helpers (grenade/throw placeholders etc) */
function throwGrenade(){ throwGrenade; } // placeholder so not undefined when pressing G (actual implementation above)
function toggleView(){ /* left as FPS default */ }

/* End of file */
</script>
</body>
</html>
